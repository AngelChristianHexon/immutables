


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SillySubstructureRepository</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.fixture.subpack</a>
</div>

<h1>Coverage Summary for Class: SillySubstructureRepository (org.immutables.fixture.subpack)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
</tr>
  <tr>
    <td class="name">SillySubstructureRepository$Criteria</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Finder</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Indexer</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Modifier</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Replacer</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Serialization</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Serialization$SillySubstructureNamingFields</td>
  </tr>
  <tr>
    <td class="name">SillySubstructureRepository$Updater</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.immutables.fixture.subpack;
&nbsp;
&nbsp;import com.google.common.annotations.Beta;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.Range;
&nbsp;import com.mongodb.DBCollection;
&nbsp;import com.mongodb.DBObject;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.CheckReturnValue;
&nbsp;import javax.annotation.ParametersAreNonnullByDefault;
&nbsp;import javax.annotation.concurrent.Immutable;
&nbsp;import javax.annotation.concurrent.NotThreadSafe;
&nbsp;import javax.annotation.concurrent.ThreadSafe;
&nbsp;import org.bson.codecs.Encoder;
&nbsp;import org.bson.codecs.configuration.CodecRegistry;
&nbsp;import org.bson.conversions.Bson;
&nbsp;import org.immutables.mongo.concurrent.FluentFuture;
&nbsp;import org.immutables.mongo.repository.Repositories;
&nbsp;import org.immutables.mongo.repository.RepositorySetup;
&nbsp;import org.immutables.mongo.repository.internal.Constraints;
&nbsp;import org.immutables.mongo.repository.internal.Support;
&nbsp;import org.immutables.value.Generated;
&nbsp;
&nbsp;/**
&nbsp; * A {@code SillySubstructureRepository} provides type-safe access for storing and retrieving documents
&nbsp; * from the MongoDB collection {@code &quot;sillySubstructure&quot;}.
&nbsp; */
&nbsp;@Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;@SuppressWarnings({&quot;all&quot;})
&nbsp;@ParametersAreNonnullByDefault
&nbsp;@javax.annotation.processing.Generated(&quot;org.immutables.processor.ProxyProcessor&quot;)
&nbsp;@ThreadSafe
&nbsp;public class SillySubstructureRepository extends Repositories.Repository&lt;SillySubstructure&gt; {
&nbsp;  private static final String DOCUMENT_COLLECTION_NAME = &quot;sillySubstructure&quot;;
&nbsp;
&nbsp;  private final Serialization serialization;
&nbsp;  private final Criteria anyCriteria;
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a {@link SillySubstructure} repository using {@link RepositorySetup configuration}.
&nbsp;   * @param configuration The repository configuration
&nbsp;   */
&nbsp;  public SillySubstructureRepository(RepositorySetup configuration) {
&nbsp;    super(configuration, DOCUMENT_COLLECTION_NAME, SillySubstructure.class);
&nbsp;    this.serialization = new Serialization(codecRegistry(), fieldNamingStrategy());
&nbsp;    this.anyCriteria = new Criteria(this.serialization, Constraints.nilConstraint());
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Inserts a single document into the collection.
&nbsp;   * @param document The sillySubstructure to insert
&nbsp;   * @return A future representing the number of inserted documents (1) if WriteConcern allows the insertion.
&nbsp;   */
&nbsp;  public FluentFuture&lt;Integer&gt; insert(SillySubstructure document) {
&nbsp;    return super.doInsert(ImmutableList.of(document));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Insert documents into the collection.
&nbsp;   * @param documents The documents to insert
&nbsp;   * @return A future representing the number of inserted documents if WriteConcern allows the insertion.
&nbsp;   */
&nbsp;  public FluentFuture&lt;Integer&gt; insert(Iterable&lt;? extends SillySubstructure&gt; documents) {
&nbsp;    return super.doInsert(ImmutableList.copyOf(documents));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Finds all documents. Use the returned {@link Finder} object to complete
&nbsp;   * {@link Finder#fetchAll() fetch all} or other operations.
&nbsp;   * @return A finder object used to complete operations
&nbsp;   */
&nbsp;  @CheckReturnValue
&nbsp;  public Finder findAll() {
&nbsp;    return find(criteria());
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Find documents by the criteria expressed as a JSON string. Use the returned {@link Finder} object to complete
&nbsp;   * {@link Finder#fetchAll() fetch} or {@link Finder#fetchFirst() fetch} operations.
&nbsp;   * @param jsonCriteria A JSON string for native criteria
&nbsp;   * @return A finder object used to complete operations
&nbsp;   */
&nbsp;  @CheckReturnValue
&nbsp;  public Finder find(String jsonCriteria) {
&nbsp;    return new Finder(this, Support.jsonQuery(jsonCriteria));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Find a document by the given {@link SillySubstructureRepository#criteria() criteria}. Use the returned {@link Finder} object to complete
&nbsp;   * {@link Finder#fetchAll() fetch}  operations.
&nbsp;   * You can also use {@link Finder#andModifyFirst() modify} or {@link Finder#deleteFirst() delete}
&nbsp;   * operations to update / delete the document(s).
&nbsp;   * @param criteria The search criteria
&nbsp;   * @return A finder object used to complete operations
&nbsp;   */
&nbsp;  @CheckReturnValue
&nbsp;  public Finder find(Criteria criteria) {
&nbsp;    return new Finder(this, criteria.constraint);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The finder object used to proceed with find operations via the
&nbsp;   * {@link Finder#fetchAll()}, {@link Finder#fetchFirst()}, {@link Finder#andModifyFirst()}, or {@link Finder#deleteFirst()} methods.
&nbsp;   * Configure exclusion and sort ordering for results using the family of {@code exclude*()} and {@code orderBy*()} attribute-specific methods.
&nbsp;   * @see SillySubstructureRepository#find(Criteria)
&nbsp;   */
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @NotThreadSafe
&nbsp;  public static final class Finder extends Repositories.FinderWithDelete&lt;SillySubstructure, Finder&gt; {
&nbsp;    private final Serialization serialization;
&nbsp;
&nbsp;    private Finder(SillySubstructureRepository repository, Constraints.ConstraintHost criteria) {
&nbsp;      super(repository);
&nbsp;      this.criteria = criteria;
&nbsp;      this.serialization = repository.serialization;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#enum1() enum1} in the ascending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#enum1() enum1} attribute using ascending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderByEnum1() {
&nbsp;      ordering = ordering.equal(serialization.enum1Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#enum1() enum1} in the descending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#enum1() enum1} attribute using descending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderByEnum1Desceding() {
&nbsp;      ordering = ordering.equal(serialization.enum1Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#set2() set2} in the ascending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#set2() set2} attribute using ascending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderBySet2() {
&nbsp;      ordering = ordering.equal(serialization.set2Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#set2() set2} in the descending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#set2() set2} attribute using descending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderBySet2Desceding() {
&nbsp;      ordering = ordering.equal(serialization.set2Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#set3() set3} in the ascending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#set3() set3} attribute using ascending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderBySet3() {
&nbsp;      ordering = ordering.equal(serialization.set3Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#set3() set3} in the descending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#set3() set3} attribute using descending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderBySet3Desceding() {
&nbsp;      ordering = ordering.equal(serialization.set3Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#floats4() floats4} in the ascending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#floats4() floats4} attribute using ascending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderByFloats4() {
&nbsp;      ordering = ordering.equal(serialization.floats4Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Order by {@link SillySubstructure#floats4() floats4} in the descending direction.
&nbsp;     * Specify that the next attribute to sort will be the {@link SillySubstructure#floats4() floats4} attribute using descending order
&nbsp;     * in the the chain of comparisons performed to sort results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder orderByFloats4Desceding() {
&nbsp;      ordering = ordering.equal(serialization.floats4Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exclude the {@link SillySubstructure#set2() set2} attribute from each document in the results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder excludeSet2() {
&nbsp;      exclusion = exclusion.equal(serialization.set2Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exclude the {@link SillySubstructure#set3() set3} attribute from each document in the results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder excludeSet3() {
&nbsp;      exclusion = exclusion.equal(serialization.set3Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exclude the {@link SillySubstructure#floats4() floats4} attribute from each document in the results.
&nbsp;     * @return {@code this} finder for use in a chained invocation
&nbsp;     */
&nbsp;    public Finder excludeFloats4() {
&nbsp;      exclusion = exclusion.equal(serialization.floats4Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Turn a find operation into an atomic {@link DBCollection#findAndModify(DBObject, DBObject, DBObject, boolean, DBObject, boolean, boolean) findAndModify}
&nbsp;     * operation. Use the family of {@code set*()}, {@code unset*()}, {@code add*()}, {@code remove*()}, {@code put*()}m and {@code init*()}
&nbsp;     * (and other attribute-specific) methods to describe the modification.
&nbsp;     * @return A modifier object to complete the {@code findAndModify} operation
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public Modifier andModifyFirst() {
&nbsp;      return new Modifier((SillySubstructureRepository) repository, criteria, ordering, exclusion);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to replace in-place existing version of the document
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public Replacer andReplaceFirst(SillySubstructure document) {
&nbsp;      return new Replacer((SillySubstructureRepository) repository, document, criteria, ordering);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Update the set of {@code &quot;sillySubstructure&quot;} documents.
&nbsp;   * @param criteria The search criteria for update
&nbsp;   * @return An updater object that will be used to complete the update.
&nbsp;   */
&nbsp;  @CheckReturnValue
&nbsp;  public Updater update(Criteria criteria) {
&nbsp;    return new Updater(this, criteria);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * {@link #update(Criteria) Given} the criteria updater describes how to perform
&nbsp;   * update operations on sets of documents.
&nbsp;   */
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @NotThreadSafe
&nbsp;  public static final class Updater extends Repositories.Updater&lt;SillySubstructure&gt; {
&nbsp;    private final Serialization serialization;
&nbsp;
&nbsp;    private Updater(SillySubstructureRepository repository, Criteria criteria) {
&nbsp;      super(repository);
&nbsp;      this.criteria = criteria.constraint;
&nbsp;      this.serialization = repository.serialization;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify a new value for the {@code enum1} attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator.
&nbsp;     * @param value A new value for the {@code enum1} attribute
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater setEnum1(RetentionPolicy value) {
&nbsp;      setFields = setFields.equal(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify an initial value for the {@code enum1} attribute. The value will be used if the document is
&nbsp;     * to be inserted. If one or more documents are found for an update, this value will not be used.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $setOnInsert} operator.
&nbsp;     * @param value The {@code enum1} value for an insert.
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater initEnum1(RetentionPolicy value) {
&nbsp;      setOnInsertFields = setOnInsertFields.equal(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater clearSet2() {
&nbsp;      setFields = setFields.equal(serialization.set2Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater removeSet2(ElementType value) {
&nbsp;      pullFields = pullFields.equal(serialization.set2Name, false, Support.writable(serialization.set2Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addSet2(ElementType value) {
&nbsp;      pushFields = pushFields.equal(serialization.set2Name, false, Support.writable(serialization.set2Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code set2} set attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;     public Updater setSet2(Iterable&lt;ElementType&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (ElementType value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.set2Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.set2Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addAllSet2(Iterable&lt;ElementType&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (ElementType value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set2Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      pushFields = pushFields.equal(serialization.set2Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater clearSet3() {
&nbsp;      setFields = setFields.equal(serialization.set3Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater removeSet3(int value) {
&nbsp;      pullFields = pullFields.equal(serialization.set3Name, false, Support.writable(serialization.set3Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $addToSet} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addSet3(int value) {
&nbsp;      addToSetFields = addToSetFields.equal(serialization.set3Name, false, Support.writable(serialization.set3Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code set3} set attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;     public Updater setSet3(Iterable&lt;java.lang.Integer&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (java.lang.Integer value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.set3Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.set3Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $addToSet} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addAllSet3(Iterable&lt;java.lang.Integer&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (java.lang.Integer value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set3Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      addToSetFields = addToSetFields.equal(serialization.set3Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater clearFloats4() {
&nbsp;      setFields = setFields.equal(serialization.floats4Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater removeFloats4(float value) {
&nbsp;      pullFields = pullFields.equal(serialization.floats4Name, false, Support.writable(serialization.floats4Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addFloats4(float value) {
&nbsp;      pushFields = pushFields.equal(serialization.floats4Name, false, Support.writable(serialization.floats4Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code floats4} list attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;     public Updater setFloats4(Iterable&lt;Float&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (Float value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.floats4Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.floats4Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} updater to be used to complete the update operation
&nbsp;     */
&nbsp;    public Updater addAllFloats4(Iterable&lt;Float&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (Float value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.floats4Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      pushFields = pushFields.equal(serialization.floats4Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @NotThreadSafe
&nbsp;  public static final class Modifier extends Repositories.Modifier&lt;SillySubstructure, Modifier&gt; {
&nbsp;    private final Serialization serialization;
&nbsp;
&nbsp;    private Modifier(
&nbsp;        SillySubstructureRepository repository,
&nbsp;        Constraints.ConstraintHost criteria,
&nbsp;        Constraints.Constraint ordering,
&nbsp;        Constraints.Constraint exclusion) {
&nbsp;      super(repository);
&nbsp;      this.serialization = repository.serialization;
&nbsp;      this.criteria = criteria;
&nbsp;      this.ordering = ordering;
&nbsp;      this.exclusion = exclusion;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify a new value for the {@code enum1} attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator.
&nbsp;     * @param value A new value for the {@code enum1} attribute
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier setEnum1(RetentionPolicy value) {
&nbsp;      setFields = setFields.equal(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify an initial value for the {@code enum1} attribute. The value will be used if the document is
&nbsp;     * to be inserted. If one or more documents are found for an update, this value will not be used.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $setOnInsert} operator.
&nbsp;     * @param value The {@code enum1} value for an insert.
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier initEnum1(RetentionPolicy value) {
&nbsp;      setOnInsertFields = setOnInsertFields.equal(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier clearSet2() {
&nbsp;      setFields = setFields.equal(serialization.set2Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier removeSet2(ElementType value) {
&nbsp;      pullFields = pullFields.equal(serialization.set2Name, false, Support.writable(serialization.set2Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addSet2(ElementType value) {
&nbsp;      pushFields = pushFields.equal(serialization.set2Name, false, Support.writable(serialization.set2Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code set2} set attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;     public Modifier setSet2(Iterable&lt;ElementType&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (ElementType value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.set2Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.set2Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code set2} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addAllSet2(Iterable&lt;ElementType&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (ElementType value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set2Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      pushFields = pushFields.equal(serialization.set2Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier clearSet3() {
&nbsp;      setFields = setFields.equal(serialization.set3Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier removeSet3(int value) {
&nbsp;      pullFields = pullFields.equal(serialization.set3Name, false, Support.writable(serialization.set3Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $addToSet} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addSet3(int value) {
&nbsp;      addToSetFields = addToSetFields.equal(serialization.set3Name, false, Support.writable(serialization.set3Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code set3} set attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;     public Modifier setSet3(Iterable&lt;java.lang.Integer&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (java.lang.Integer value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.set3Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.set3Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code set3} set attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $addToSet} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addAllSet3(Iterable&lt;java.lang.Integer&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (java.lang.Integer value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set3Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      addToSetFields = addToSetFields.equal(serialization.set3Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Clear the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $set} operator resetting to empty array
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier clearFloats4() {
&nbsp;      setFields = setFields.equal(serialization.floats4Name, false, ImmutableList.&lt;Object&gt;of());
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove a value from the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $pull} operator.
&nbsp;     * @param value The value to remove
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier removeFloats4(float value) {
&nbsp;      pullFields = pullFields.equal(serialization.floats4Name, false, Support.writable(serialization.floats4Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a value to the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator.
&nbsp;     * @param value The value to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addFloats4(float value) {
&nbsp;      pushFields = pushFields.equal(serialization.floats4Name, false, Support.writable(serialization.floats4Encoder, value));
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Override all values of {@code floats4} list attribute.
&nbsp;     *
&nbsp;     * &lt;p&gt;Corresponds to the MongoDB {@code $set} operator on the array field.
&nbsp;     * @param values The values to set
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;     public Modifier setFloats4(Iterable&lt;Float&gt; values) {
&nbsp;       List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;       for (Float value : values) {
&nbsp;         wrappedValues.add(Support.writable(serialization.floats4Encoder, value));
&nbsp;       }
&nbsp;
&nbsp;       setFields = setFields.equal(serialization.floats4Name, false, wrappedValues);
&nbsp;       return this;
&nbsp;     }
&nbsp;
&nbsp;    /**
&nbsp;     * Add all of the given values to the {@code floats4} list attribute.
&nbsp;     * &lt;p&gt;
&nbsp;     * Corresponds to the MongoDB {@code $push} operator with the {@code $each} modifier.
&nbsp;     * @param values The values to add
&nbsp;     * @return {@code this} modifier to be used to complete the update operation
&nbsp;     */
&nbsp;    public Modifier addAllFloats4(Iterable&lt;Float&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (Float value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.floats4Encoder, value));
&nbsp;      }
&nbsp;      if (wrappedValues.isEmpty()) {
&nbsp;        return this;
&nbsp;      }
&nbsp;      Object v = wrappedValues.size() == 1
&nbsp;          ? wrappedValues.get(0)
&nbsp;          : Support.bsonObjectAttribute(&quot;$each&quot;, wrappedValues);
&nbsp;
&nbsp;      pushFields = pushFields.equal(serialization.floats4Name, false, v);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @NotThreadSafe
&nbsp;  public static final class Replacer extends Repositories.Replacer&lt;SillySubstructure, Replacer&gt; {
&nbsp;    protected Replacer(SillySubstructureRepository repository, SillySubstructure document, Constraints.ConstraintHost criteria, Constraints.Constraint ordering) {
&nbsp;      super(repository, document, criteria, ordering);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * {@link DBCollection#createIndex(DBObject, DBObject) Ensure an index} on collection sillySubstructure by one or
&nbsp;   * more attributes using the family of {@code with*()} attribute-specific methods.
&nbsp;   * While indexes will usually be maintained by special administration scripts, for simple cases it is convenient
&nbsp;   * to ensure an index on application startup.
&nbsp;   * @see Indexer#named(String)
&nbsp;   * @see Indexer#unique()
&nbsp;   * @return An indexer object to be completed with the {@link Indexer#ensure()} operation.
&nbsp;   */
&nbsp;  @CheckReturnValue
&nbsp;  public Indexer index() {
&nbsp;    return new Indexer(this);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * An indexer used to create an index on the {@code &quot;sillySubstructure&quot;} collection if it does not exist by one or more attributes.
&nbsp;   * @see DBCollection#createIndex(DBObject, DBObject)
&nbsp;   */
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @NotThreadSafe
&nbsp;  public static final class Indexer extends Repositories.Indexer&lt;SillySubstructure, Indexer&gt; {
&nbsp;    private final Serialization serialization;
&nbsp;
&nbsp;    private Indexer(SillySubstructureRepository repository) {
&nbsp;      super(repository);
&nbsp;      this.serialization = repository.serialization;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#enum1() enum1}, in the ascending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withEnum1() {
&nbsp;      fields = fields.equal(serialization.enum1Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#enum1() enum1}, in the descending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withEnum1Desceding() {
&nbsp;      fields = fields.equal(serialization.enum1Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#set2() set2}, in the ascending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withSet2() {
&nbsp;      fields = fields.equal(serialization.set2Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#set2() set2}, in the descending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withSet2Desceding() {
&nbsp;      fields = fields.equal(serialization.set2Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#set3() set3}, in the ascending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withSet3() {
&nbsp;      fields = fields.equal(serialization.set3Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#set3() set3}, in the descending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withSet3Desceding() {
&nbsp;      fields = fields.equal(serialization.set3Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#floats4() floats4}, in the ascending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withFloats4() {
&nbsp;      fields = fields.equal(serialization.floats4Name, false, 1);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specify that the next attribute to index will be {@link SillySubstructure#floats4() floats4}, in the descending direction.
&nbsp;     * @return {@code this} indexer for use in a chained invocation
&nbsp;     */
&nbsp;    public Indexer withFloats4Desceding() {
&nbsp;      fields = fields.equal(serialization.floats4Name, false, -1);
&nbsp;      return this;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Search criteria.
&nbsp;   * Returns an initial object to create criteria by invoking methods that describe attribute specific constraints.
&nbsp;   * @return An empty immutable criteria
&nbsp;   */
&nbsp;  public Criteria criteria() {
&nbsp;    return anyCriteria;
&nbsp;  }
&nbsp;
&nbsp;  @Beta
&nbsp;  Bson toBson(Criteria criteria) {
&nbsp;    return Support.convertToBson(criteria.constraint);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * {@code SillySubstructureRepository.Criteria} is a SillySubstructure document search query.
&nbsp;   * Call methods on the criteria to add constraints for search queries.
&nbsp;   */
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  @Immutable
&nbsp;  @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;  public static final class Criteria extends Repositories.Criteria {
&nbsp;    private final Constraints.Constraint constraint;
&nbsp;    private final Serialization serialization;
&nbsp;
&nbsp;    Criteria(Serialization serialization, Constraints.Constraint constraint) {
&nbsp;      this.constraint = constraint;
&nbsp;      this.serialization = serialization;
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1(RetentionPolicy value) {
&nbsp;      return new Criteria(serialization, constraint.equal(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, value)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1Not(RetentionPolicy value) {
&nbsp;      return new Criteria(serialization, constraint.equal(serialization.enum1Name, true, Support.writable(serialization.enum1Encoder, value)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1In(Iterable&lt;RetentionPolicy&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (RetentionPolicy value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.enum1Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.in(serialization.enum1Name, false, wrappedValues));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1In(RetentionPolicy first, RetentionPolicy second, RetentionPolicy... rest) {
&nbsp;      List&lt;Object&gt; values = new ArrayList&lt;&gt;(2 + rest.length);
&nbsp;      values.add(Support.writable(serialization.enum1Encoder, first));
&nbsp;      values.add(Support.writable(serialization.enum1Encoder, second));
&nbsp;      for (RetentionPolicy value : rest) {
&nbsp;        values.add(Support.writable(serialization.enum1Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.in(serialization.enum1Name, false, values));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1NotIn(Iterable&lt;RetentionPolicy&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (RetentionPolicy value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.enum1Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.in(serialization.enum1Name, true, wrappedValues));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1NotIn(RetentionPolicy first, RetentionPolicy second, RetentionPolicy... rest) {
&nbsp;      List&lt;Object&gt; values = new ArrayList&lt;&gt;(2 + rest.length);
&nbsp;      values.add(Support.writable(serialization.enum1Encoder, first));
&nbsp;      values.add(Support.writable(serialization.enum1Encoder, second));
&nbsp;      for (RetentionPolicy value : rest) {
&nbsp;        values.add(Support.writable(serialization.enum1Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.in(serialization.enum1Name, true, values));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1GreaterThan(RetentionPolicy lower) {
&nbsp;      return enum1In(Range.greaterThan(lower));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1LessThan(RetentionPolicy upper) {
&nbsp;      return enum1In(Range.lessThan(upper));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1AtMost(RetentionPolicy upperInclusive) {
&nbsp;      return enum1In(Range.atMost(upperInclusive));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1AtLeast(RetentionPolicy lowerInclusive) {
&nbsp;      return enum1In(Range.atLeast(lowerInclusive));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1In(Range&lt;RetentionPolicy&gt; range) {
&nbsp;      return new Criteria(serialization, constraint.range(serialization.enum1Name, false, Support.writable(serialization.enum1Encoder, range)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria enum1NotIn(Range&lt;RetentionPolicy&gt; range) {
&nbsp;      return new Criteria(serialization, constraint.range(serialization.enum1Name, true, Support.writable(serialization.enum1Encoder, range)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set2Empty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set2Name, false, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set2NonEmpty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set2Name, true, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set2Size(int size) {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set2Name, false, size));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set2Contains(ElementType value) {
&nbsp;      return new Criteria(serialization, constraint.equal(serialization.set2Name, false, Support.writable(serialization.set2Encoder, value)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set2ContainsAll(Iterable&lt;ElementType&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (ElementType value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set2Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.nested(serialization.set2Name, Constraints.nilConstraint().equal(&quot;$all&quot;, false, wrappedValues)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set3Empty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set3Name, false, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set3NonEmpty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set3Name, true, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set3Size(int size) {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.set3Name, false, size));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set3Contains(int value) {
&nbsp;      return new Criteria(serialization, constraint.equal(serialization.set3Name, false, Support.writable(serialization.set3Encoder, value)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria set3ContainsAll(Iterable&lt;java.lang.Integer&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (java.lang.Integer value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.set3Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.nested(serialization.set3Name, Constraints.nilConstraint().equal(&quot;$all&quot;, false, wrappedValues)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria floats4Empty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.floats4Name, false, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria floats4NonEmpty() {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.floats4Name, true, 0));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria floats4Size(int size) {
&nbsp;      return new Criteria(serialization, constraint.size(serialization.floats4Name, false, size));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria floats4Contains(float value) {
&nbsp;      return new Criteria(serialization, constraint.equal(serialization.floats4Name, false, Support.writable(serialization.floats4Encoder, value)));
&nbsp;    }
&nbsp;
&nbsp;    public Criteria floats4ContainsAll(Iterable&lt;Float&gt; values) {
&nbsp;      List&lt;Object&gt; wrappedValues = new ArrayList&lt;&gt;();
&nbsp;      for (Float value : values) {
&nbsp;        wrappedValues.add(Support.writable(serialization.floats4Encoder, value));
&nbsp;      }
&nbsp;      return new Criteria(serialization, constraint.nested(serialization.floats4Name, Constraints.nilConstraint().equal(&quot;$all&quot;, false, wrappedValues)));
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Criteria or() {
&nbsp;      return new Criteria(serialization, constraint.disjunction());
&nbsp;    }
&nbsp;
&nbsp;    public Criteria with(Criteria criteria) {
&nbsp;      return new Criteria(serialization, criteria.constraint.accept(constraint));
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;SillySubstructureRepository.criteria(&quot; + Support.stringify(constraint) + &quot;)&quot;;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;  private static class Serialization {
&nbsp;    final Encoder&lt;RetentionPolicy&gt; enum1Encoder;
&nbsp;    final Encoder&lt;ElementType&gt; set2Encoder;
&nbsp;    final Encoder&lt;java.lang.Integer&gt; set3Encoder;
&nbsp;    final Encoder&lt;Float&gt; floats4Encoder;
&nbsp;    final CodecRegistry registry;
&nbsp;    final String enum1Name;
&nbsp;    final String set2Name;
&nbsp;    final String set3Name;
&nbsp;    final String floats4Name;
&nbsp;
&nbsp;    Serialization(CodecRegistry registry, RepositorySetup.FieldNamingStrategy fieldNamingStrategy) {
&nbsp;      this.registry = registry;
&nbsp;      this.enum1Encoder = this.registry.get(RetentionPolicy.class);
&nbsp;      this.set2Encoder = this.registry.get(ElementType.class);
&nbsp;      this.set3Encoder = this.registry.get(java.lang.Integer.class);
&nbsp;      this.floats4Encoder = this.registry.get(Float.class);
&nbsp;      this.enum1Name = &quot;e1&quot;;
&nbsp;      this.set2Name = translateName(fieldNamingStrategy, &quot;set2&quot;);
&nbsp;      this.set3Name = translateName(fieldNamingStrategy, &quot;set3&quot;);
&nbsp;      this.floats4Name = translateName(fieldNamingStrategy, &quot;floats4&quot;);
&nbsp;    }
&nbsp;
&nbsp;    @Generated(from = &quot;SillySubstructure&quot;, generator = &quot;Repositories&quot;)
&nbsp;    static final class SillySubstructureNamingFields {
&nbsp;      public RetentionPolicy enum1;
&nbsp;      public Set&lt;ElementType&gt; set2;
&nbsp;      public Set&lt;java.lang.Integer&gt; set3;
&nbsp;      public List&lt;Float&gt; floats4;
&nbsp;    }
&nbsp;
&nbsp;    private static String translateName(RepositorySetup.FieldNamingStrategy fieldNamingStrategy, String fieldName) {
&nbsp;      try {
&nbsp;        return fieldNamingStrategy.translateName(
&nbsp;            SillySubstructureNamingFields.class.getField(fieldName));
&nbsp;      } catch (NoSuchFieldException noSuchField) {
&nbsp;        throw new AssertionError(noSuchField);
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
