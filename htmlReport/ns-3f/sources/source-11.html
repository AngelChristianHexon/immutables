


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SourceExtraction</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.generator</a>
</div>

<h1>Coverage Summary for Class: SourceExtraction (org.immutables.generator)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SourceExtraction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SourceExtraction$1</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$CompositeExtractor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$DefaultExtractor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$EclipseSourceExtractor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/75)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$Imports</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (9/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$JavacSourceExtractor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SourceExtraction$SourceExtractor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    8.1%
  </span>
  <span class="absValue">
    (3/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2%
  </span>
  <span class="absValue">
    (2/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.6%
  </span>
  <span class="absValue">
    (9/160)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2016 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.generator;
&nbsp;
&nbsp;import com.google.common.base.CharMatcher;
&nbsp;import com.google.common.base.MoreObjects;
&nbsp;import com.google.common.collect.ImmutableMap;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Maps;
&nbsp;import com.google.common.io.CharStreams;
&nbsp;import com.sun.tools.javac.code.Symbol.ClassSymbol;
&nbsp;import com.sun.tools.javac.code.Symbol.MethodSymbol;
&nbsp;import com.sun.tools.javac.code.Symbol.VarSymbol;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Reader;
&nbsp;import java.nio.CharBuffer;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.Set;
&nbsp;import java.util.StringTokenizer;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.tools.Diagnostic;
&nbsp;import javax.tools.FileObject;
&nbsp;import javax.tools.StandardLocation;
&nbsp;import org.eclipse.jdt.internal.compiler.apt.model.ElementImpl;
&nbsp;import org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl;
&nbsp;import org.eclipse.jdt.internal.compiler.apt.model.TypeElementImpl;
&nbsp;import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
&nbsp;import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
&nbsp;import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
&nbsp;import org.eclipse.jdt.internal.compiler.lookup.Binding;
&nbsp;import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
&nbsp;import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
&nbsp;import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
&nbsp;
&nbsp;public final class SourceExtraction {
&nbsp;  private SourceExtraction() {}
&nbsp;
&nbsp;  public static final class Imports {
<b class="fc">&nbsp;    private static final Imports EMPTY = new Imports(</b>
<b class="fc">&nbsp;        ImmutableSet.&lt;String&gt;of(),</b>
<b class="fc">&nbsp;        ImmutableMap.&lt;String, String&gt;of());</b>
&nbsp;
&nbsp;    public final ImmutableSet&lt;String&gt; all;
&nbsp;    public final ImmutableMap&lt;String, String&gt; classes;
&nbsp;
<b class="fc">&nbsp;    private Imports(Set&lt;String&gt; all, Map&lt;String, String&gt; classes) {</b>
<b class="fc">&nbsp;      this.all = ImmutableSet.copyOf(all);</b>
<b class="fc">&nbsp;      this.classes = ImmutableMap.copyOf(classes);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Imports of(Set&lt;String&gt; all, Map&lt;String, String&gt; classes) {
<b class="pc">&nbsp;      if (all.isEmpty() &amp;&amp; classes.isEmpty()) {</b>
<b class="nc">&nbsp;        return EMPTY;</b>
&nbsp;      }
<b class="pc">&nbsp;      if (!all.containsAll(classes.values())) {</b>
&nbsp;        // This check initially appeared as some imports might be skipped,
&nbsp;        // but all classes imported are tracked, but it should be not a problem
&nbsp;      }
<b class="fc">&nbsp;      return new Imports(all, classes);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Imports empty() {
<b class="nc">&nbsp;      return EMPTY;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;      return this == EMPTY;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return MoreObjects.toStringHelper(this)</b>
<b class="nc">&nbsp;          .add(&quot;all&quot;, all)</b>
<b class="nc">&nbsp;          .add(&quot;classes&quot;, classes)</b>
<b class="nc">&nbsp;          .toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public static CharSequence headerFrom(CharSequence source) {
<b class="nc">&nbsp;    if (source.length() != 0) {</b>
<b class="nc">&nbsp;      return PostprocessingMachine.collectHeader(source);</b>
&nbsp;    }
<b class="nc">&nbsp;    return SourceExtractor.UNABLE_TO_EXTRACT;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static Imports importsFrom(CharSequence source) {
<b class="nc">&nbsp;    if (source.length() != 0) {</b>
<b class="nc">&nbsp;      return PostprocessingMachine.collectImports(source);</b>
&nbsp;    }
<b class="nc">&nbsp;    return Imports.empty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public static CharSequence extract(ProcessingEnvironment processing, TypeElement element) {
&nbsp;    try {
<b class="nc">&nbsp;      return EXTRACTOR.extract(processing, element);</b>
<b class="nc">&nbsp;    } catch (UnsupportedOperationException | IllegalArgumentException cannotReadSourceFile) {</b>
<b class="nc">&nbsp;    } catch (IOException cannotReadSourceFile) {</b>
&nbsp;      if (moreDiagnostic) {
&nbsp;        processing.getMessager().printMessage(
&nbsp;            Diagnostic.Kind.NOTE,
&nbsp;            String.format(&quot;Was unable to read source file for %s[%s.class]: %s&quot;,
&nbsp;                element,
&nbsp;                element.getClass().getName(),
&nbsp;                cannotReadSourceFile));
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return SourceExtractor.UNABLE_TO_EXTRACT;</b>
&nbsp;  }
&nbsp;
&nbsp;  interface SourceExtractor {
<b class="nc">&nbsp;    CharSequence UNABLE_TO_EXTRACT = &quot;&quot;;</b>
&nbsp;
&nbsp;    boolean claim(Element element);
&nbsp;
&nbsp;    CharSequence extract(ProcessingEnvironment environment, TypeElement typeElement) throws IOException;
&nbsp;
&nbsp;    CharSequence extractReturnType(ExecutableElement executableElement);
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final class DefaultExtractor implements SourceExtractor {</b>
<b class="nc">&nbsp;    static final DefaultExtractor INSTANCE = new DefaultExtractor();</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extract(ProcessingEnvironment environment, TypeElement element) throws IOException {
&nbsp;      try {
<b class="nc">&nbsp;        FileObject resource = environment.getFiler().getResource(</b>
&nbsp;            StandardLocation.SOURCE_PATH,
&nbsp;            &quot;&quot;,
<b class="nc">&nbsp;            toFilename(element));</b>
<b class="nc">&nbsp;        try (Reader r = resource.openReader(true)) {</b>
<b class="nc">&nbsp;          return CharStreams.toString(r);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      } catch (UnsupportedOperationException | IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;        return UNABLE_TO_EXTRACT;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    private String toFilename(TypeElement element) {
<b class="nc">&nbsp;      return element.getQualifiedName().toString().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.java&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extractReturnType(ExecutableElement executableElement) {
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean claim(Element element) {
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final class JavacSourceExtractor implements SourceExtractor {</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean claim(Element element) {
<b class="nc">&nbsp;      return element instanceof ClassSymbol</b>
&nbsp;          || element instanceof MethodSymbol
&nbsp;          || element instanceof VarSymbol;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extract(ProcessingEnvironment environment, TypeElement typeElement) throws IOException {
<b class="nc">&nbsp;      if (typeElement instanceof ClassSymbol) {</b>
<b class="nc">&nbsp;        ClassSymbol classSymbol = (ClassSymbol) typeElement;</b>
<b class="nc">&nbsp;        if (classSymbol.sourcefile != null) {</b>
<b class="nc">&nbsp;          try (Reader r = classSymbol.sourcefile.openReader(true)) {</b>
<b class="nc">&nbsp;            return CharStreams.toString(r);</b>
<b class="nc">&nbsp;          }</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extractReturnType(ExecutableElement executableElement) {
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final class EclipseSourceExtractor implements SourceExtractor {</b>
&nbsp;    @Override
&nbsp;    public boolean claim(Element element) {
<b class="nc">&nbsp;      return element instanceof ElementImpl;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extract(ProcessingEnvironment environment, TypeElement typeElement) throws IOException {
<b class="nc">&nbsp;      if (typeElement instanceof ElementImpl) {</b>
<b class="nc">&nbsp;        Binding binding = ((ElementImpl) typeElement)._binding;</b>
<b class="nc">&nbsp;        if (binding instanceof SourceTypeBinding) {</b>
<b class="nc">&nbsp;          CompilationUnitDeclaration unit = ((SourceTypeBinding) binding).scope.referenceCompilationUnit();</b>
<b class="nc">&nbsp;          char[] contents = unit.compilationResult.compilationUnit.getContents();</b>
<b class="nc">&nbsp;          return CharBuffer.wrap(contents);</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extractReturnType(ExecutableElement executableElement) {
<b class="nc">&nbsp;      if (executableElement instanceof ExecutableElementImpl) {</b>
<b class="nc">&nbsp;        Binding binding = ((ExecutableElementImpl) executableElement)._binding;</b>
<b class="nc">&nbsp;        if (binding instanceof MethodBinding) {</b>
<b class="nc">&nbsp;          MethodBinding methodBinding = (MethodBinding) binding;</b>
&nbsp;
<b class="nc">&nbsp;          @Nullable AbstractMethodDeclaration sourceMethod = methodBinding.sourceMethod();</b>
<b class="nc">&nbsp;          if (sourceMethod != null) {</b>
<b class="nc">&nbsp;            CharSequence rawType = getRawType(methodBinding);</b>
<b class="nc">&nbsp;            char[] content = sourceMethod.compilationResult.compilationUnit.getContents();</b>
&nbsp;
<b class="nc">&nbsp;            int sourceEnd = methodBinding.sourceStart();// intentionaly</b>
<b class="nc">&nbsp;            int sourceStart = scanForTheSourceStart(content, sourceEnd);</b>
&nbsp;
<b class="nc">&nbsp;            char[] methodTest = Arrays.copyOfRange(content, sourceStart, sourceEnd);</b>
&nbsp;
<b class="nc">&nbsp;            Entry&lt;String, List&lt;String&gt;&gt; extracted =</b>
<b class="nc">&nbsp;                SourceTypes.extract(String.valueOf(methodTest));</b>
&nbsp;
<b class="nc">&nbsp;            return SourceTypes.stringify(</b>
<b class="nc">&nbsp;                Maps.immutableEntry(rawType.toString(), extracted.getValue()));</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int scanForTheSourceStart(char[] content, int sourceEnd) {
<b class="nc">&nbsp;      int i = sourceEnd;</b>
<b class="nc">&nbsp;      for (; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;        char c = content[i];</b>
&nbsp;        // FIXME how else I can scan?
<b class="nc">&nbsp;        if (c == &#39;\n&#39;) {</b>
<b class="nc">&nbsp;          return i;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return i;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence extractSuperclass(SourceTypeBinding binding) {
<b class="nc">&nbsp;      CharSequence declaration = readSourceDeclaration(binding);</b>
<b class="nc">&nbsp;      StringTokenizer tokenizer = new StringTokenizer(declaration.toString(), &quot;&lt;&gt;, \t\n\r&quot;, true);</b>
<b class="nc">&nbsp;      int genericsOpened = 0;</b>
<b class="nc">&nbsp;      while (tokenizer.hasMoreTokens()) {</b>
<b class="nc">&nbsp;        String t = tokenizer.nextToken();</b>
<b class="nc">&nbsp;        if (t.equals(&quot;&lt;&quot;)) {</b>
<b class="nc">&nbsp;          genericsOpened++;</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.equals(&quot;&gt;&quot;)) {</b>
<b class="nc">&nbsp;          genericsOpened--;</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (genericsOpened &gt; 0) {</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.equals(&quot;extends&quot;)) {</b>
<b class="nc">&nbsp;          return readSourceSuperclass(tokenizer);</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return UNABLE_TO_EXTRACT;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence readSourceSuperclass(StringTokenizer tokenizer) {
<b class="nc">&nbsp;      StringBuilder superclass = new StringBuilder();</b>
<b class="nc">&nbsp;      while (tokenizer.hasMoreTokens()) {</b>
<b class="nc">&nbsp;        String part = tokenizer.nextToken();</b>
<b class="nc">&nbsp;        if (CharMatcher.whitespace().matchesAllOf(part)) {</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (superclass.length() == 0</b>
<b class="nc">&nbsp;            || part.charAt(0) == &#39;.&#39;</b>
<b class="nc">&nbsp;            || superclass.charAt(superclass.length() - 1) == &#39;.&#39;) {</b>
<b class="nc">&nbsp;          superclass.append(part);</b>
&nbsp;        } else {
&nbsp;          break;
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return superclass;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence readSourceDeclaration(SourceTypeBinding binding) {
<b class="nc">&nbsp;      TypeDeclaration referenceContext = binding.scope.referenceContext;</b>
<b class="nc">&nbsp;      char[] content = referenceContext.compilationResult.compilationUnit.getContents();</b>
<b class="nc">&nbsp;      int start = referenceContext.declarationSourceStart;</b>
<b class="nc">&nbsp;      int end = referenceContext.declarationSourceEnd;</b>
&nbsp;
<b class="nc">&nbsp;      StringBuilder declaration = new StringBuilder();</b>
<b class="nc">&nbsp;      for (int p = start; p &lt;= end; p++) {</b>
<b class="nc">&nbsp;        char c = content[p];</b>
<b class="nc">&nbsp;        if (c == &#39;{&#39;) {</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        }
<b class="nc">&nbsp;        declaration.append(c);</b>
&nbsp;      }
<b class="nc">&nbsp;      return declaration;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence getRawType(MethodBinding methodBinding) {
<b class="nc">&nbsp;      TypeBinding returnType = methodBinding.returnType;</b>
<b class="nc">&nbsp;      char[] sourceName = returnType.sourceName();</b>
<b class="nc">&nbsp;      if (sourceName == null) {</b>
<b class="nc">&nbsp;        sourceName = new char[] {};</b>
&nbsp;      }
<b class="nc">&nbsp;      return CharBuffer.wrap(sourceName);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static final class CompositeExtractor implements SourceExtractor {
&nbsp;    private final SourceExtractor[] extractors;
&nbsp;
<b class="nc">&nbsp;    CompositeExtractor(List&lt;SourceExtractor&gt; extractors) {</b>
<b class="nc">&nbsp;      this.extractors = extractors.toArray(new SourceExtractor[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean claim(Element element) {
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extract(ProcessingEnvironment environment, TypeElement typeElement) throws IOException {
<b class="nc">&nbsp;      for (SourceExtractor extractor : extractors) {</b>
<b class="nc">&nbsp;        CharSequence source = extractor.extract(environment, typeElement);</b>
<b class="nc">&nbsp;        if (!source.equals(UNABLE_TO_EXTRACT)) {</b>
<b class="nc">&nbsp;          return source;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (extractor.claim(typeElement)) {</b>
&nbsp;          // cannot extract, but an extractor knows for sure
&nbsp;          // that it was his case which it may claim, then no
&nbsp;          // need to consult other extractors, which actually might
&nbsp;          // cause additional trouble.
<b class="nc">&nbsp;          return UNABLE_TO_EXTRACT;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return DefaultExtractor.INSTANCE.extract(environment, typeElement);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CharSequence extractReturnType(ExecutableElement executableElement) {
<b class="nc">&nbsp;      for (SourceExtractor extractor : extractors) {</b>
<b class="nc">&nbsp;        CharSequence source = extractor.extractReturnType(executableElement);</b>
<b class="nc">&nbsp;        if (!source.equals(UNABLE_TO_EXTRACT)) {</b>
<b class="nc">&nbsp;          return source;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (extractor.claim(executableElement)) {</b>
&nbsp;          // cannot extract, but an extractor knows for sure
&nbsp;          // that it was his case which it may claim, then no
&nbsp;          // need to consult other extractors, which actually might
&nbsp;          // cause additional trouble.
<b class="nc">&nbsp;          return UNABLE_TO_EXTRACT;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return DefaultExtractor.INSTANCE.extractReturnType(executableElement);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static SourceExtractor createExtractor() {
<b class="nc">&nbsp;    if (Compiler.ECJ.isPresent() || Compiler.JAVAC.isPresent()) {</b>
<b class="nc">&nbsp;      List&lt;SourceExtractor&gt; extractors = Lists.newArrayListWithCapacity(2);</b>
<b class="nc">&nbsp;      if (Compiler.ECJ.isPresent()) {</b>
<b class="nc">&nbsp;        extractors.add(new EclipseSourceExtractor());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (Compiler.JAVAC.isPresent()) {</b>
<b class="nc">&nbsp;        extractors.add(new JavacSourceExtractor());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (extractors.size() == 1) {</b>
<b class="nc">&nbsp;        return extractors.get(0);</b>
&nbsp;      }
<b class="nc">&nbsp;      return new CompositeExtractor(extractors);</b>
&nbsp;    }
<b class="nc">&nbsp;    return DefaultExtractor.INSTANCE;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final SourceExtractor EXTRACTOR = createExtractor();</b>
&nbsp;
&nbsp;  public static CharSequence getReturnTypeString(ExecutableElement method) {
<b class="nc">&nbsp;    return EXTRACTOR.extractReturnType(method);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static String getSuperclassString(TypeElement element) {
<b class="nc">&nbsp;    if (Compiler.ECJ.isPresent()) {</b>
<b class="nc">&nbsp;      if (element instanceof TypeElementImpl) {</b>
<b class="nc">&nbsp;        TypeElementImpl elementImpl = ((TypeElementImpl) element);</b>
<b class="nc">&nbsp;        if (elementImpl._binding instanceof SourceTypeBinding) {</b>
<b class="nc">&nbsp;          return EclipseSourceExtractor.extractSuperclass((SourceTypeBinding) elementImpl._binding).toString();</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return element.getSuperclass().toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  // IDK what would be the appropriate way to configure this, for now, we just disable this
&nbsp;  private static final boolean moreDiagnostic = false;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
