


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CriteriaModel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: CriteriaModel (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CriteriaModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/118)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CriteriaModel$1</td>
  </tr>
  <tr>
    <td class="name">CriteriaModel$ContainerDef</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CriteriaModel$CreatorVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CriteriaModel$IntrospectedType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CriteriaModel$MatcherDef</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CriteriaModel$MatcherDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/182)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/231)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2019 Immutables Authors and Contributors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import org.immutables.value.processor.encode.Type;
&nbsp;import org.immutables.value.processor.encode.TypeExtractor;
&nbsp;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.util.Elements;
&nbsp;import javax.lang.model.util.Types;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;/**
&nbsp; * Creates several matchers programmatically based on {@link ValueAttribute}.
&nbsp; * {@code StringMatcher}, {@code WithMatcher}, {@code NotMatcher} etc.
&nbsp; */
&nbsp;public class CriteriaModel {
&nbsp;
&nbsp;
&nbsp;  private static final String MATCHER = &quot;org.immutables.criteria.matcher.Matcher&quot;;
&nbsp;
<b class="nc">&nbsp;  private static final Iterable&lt;Type.Defined&gt; NO_BOUNDS = Collections.emptyList();</b>
&nbsp;
&nbsp;  private final ValueAttribute attribute;
&nbsp;  private final Type.Factory factory;
&nbsp;  private final Elements elements;
&nbsp;  private final Types types;
&nbsp;  private final IntrospectedType introspectedType;
&nbsp;  private final MatcherDefinition matcherDefinition;
&nbsp;
<b class="nc">&nbsp;  CriteriaModel(ValueAttribute attribute) {</b>
<b class="nc">&nbsp;    this.attribute = Preconditions.checkNotNull(attribute, &quot;attribute&quot;);</b>
<b class="nc">&nbsp;    this.factory = new Type.Producer();</b>
<b class="nc">&nbsp;    ProcessingEnvironment env = attribute.containingType.constitution.protoclass().environment().processing();</b>
<b class="nc">&nbsp;    this.elements = env.getElementUtils();</b>
<b class="nc">&nbsp;    this.types = env.getTypeUtils();</b>
<b class="nc">&nbsp;    this.introspectedType = new IntrospectedType(attribute.returnType, attribute.isNullable(), env.getTypeUtils(), env.getElementUtils());</b>
<b class="nc">&nbsp;    this.matcherDefinition = new MatcherDefinition(attribute, buildMatcher());</b>
&nbsp;
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static class IntrospectedType {</b>
&nbsp;
&nbsp;    private final TypeMirror type;
&nbsp;    private final Types types;
&nbsp;    private final Elements elements;
&nbsp;    private final boolean nullable;
&nbsp;
&nbsp;    // type erasure will be boxed for primitive types
&nbsp;    private final TypeMirror erasure;
&nbsp;
<b class="nc">&nbsp;    IntrospectedType(TypeMirror type, boolean nullable, Types types, Elements elements) {</b>
<b class="nc">&nbsp;      this.types = types;</b>
<b class="nc">&nbsp;      this.elements = elements;</b>
<b class="nc">&nbsp;      this.type = Preconditions.checkNotNull(type, &quot;type&quot;);</b>
<b class="nc">&nbsp;      this.nullable = nullable;</b>
&nbsp;
<b class="nc">&nbsp;      TypeMirror erasure = types.erasure(type);</b>
<b class="nc">&nbsp;      if (erasure.getKind().isPrimitive()) {</b>
<b class="nc">&nbsp;        erasure = types.boxedClass(MoreTypes.asPrimitiveType(erasure)).asType();</b>
&nbsp;      }
<b class="nc">&nbsp;      this.erasure = erasure;</b>
&nbsp;    }
&nbsp;
&nbsp;    public TypeMirror type() {
<b class="nc">&nbsp;      return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    public IntrospectedType withType(TypeMirror type) {
<b class="nc">&nbsp;      return new IntrospectedType(type, false, types, elements);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isSubtypeOf(Class&lt;?&gt; maybeSuper) {
<b class="nc">&nbsp;      Objects.requireNonNull(maybeSuper, &quot;maybeSuper&quot;);</b>
<b class="nc">&nbsp;      return isSubtypeOf(elements.getTypeElement(maybeSuper.getCanonicalName()));</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isSubtypeOf(Element element) {
<b class="nc">&nbsp;      Objects.requireNonNull(element, &quot;element&quot;);</b>
<b class="nc">&nbsp;      final TypeMirror maybeSuperType = element.asType();</b>
<b class="nc">&nbsp;      return types.isSubtype(erasure, types.erasure(maybeSuperType));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isBoolean() {
<b class="nc">&nbsp;      return type.getKind() == TypeKind.BOOLEAN ||</b>
<b class="nc">&nbsp;              isSubtypeOf(Boolean.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isNumber() {
<b class="nc">&nbsp;      return type.getKind().isPrimitive() &amp;&amp; !isBoolean() &amp;&amp; type.getKind() != TypeKind.CHAR || isSubtypeOf(Number.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isInteger() {
<b class="nc">&nbsp;      return type.getKind() == TypeKind.INT || isSubtypeOf(Integer.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isLong() {
<b class="nc">&nbsp;      return type.getKind() == TypeKind.LONG || isSubtypeOf(Long.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isDouble() {
<b class="nc">&nbsp;      return type.getKind() == TypeKind.DOUBLE || isSubtypeOf(Double.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isBigInteger() {
<b class="nc">&nbsp;      return isSubtypeOf(BigInteger.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isBigDecimal() {
<b class="nc">&nbsp;      return isSubtypeOf(BigDecimal.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isContainer() {
<b class="nc">&nbsp;      return isIterable() || isOptional() || isArray() || isMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isScalar() {
<b class="nc">&nbsp;      return !isContainer();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEnum() {
<b class="nc">&nbsp;      return types.asElement(type).getKind() == ElementKind.ENUM;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isIterable() {
<b class="nc">&nbsp;      return isSubtypeOf(Iterable.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isArray() {
<b class="nc">&nbsp;      return type.getKind() == TypeKind.ARRAY;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasOptionalMatcher() {
<b class="nc">&nbsp;      return isString() || isComparable() || isBoolean() || isNumber();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isComparable() {
<b class="nc">&nbsp;      return isSubtypeOf(Comparable.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isString() {
<b class="nc">&nbsp;      return isSubtypeOf(String.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isMap() {
<b class="nc">&nbsp;      return isSubtypeOf(Map.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isMatcher() {
<b class="nc">&nbsp;      return isSubtypeOf(elements.getTypeElement(&quot;org.immutables.criteria.matcher.Matcher&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    public TypeMirror box() {
<b class="nc">&nbsp;      return type.getKind().isPrimitive() ? types.boxedClass(MoreTypes.asPrimitiveType(type)).asType() : type;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasCriteria() {
<b class="nc">&nbsp;      final Element element = types.asElement(type);</b>
<b class="nc">&nbsp;      return element != null &amp;&amp; CriteriaMirror.find(element).isPresent();</b>
&nbsp;    }
&nbsp;
&nbsp;    private IntrospectedType optionalParameter() {
<b class="nc">&nbsp;      if (isNullable()) {</b>
<b class="nc">&nbsp;        return withType(type);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final String typeName = erasure.toString();</b>
&nbsp;      final TypeMirror newType;
<b class="nc">&nbsp;      if (&quot;java.util.OptionalInt&quot;.equals(typeName)) {</b>
<b class="nc">&nbsp;        newType = elements.getTypeElement(Integer.class.getName()).asType();</b>
<b class="nc">&nbsp;      } else if (&quot;java.util.OptionalLong&quot;.equals(typeName)) {</b>
<b class="nc">&nbsp;        newType = elements.getTypeElement(Long.class.getName()).asType();</b>
<b class="nc">&nbsp;      } else if (&quot;java.util.OptionalDouble&quot;.equals(typeName)) {</b>
<b class="nc">&nbsp;        newType = elements.getTypeElement(Double.class.getName()).asType();</b>
<b class="nc">&nbsp;      } else if (&quot;java.util.Optional&quot;.equals(typeName)</b>
<b class="nc">&nbsp;          || &quot;com.google.common.base.Optional&quot;.equals(typeName)</b>
<b class="nc">&nbsp;          || &quot;io.atlassian.fugue.Option&quot;.equals(typeName)) {</b>
<b class="nc">&nbsp;        newType = MoreTypes.asDeclared(type).getTypeArguments().get(0);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        throw new IllegalArgumentException(String.format(&quot;%s is not an optional type&quot;, type));</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return withType(newType);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isNullable() {
<b class="nc">&nbsp;      return nullable;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean useOptional() {
<b class="nc">&nbsp;      return isOptional() || isNullable();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isOptional() {
<b class="nc">&nbsp;      final List&lt;String&gt; names =</b>
<b class="nc">&nbsp;          Arrays.asList(</b>
&nbsp;              &quot;java.util.Optional&quot;,
&nbsp;              &quot;java.util.OptionalInt&quot;,
&nbsp;              &quot;java.util.OptionalDouble&quot;,
&nbsp;              &quot;java.util.OptionalLong&quot;,
<b class="nc">&nbsp;              Optional.class.getName(),</b>
&nbsp;              &quot;io.atlassian.fugue.Option&quot;);
&nbsp;
<b class="nc">&nbsp;      for (String name : names) {</b>
<b class="nc">&nbsp;        final Element element = elements.getTypeElement(name);</b>
<b class="nc">&nbsp;        if (element != null &amp;&amp; isSubtypeOf(element)) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private Type toType(TypeMirror mirror) {
<b class="nc">&nbsp;    if (mirror.getKind() == TypeKind.ARRAY) {</b>
<b class="nc">&nbsp;      return factory.array(toType(MoreTypes.asArray(mirror).getComponentType()));</b>
<b class="nc">&nbsp;    } else if (mirror.getKind().isPrimitive()) {</b>
<b class="nc">&nbsp;      final TypeElement boxed = types.boxedClass(MoreTypes.asPrimitiveType(mirror));</b>
<b class="nc">&nbsp;      return factory.reference(boxed.getQualifiedName().toString());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final Element element = types.asElement(mirror);</b>
<b class="nc">&nbsp;    if (element == null) {</b>
<b class="nc">&nbsp;      throw new IllegalArgumentException(String.format(&quot;Element for type %s not found (attribute %s %s)&quot;,</b>
<b class="nc">&nbsp;              mirror, attribute.name(), attribute.returnType));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final TypeExtractor extractor = new TypeExtractor(factory, MoreElements.asType(element));</b>
<b class="nc">&nbsp;    return extractor.get(mirror);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Criteria templates are always generated as top-level class (separate file).
&nbsp;   * Construct criteria name from {@linkplain TypeMirror}
&nbsp;   *
&nbsp;   * @return fully qualified criteria (template) class name
&nbsp;   */
&nbsp;  private static String topLevelCriteriaClassName(TypeMirror type) {
<b class="nc">&nbsp;    DeclaredType declaredType = MoreTypes.asDeclared(type);</b>
<b class="nc">&nbsp;    Element element = declaredType.asElement();</b>
&nbsp;    do {
<b class="nc">&nbsp;      element = element.getEnclosingElement();</b>
<b class="nc">&nbsp;    } while (element.getKind() != ElementKind.PACKAGE);</b>
&nbsp;
<b class="nc">&nbsp;    String packagePrefix = &quot;&quot;;</b>
<b class="nc">&nbsp;    if (!element.getSimpleName().contentEquals(&quot;&quot;)) {</b>
<b class="nc">&nbsp;      packagePrefix = MoreElements.asPackage(element).getQualifiedName() + &quot;.&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    // package name + type name + &quot;CriteriaTemplate&quot;
<b class="nc">&nbsp;    return packagePrefix + declaredType.asElement().getSimpleName().toString() + &quot;CriteriaTemplate&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Type.Parameterized matcherType(IntrospectedType introspected) {
<b class="nc">&nbsp;    final TypeMirror type = introspected.type;</b>
&nbsp;    String name;
&nbsp;
<b class="nc">&nbsp;    if (introspected.useOptional()) {</b>
<b class="nc">&nbsp;      IntrospectedType param = introspected.optionalParameter();</b>
&nbsp;      // use optional intersection-types ?
<b class="nc">&nbsp;      if (param.isString()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.OptionalStringMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (param.isBoolean()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.OptionalBooleanMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (param.isNumber()) {</b>
<b class="nc">&nbsp;        if (param.isInteger()) {</b>
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalIntegerMatcher.Template&quot;;</b>
<b class="nc">&nbsp;        } else if (param.isLong()) {</b>
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalLongMatcher.Template&quot;;</b>
<b class="nc">&nbsp;        } else if (param.isDouble()) {</b>
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalDoubleMatcher.Template&quot;;</b>
<b class="nc">&nbsp;        } else if (param.isBigInteger()) {</b>
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalBigIntegerMatcher.Template&quot;;</b>
<b class="nc">&nbsp;        } else if (param.isBigDecimal()) {</b>
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalBigDecimalMatcher.Template&quot;;</b>
&nbsp;        } else {
&nbsp;          // generic number
<b class="nc">&nbsp;          name = &quot;org.immutables.criteria.matcher.OptionalNumberMatcher.Template&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (param.isComparable()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.OptionalComparableMatcher.Template&quot;;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.OptionalObjectMatcher.Template&quot;;</b>
&nbsp;      }
<b class="nc">&nbsp;    } else if (introspected.hasCriteria()) {</b>
<b class="nc">&nbsp;      name = topLevelCriteriaClassName(type);</b>
<b class="nc">&nbsp;    } else if (introspected.isBoolean()) {</b>
<b class="nc">&nbsp;      name = &quot;org.immutables.criteria.matcher.BooleanMatcher.Template&quot;;</b>
<b class="nc">&nbsp;    } else if (introspected.isNumber()) {</b>
<b class="nc">&nbsp;      if (introspected.isInteger()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.IntegerMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (introspected.isLong()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.LongMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (introspected.isDouble()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.DoubleMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (introspected.isBigInteger()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.BigIntegerMatcher.Template&quot;;</b>
<b class="nc">&nbsp;      } else if (introspected.isBigDecimal()) {</b>
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.BigDecimalMatcher.Template&quot;;</b>
&nbsp;      } else {
&nbsp;        // generic number
<b class="nc">&nbsp;        name = &quot;org.immutables.criteria.matcher.NumberMatcher.Template&quot;;</b>
&nbsp;      }
<b class="nc">&nbsp;    } else if (introspected.isString()) {</b>
<b class="nc">&nbsp;      name = &quot;org.immutables.criteria.matcher.StringMatcher.Template&quot;;</b>
<b class="nc">&nbsp;    } else if (introspected.isIterable() || introspected.isArray()) {</b>
<b class="nc">&nbsp;      name = &quot;org.immutables.criteria.matcher.IterableMatcher.Template&quot;;</b>
<b class="nc">&nbsp;    } else if (introspected.isComparable()) {</b>
<b class="nc">&nbsp;      name = &quot;org.immutables.criteria.matcher.ComparableMatcher.Template&quot;;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      name = &quot;org.immutables.criteria.matcher.ObjectMatcher.Template&quot;;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final Element element = elements.getTypeElement(name);</b>
&nbsp;    final Type.Parameterized matcherType;
<b class="nc">&nbsp;    if (element == null) {</b>
&nbsp;      // means type not found in classpath. probably not yet generated criteria
&nbsp;      // create PersonCriteria&lt;R&gt; manually with Type.Parameterized
<b class="nc">&nbsp;      final Type.Variable variable = factory.parameters().introduce(&quot;R&quot;, NO_BOUNDS).variable(&quot;R&quot;);</b>
<b class="nc">&nbsp;      matcherType = factory.parameterized(factory.reference(name), Collections.singleton(variable));</b>
<b class="nc">&nbsp;    } else {</b>
<b class="nc">&nbsp;      matcherType = (Type.Parameterized) toType(element.asType());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return matcherType;</b>
&nbsp;  }
&nbsp;
&nbsp;
<b class="nc">&nbsp;  private static class CreatorVisitor implements Type.Visitor&lt;MatcherDef&gt; {</b>
&nbsp;    private final Types types;
&nbsp;    private final Elements elements;
&nbsp;    private final ValueAttribute attribute;
&nbsp;
<b class="nc">&nbsp;    private CreatorVisitor(Types types, Elements elements, ValueAttribute attribute) {</b>
<b class="nc">&nbsp;      this.types = types;</b>
<b class="nc">&nbsp;      this.elements = elements;</b>
<b class="nc">&nbsp;      this.attribute = attribute;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef primitive(Type.Primitive primitive) {
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef reference(Type.Reference reference) {
<b class="nc">&nbsp;      return new MatcherDef(reference, creator(reference));</b>
&nbsp;    }
&nbsp;
&nbsp;    private String creator(Type.Reference reference) {
<b class="nc">&nbsp;      if (isMatcher(reference)) {</b>
<b class="nc">&nbsp;        String name = reference.name;</b>
<b class="nc">&nbsp;        if (name.endsWith(&quot;.Template&quot;)) {</b>
<b class="nc">&nbsp;          name = name.substring(0, name.lastIndexOf(&quot;.Template&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (attribute.hasCriteria() &amp;&amp; name.endsWith(&quot;Template&quot;)) {</b>
<b class="nc">&nbsp;          name = name.substring(0, name.lastIndexOf(&quot;Template&quot;));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return name + &quot;.creator()&quot;;</b>
&nbsp;      }
&nbsp;
&nbsp;      // default (and generic) object matcher
<b class="nc">&nbsp;      return &quot;org.immutables.criteria.matcher.ObjectMatcher.creator()&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef parameterized(Type.Parameterized parameterized) {
<b class="nc">&nbsp;      for (Type.Nonprimitive arg: parameterized.arguments) {</b>
<b class="nc">&nbsp;        if (arg instanceof Type.Parameterized) {</b>
<b class="nc">&nbsp;          Type.Parameterized param = (Type.Parameterized) arg;</b>
<b class="nc">&nbsp;          if (isMatcher(param.reference)) {</b>
&nbsp;            // single match expected for now
<b class="nc">&nbsp;            return new ContainerDef(parameterized.reference, param.accept(this), creator(parameterized.reference));</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return reference(parameterized.reference);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isMatcher(Type.Reference reference) {
&nbsp;      // is matcher
<b class="nc">&nbsp;      Element element = elements.getTypeElement(reference.name);</b>
<b class="nc">&nbsp;      if (element != null &amp;&amp; types.isSubtype(element.asType(), elements.getTypeElement(MATCHER).asType())) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return attribute.hasCriteria();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef variable(Type.Variable variable) {
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef array(Type.Array array) {
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef superWildcard(Type.Wildcard.Super wildcard) {
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MatcherDef extendsWildcard(Type.Wildcard.Extends wildcard) {
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Composite matcher for containers like Iterable / Map / Optional / @Nullable
&nbsp;   */
<b class="nc">&nbsp;  private static class ContainerDef extends MatcherDef {</b>
&nbsp;
&nbsp;    public final MatcherDef element;
&nbsp;
&nbsp;    private ContainerDef(Type.Defined type, MatcherDef element, String creator) {
<b class="nc">&nbsp;      super(type, creator);</b>
<b class="nc">&nbsp;      this.element = Objects.requireNonNull(element, &quot;element&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static class MatcherDef {</b>
&nbsp;    public final Type.Defined type;
&nbsp;    public final String creator;
&nbsp;
<b class="nc">&nbsp;    private MatcherDef(Type.Defined type, String creator) {</b>
<b class="nc">&nbsp;      this.type = Objects.requireNonNull(type, &quot;type&quot;);</b>
<b class="nc">&nbsp;      this.creator = creator;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public Type.Parameterized buildMatcher() {
<b class="nc">&nbsp;    return buildMatcher(introspectedType);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Type.Parameterized buildMatcher(IntrospectedType introspected) {
<b class="nc">&nbsp;    Preconditions.checkNotNull(introspected, introspected);</b>
<b class="nc">&nbsp;    final TypeMirror type = introspected.type;</b>
<b class="nc">&nbsp;    final Type.Parameterized matcher = matcherType(introspected);</b>
<b class="nc">&nbsp;    if (matcher.arguments.size() &gt; 1) {</b>
&nbsp;      // replace second and maybe third argument
&nbsp;      // first type argument R unchanged
<b class="nc">&nbsp;      Type.VariableResolver resolver = Type.VariableResolver.empty();</b>
&nbsp;
&nbsp;      final Type valueType;
<b class="nc">&nbsp;      final Type.Variable arg1 = (Type.Variable) matcher.arguments.get(1);</b>
&nbsp;      // resolve P (which is projection type) for Optional
<b class="nc">&nbsp;      for (Type.Nonprimitive arg: matcher.arguments) {</b>
<b class="nc">&nbsp;        if (arg instanceof Type.Variable &amp;&amp; ((Type.Variable) arg).name.equals(&quot;P&quot;)) {</b>
&nbsp;          // resolve projection type (P) for .Template&lt;R, P&gt;.
&nbsp;          // projection type is identical to attribute type
&nbsp;          // Example .Template&lt;R, Optional&lt;Boolean&gt;&gt;
<b class="nc">&nbsp;          resolver = resolver.bind((Type.Variable) arg, factory.reference(type.toString()));</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      if (introspected.useOptional()) {</b>
<b class="nc">&nbsp;        final IntrospectedType newType = introspected.optionalParameter();</b>
<b class="nc">&nbsp;        valueType = toType(newType.type());</b>
<b class="nc">&nbsp;        if (newType.hasOptionalMatcher()) {</b>
&nbsp;          // don&#39;t recurse if optional matcher is present like OptionalComparableMatcher
<b class="nc">&nbsp;          resolver = resolver.bind(arg1, (Type.Nonprimitive) valueType);</b>
&nbsp;        } else {
<b class="nc">&nbsp;          resolver = resolver.bind(arg1, buildMatcher(newType));</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (introspected.isScalar()) {</b>
&nbsp;        // this is leaf no need to recurse
<b class="nc">&nbsp;        valueType = toType(introspected.box());</b>
<b class="nc">&nbsp;        resolver = resolver.bind(arg1, (Type.Nonprimitive) valueType);</b>
<b class="nc">&nbsp;      } else if (introspected.isArray()) {</b>
<b class="nc">&nbsp;        final TypeMirror mirror = MoreTypes.asArray(type).getComponentType();</b>
<b class="nc">&nbsp;        valueType = toType(mirror);</b>
<b class="nc">&nbsp;        resolver = resolver.bind(arg1, buildMatcher(introspected.withType(mirror)));</b>
<b class="nc">&nbsp;      } else {</b>
<b class="nc">&nbsp;        final TypeMirror mirror = MoreTypes.asDeclared(type).getTypeArguments().get(0);</b>
<b class="nc">&nbsp;        valueType = toType(mirror);</b>
<b class="nc">&nbsp;        resolver = resolver.bind(arg1, buildMatcher(introspected.withType(mirror)));</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (matcher.arguments.size() &gt; 2 &amp;&amp; ((Type.Variable) matcher.arguments.get(2)).name.equals(&quot;V&quot;)) {</b>
&nbsp;        // parameter called V is usually value type
<b class="nc">&nbsp;        resolver = resolver.bind((Type.Variable) matcher.arguments.get(2), (Type.Nonprimitive) valueType);</b>
&nbsp;      }
&nbsp;
&nbsp;      // resolve P (which is projection type) for Array / Iterable
<b class="nc">&nbsp;      if (introspected.isArray() || introspected.isIterable()) {</b>
<b class="nc">&nbsp;        for (Type.Nonprimitive arg: matcher.arguments) {</b>
<b class="nc">&nbsp;          if (arg instanceof Type.Variable &amp;&amp; ((Type.Variable) arg).name.equals(&quot;P&quot;)) {</b>
&nbsp;            // resolve projection type (P) for .Template&lt;R, P&gt;.
&nbsp;            // projection type is identical to attribute type
&nbsp;            // Example .Template&lt;R, Optional&lt;Boolean&gt;&gt;
<b class="nc">&nbsp;            resolver = resolver.bind((Type.Variable) arg, factory.reference(type.toString()));</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return (Type.Parameterized) matcher.accept(resolver);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return matcher;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public MatcherDefinition matcher() {
<b class="nc">&nbsp;    return matcherDefinition;</b>
&nbsp;  }
&nbsp;  
<b class="nc">&nbsp;  public static class MatcherDefinition {</b>
&nbsp;    private final ValueAttribute attribute;
&nbsp;    private final Type.Parameterized matcherType;
&nbsp;    private final MatcherDef def;
&nbsp;
<b class="nc">&nbsp;    private MatcherDefinition(ValueAttribute attribute, Type.Parameterized matcherType) {</b>
<b class="nc">&nbsp;      this.attribute = attribute;</b>
<b class="nc">&nbsp;      this.matcherType = Preconditions.checkNotNull(matcherType, &quot;type&quot;);</b>
<b class="nc">&nbsp;      ProcessingEnvironment env = attribute.containingType.constitution.protoclass().environment().processing();</b>
<b class="nc">&nbsp;      this.def = matcherType.accept(new CreatorVisitor(env.getTypeUtils(), env.getElementUtils(), attribute));</b>
&nbsp;    }
&nbsp;
&nbsp;    public Type.Parameterized matcherType() {
<b class="nc">&nbsp;      return this.matcherType;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String creator() {
&nbsp;
<b class="nc">&nbsp;      final String first = def.creator;</b>
<b class="nc">&nbsp;      final String second = def instanceof ContainerDef ? ((ContainerDef) def).element.creator : first;</b>
&nbsp;
<b class="nc">&nbsp;      final String withPath = String.format(&quot;context.appendPath(%s.class, \&quot;%s\&quot;, %s)&quot;, attribute.containingType.typeDocument().toString(),</b>
<b class="nc">&nbsp;              attribute.originalElement().getSimpleName().toString(), second);</b>
&nbsp;
<b class="nc">&nbsp;      return String.format(&quot;%s.create(%s)&quot;, first, withPath);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
