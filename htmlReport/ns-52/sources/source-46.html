


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Proto</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: Proto (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Proto</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Proto$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$AbstractDeclaring</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/125)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$DeclaringPackage</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/81)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$DeclaringType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/112)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/143)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$DeclatedTypeToElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$Diagnosable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$ElementToName</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$Environment</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$Interning</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$IsPublic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$JacksonMode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$MetaAnnotated</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$MetaAnnotatedCache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$Protoclass</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/188)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/233)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$Protoclass$Kind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$ToImmutableInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$ToInjectionInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$ToStyleInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Proto$TypeFactoryAndInflater</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/206)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/571)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/826)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2014-2018 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import com.google.common.base.Predicate;
&nbsp;import com.google.common.collect.FluentIterable;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Interner;
&nbsp;import com.google.common.collect.Interners;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.ObjectArrays;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.SourceVersion;
&nbsp;import javax.lang.model.element.AnnotationMirror;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.NestingKind;
&nbsp;import javax.lang.model.element.PackageElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import javax.tools.Diagnostic;
&nbsp;import org.immutables.generator.ClasspathFence;
&nbsp;import org.immutables.generator.EnvironmentState;
&nbsp;import org.immutables.generator.SourceExtraction;
&nbsp;import org.immutables.value.Value;
&nbsp;import org.immutables.value.processor.encode.EncMetadataMirror;
&nbsp;import org.immutables.value.processor.encode.EncodingInfo;
&nbsp;import org.immutables.value.processor.encode.EncodingMirror;
&nbsp;import org.immutables.value.processor.encode.Inflater;
&nbsp;import org.immutables.value.processor.encode.Instantiator;
&nbsp;import org.immutables.value.processor.encode.Type;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.AnnotationInjection;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.InjectionInfo;
&nbsp;import org.immutables.value.processor.meta.Reporter.About;
&nbsp;import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;
&nbsp;import static com.google.common.base.Verify.verify;
&nbsp;
&nbsp;@Value.Enclosing
<b class="nc">&nbsp;public class Proto {</b>
&nbsp;  private Proto() {}
&nbsp;
&nbsp;  public static Type.Factory typeFactory() {
<b class="nc">&nbsp;    return typeFactoryAndInflater().factory;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static TypeFactoryAndInflater typeFactoryAndInflater() {
<b class="nc">&nbsp;    return EnvironmentState.getPerProcessing(TypeFactoryAndInflater.class, TypeFactoryAndInflater::new);</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static class TypeFactoryAndInflater implements Runnable {</b>
<b class="nc">&nbsp;    final Type.Factory factory = new Type.Producer();</b>
<b class="nc">&nbsp;    final Inflater inflater = new Inflater(factory);</b>
<b class="nc">&nbsp;    @Override public void run() {}</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  final static class Interning {</b>
<b class="nc">&nbsp;    private final Interner&lt;DeclaringPackage&gt; packageInterner = Interners.newStrongInterner();</b>
<b class="nc">&nbsp;    private final Interner&lt;DeclaringType&gt; typeInterner = Interners.newStrongInterner();</b>
<b class="nc">&nbsp;    private final Interner&lt;Protoclass&gt; protoclassInterner = Interners.newStrongInterner();</b>
&nbsp;
&nbsp;    DeclaringPackage forPackage(DeclaringPackage declaringPackage) {
<b class="nc">&nbsp;      return packageInterner.intern(declaringPackage);</b>
&nbsp;    }
&nbsp;
&nbsp;    DeclaringType forType(DeclaringType declaringType) {
<b class="nc">&nbsp;      return typeInterner.intern(declaringType);</b>
&nbsp;    }
&nbsp;
&nbsp;    Protoclass forProto(Protoclass protoclass) {
<b class="nc">&nbsp;      return protoclassInterner.intern(protoclass);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Value.Immutable(builder = false)
<b class="nc">&nbsp;  public static abstract class MetaAnnotated {</b>
&nbsp;    @Value.Parameter
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract Element element();
&nbsp;
&nbsp;    @Value.Parameter
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract String qualifiedName();
&nbsp;
&nbsp;    @Value.Parameter
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract Environment environment();
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Set&lt;EncodingInfo&gt; encodings() {
<b class="nc">&nbsp;      if (qualifiedName().endsWith(&quot;Enabled&quot;)</b>
<b class="nc">&nbsp;          || CustomImmutableAnnotations.annotations().contains(qualifiedName())</b>
<b class="nc">&nbsp;          || style().isPresent()) {</b>
&nbsp;
&nbsp;        // See if it is encoding enabled itself
<b class="nc">&nbsp;        Optional&lt;EncodingInfo&gt; encoding = EncMetadataMirror.find(element())</b>
<b class="nc">&nbsp;            .transform(typeFactoryAndInflater().inflater);</b>
&nbsp;
<b class="nc">&nbsp;        if (encoding.isPresent()) {</b>
<b class="nc">&nbsp;          return encoding.asSet();</b>
&nbsp;        }
&nbsp;
&nbsp;        // trying to find it as meta-meta annotation
<b class="nc">&nbsp;        List&lt;EncodingInfo&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (AnnotationMirror m : element().getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;          MetaAnnotated metaAnnotated = MetaAnnotated.from(m, environment());</b>
<b class="nc">&nbsp;          result.addAll(metaAnnotated.encodings());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (!result.isEmpty()) {</b>
<b class="nc">&nbsp;          return ImmutableSet.copyOf(result);</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return ImmutableSet.of();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
<b class="nc">&nbsp;      return DataMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
<b class="nc">&nbsp;      return StyleMirror.find(element()).transform(ToStyleInfo.FUNCTION);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
<b class="nc">&nbsp;      Optional&lt;DepluralizeMirror&gt; d = DepluralizeMirror.find(element());</b>
<b class="nc">&nbsp;      if (d.isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.of(d.get().dictionary());</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
<b class="nc">&nbsp;      if (!environment().hasSerialModule()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;VersionMirror&gt; version = VersionMirror.find(element());</b>
<b class="nc">&nbsp;      return version.isPresent()</b>
<b class="nc">&nbsp;          ? Optional.of(version.get().value())</b>
<b class="nc">&nbsp;          : Optional.&lt;Long&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isSerialStructural() {
<b class="nc">&nbsp;      return environment().hasSerialModule()</b>
<b class="nc">&nbsp;          &amp;&amp; StructuralMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isJacksonSerialized() {
<b class="nc">&nbsp;      return environment().hasJacksonLib()</b>
<b class="nc">&nbsp;          &amp;&amp; isJacksonSerializedAnnotated(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isJacksonDeserialized() {
<b class="nc">&nbsp;      return environment().hasJacksonLib()</b>
<b class="nc">&nbsp;          &amp;&amp; isJacksonDeserializedAnnotated(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isJacksonJsonTypeInfo() {
<b class="nc">&nbsp;      return environment().hasJacksonLib()</b>
<b class="nc">&nbsp;          &amp;&amp; isJacksonJsonTypeInfoAnnotated(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isJsonQualifier() {
<b class="nc">&nbsp;      return environment().hasOkJsonLib()</b>
<b class="nc">&nbsp;          &amp;&amp; OkQualifierMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isEnclosing() {
<b class="nc">&nbsp;      return EnclosingMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public ImmutableList&lt;InjectionInfo&gt; injectAnnotation() {
<b class="nc">&nbsp;      if (environment().hasAnnotateModule()) {</b>
<b class="nc">&nbsp;        ImmutableList.Builder&lt;InjectionInfo&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;        Optional&lt;InjectAnnotationMirror&gt; injectAnnotation = InjectAnnotationMirror.find(element());</b>
<b class="nc">&nbsp;        if (injectAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;          builder.add(ToInjectionInfo.FUNCTION.apply(injectAnnotation.get()));</b>
&nbsp;        }
<b class="nc">&nbsp;        Optional&lt;InjectManyAnnotationsMirror&gt; injectMany = InjectManyAnnotationsMirror.find(element());</b>
<b class="nc">&nbsp;        if (injectMany.isPresent()) {</b>
<b class="nc">&nbsp;          for (InjectAnnotationMirror m : injectMany.get().value()) {</b>
<b class="nc">&nbsp;            builder.add(ToInjectionInfo.FUNCTION.apply(m));</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        return builder.build();</b>
&nbsp;      }
<b class="nc">&nbsp;      return ImmutableList.of();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static MetaAnnotated from(AnnotationMirror mirror, Environment environment) {
<b class="nc">&nbsp;      TypeElement element = (TypeElement) mirror.getAnnotationType().asElement();</b>
<b class="nc">&nbsp;      String name = element.getQualifiedName().toString();</b>
&nbsp;
<b class="nc">&nbsp;      ConcurrentMap&lt;String, MetaAnnotated&gt; cache = metaAnnotatedCache();</b>
<b class="nc">&nbsp;      @Nullable MetaAnnotated metaAnnotated = cache.get(name);</b>
<b class="nc">&nbsp;      if (metaAnnotated == null) {</b>
<b class="nc">&nbsp;        metaAnnotated = ImmutableProto.MetaAnnotated.of(element, name, environment);</b>
<b class="nc">&nbsp;        @Nullable MetaAnnotated existing = cache.putIfAbsent(name, metaAnnotated);</b>
<b class="nc">&nbsp;        if (existing != null) {</b>
<b class="nc">&nbsp;          metaAnnotated = existing;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return metaAnnotated;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static ConcurrentMap&lt;String, MetaAnnotated&gt; metaAnnotatedCache() {
<b class="nc">&nbsp;      return EnvironmentState.getPerProcessing(MetaAnnotatedCache.class, MetaAnnotatedCache::new).cache;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static class MetaAnnotatedCache implements Runnable {</b>
<b class="nc">&nbsp;    final ConcurrentMap&lt;String, MetaAnnotated&gt; cache = new ConcurrentHashMap&lt;&gt;(16, 0.7f, 1);</b>
&nbsp;    @Override public void run() {
&nbsp;      // these clear() calls are not strictly necessary, just subject to GC after processing or round
&nbsp;      // but we try to be &quot;paranoidaly consistent&quot;
<b class="nc">&nbsp;      cache.clear();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  abstract static class Diagnosable {</b>
&nbsp;    /**
&nbsp;     * Element suitable for reporting as a source of declaration which might causing problems.
&nbsp;     */
&nbsp;    @Value.Auxiliary
&nbsp;    abstract Element element();
&nbsp;
&nbsp;    @Value.Auxiliary
&nbsp;    abstract Environment environment();
&nbsp;
&nbsp;    ProcessingEnvironment processing() {
<b class="nc">&nbsp;      return environment().processing();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Auxiliary
&nbsp;    @Value.Derived
&nbsp;    public String simpleName() {
<b class="nc">&nbsp;      return element().getSimpleName().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Reporter report() {
<b class="nc">&nbsp;      return Reporter.from(processing()).withElement(element());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  @Value.Immutable</b>
<b class="nc">&nbsp;  public abstract static class Environment {</b>
&nbsp;    @Value.Parameter
&nbsp;    abstract ProcessingEnvironment processing();
&nbsp;
&nbsp;    @Value.Parameter
&nbsp;    abstract Round round();
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    StyleInfo defaultStyles() {
<b class="nc">&nbsp;      @Nullable TypeElement element = findElement(StyleMirror.qualifiedName());</b>
<b class="nc">&nbsp;      if (element == null) {</b>
<b class="nc">&nbsp;        processing().getMessager()</b>
<b class="nc">&nbsp;            .printMessage(Diagnostic.Kind.MANDATORY_WARNING,</b>
&nbsp;                &quot;Could not found annotations on the compile classpath. It looks like annotation processor is running&quot;
&nbsp;                    + &quot; in a separate annotation-processing classpath and unable to get to annotation definitions.&quot;
&nbsp;                    + &quot; To fix this, please add annotation-only artifact &#39;org.immutables:value:(version):annotations&#39;&quot;
&nbsp;                    + &quot; to &#39;compile&#39; &#39;compileOnly&#39; or &#39;provided&#39; dependency scope.&quot;);
&nbsp;
<b class="nc">&nbsp;        element = findElement(StyleMirror.mirrorQualifiedName());</b>
<b class="nc">&nbsp;        verify(element != null, &quot;Classpath should contain at least mirror annotation, otherwise library is corrupted&quot;);</b>
&nbsp;      }
&nbsp;      try {
<b class="nc">&nbsp;        return ToStyleInfo.FUNCTION.apply(StyleMirror.from(element));</b>
<b class="nc">&nbsp;      } catch (Exception ex) {</b>
<b class="nc">&nbsp;        processing().getMessager()</b>
<b class="nc">&nbsp;            .printMessage(Diagnostic.Kind.MANDATORY_WARNING,</b>
&nbsp;                &quot;The version of the Immutables annotation on the classpath has incompatible differences&quot;
&nbsp;                    + &quot; from the Immutables annotation processor used. Various problems might occur,&quot;
&nbsp;                    + &quot; like this one: &quot;
&nbsp;                    + ex);
&nbsp;
<b class="nc">&nbsp;        element = findElement(StyleMirror.mirrorQualifiedName());</b>
<b class="nc">&nbsp;        verify(element != null,</b>
&nbsp;            &quot;classpath should contain at least the mirror annotation, otherwise library is corrupted&quot;);
<b class="nc">&nbsp;        return ToStyleInfo.FUNCTION.apply(StyleMirror.from(element));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try to find Guava&#39;s object util classes if they&#39;re available. First lookup for
&nbsp;     * {@code base.MoreObjects} then {@code base.Objects}.
&nbsp;     * Return {@code null} if not found.
&nbsp;     * @return full class name for Guava&#39;s {@code MoreObjects} / {@code Objects} or {@code null} if
&nbsp;     *         such class doesn&#39;t exists in classpath
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    @Value.Lazy
&nbsp;    String typeMoreObjects() {
<b class="nc">&nbsp;      for (String shortName : Arrays.asList(&quot;base.MoreObjects&quot;, &quot;base.Objects&quot;)) {</b>
<b class="nc">&nbsp;        final String name = UnshadeGuava.typeString(shortName);</b>
<b class="nc">&nbsp;        if (hasElement(name)) {</b>
<b class="nc">&nbsp;          return name;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;      // not found
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasGuavaLib() {
<b class="nc">&nbsp;      return typeMoreObjects() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasOkJsonLib() {
<b class="nc">&nbsp;      return hasElement(&quot;com.squareup.moshi.Moshi&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasGsonLib() {
<b class="nc">&nbsp;      return hasElement(&quot;com.google.gson.Gson&quot;);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasDatatypesModule() {
<b class="nc">&nbsp;      return hasElement(DataMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasJacksonLib() {
<b class="nc">&nbsp;      return hasElement(Proto.JACKSON_DESERIALIZE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasCriteriaModule() {
<b class="nc">&nbsp;      return hasElement(CriteriaMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasMongoModule() {
<b class="nc">&nbsp;      return hasElement(RepositoryMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasSerialModule() {
<b class="nc">&nbsp;      return hasElement(VersionMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasTreesModule() {
<b class="nc">&nbsp;      return hasElement(TransformMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasAstModule() {
<b class="nc">&nbsp;      return hasElement(AstMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasOrdinalModule() {
<b class="nc">&nbsp;      return hasElement(ORDINAL_VALUE_INTERFACE_TYPE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasBuilderModule() {
<b class="nc">&nbsp;      return hasElement((FactoryMirror.qualifiedName()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasFuncModule() {
<b class="nc">&nbsp;      return hasElement(FunctionalMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasEncodeModule() {
<b class="nc">&nbsp;      return hasElement(EncodingMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasAnnotateModule() {
<b class="nc">&nbsp;      return hasElement(InjectAnnotationMirror.qualifiedName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean hasJava9Collections() {
<b class="nc">&nbsp;      for (SourceVersion version : SourceVersion.values()) {</b>
<b class="nc">&nbsp;        if (version.name().equals(&quot;RELEASE_9&quot;)) {</b>
<b class="nc">&nbsp;          if (processing().getSourceVersion().compareTo(version) &gt;= 0) {</b>
<b class="nc">&nbsp;            TypeElement element = findElement(List.class.getCanonicalName());</b>
<b class="nc">&nbsp;            assert element != null : &quot;always present in modern JREs&quot;;</b>
<b class="nc">&nbsp;            for (ExecutableElement e : ElementFilter.methodsIn(element.getEnclosedElements())) {</b>
<b class="nc">&nbsp;              if (e.getModifiers().contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;                  &amp;&amp; e.getSimpleName().contentEquals(&quot;of&quot;)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;              }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;          }</b>
&nbsp;          break;
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Default type adapters should only be called if {@code Gson.TypeAdapters} annotation is
&nbsp;     * definitely in classpath. Currently, it is called by for mongo repository module,
&nbsp;     * which have {@code gson} module as a transitive dependency.
&nbsp;     * @return default type adapters
&nbsp;     */
&nbsp;    @Value.Lazy
&nbsp;    TypeAdaptersMirror defaultTypeAdapters() {
<b class="nc">&nbsp;      @Nullable TypeElement typeElement =</b>
<b class="nc">&nbsp;          findElement(TypeAdaptersMirror.qualifiedName());</b>
&nbsp;
<b class="nc">&nbsp;      Preconditions.checkState(typeElement != null,</b>
&nbsp;          &quot;Processor internal error, @%s is not know to be on the classpath&quot;,
<b class="nc">&nbsp;          TypeAdaptersMirror.qualifiedName());</b>
&nbsp;
<b class="nc">&nbsp;      return TypeAdaptersMirror.from(typeElement);</b>
&nbsp;    }
&nbsp;
&nbsp;    ValueType composeValue(Protoclass protoclass) {
<b class="nc">&nbsp;      return round().composeValue(protoclass);</b>
&nbsp;    }
&nbsp;
&nbsp;    ImmutableList&lt;Protoclass&gt; protoclassesFrom(Iterable&lt;? extends Element&gt; elements) {
<b class="nc">&nbsp;      return round().protoclassesFrom(elements);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if {@code qualifiedName} is known to current environment (annotation processor).
&nbsp;     * Retrieve (by canonical name) {@link TypeElement} from APT environment.
&nbsp;     */
&nbsp;    private boolean hasElement(String qualifiedName) {
<b class="nc">&nbsp;      return findElement(qualifiedName) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private @Nullable TypeElement findElement(String qualifiedName) {
<b class="nc">&nbsp;      if (ClasspathFence.isInhibited(qualifiedName)) {</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;      }
&nbsp;      try {
<b class="nc">&nbsp;        TypeElement typeElement = processing()</b>
<b class="nc">&nbsp;            .getElementUtils()</b>
<b class="nc">&nbsp;            .getTypeElement(qualifiedName);</b>
<b class="nc">&nbsp;        return typeElement;</b>
<b class="nc">&nbsp;      } catch (Exception ex) {</b>
&nbsp;        // to be visible during build
<b class="nc">&nbsp;        ex.printStackTrace();</b>
&nbsp;        // any type loading problems, which are unlikely (leftover?)
<b class="nc">&nbsp;        return null;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;Set&lt;EncodingInfo&gt;, Instantiator&gt; instantiators = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    Instantiator instantiatorFor(Set&lt;EncodingInfo&gt; encodings) {
<b class="nc">&nbsp;      return instantiators.computeIfAbsent(encodings,</b>
<b class="nc">&nbsp;          key -&gt; typeFactoryAndInflater().inflater.instantiatorFor(key));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCheckedException(TypeMirror throwable) {
<b class="nc">&nbsp;      return checkedExceptionProbe().isCheckedException(throwable);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    CheckedExceptionProbe checkedExceptionProbe() {
<b class="nc">&nbsp;      return new CheckedExceptionProbe(</b>
<b class="nc">&nbsp;          processing().getTypeUtils(),</b>
<b class="nc">&nbsp;          processing().getElementUtils());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Introspection supertype for the {@link DeclaringType} and {@link DeclaringPackage}
&nbsp;   */
<b class="nc">&nbsp;  public static abstract class AbstractDeclaring extends Diagnosable {</b>
&nbsp;    public abstract String name();
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract Element element();
&nbsp;
&nbsp;    public abstract DeclaringPackage packageOf();
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    protected Optional&lt;IncludeMirror&gt; include() {
<b class="nc">&nbsp;      return IncludeMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    protected Optional&lt;FIncludeMirror&gt; builderInclude() {
<b class="nc">&nbsp;      return FIncludeMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    public String asPrefix() {
<b class="nc">&nbsp;      return name().isEmpty() ? &quot;&quot; : (name() + &quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Optional&lt;DeclaringType&gt; asType() {
<b class="nc">&nbsp;      return this instanceof DeclaringType</b>
<b class="nc">&nbsp;          ? Optional.of((DeclaringType) this)</b>
<b class="nc">&nbsp;          : Optional.&lt;DeclaringType&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * used to intern packaged created internally
&nbsp;     */
&nbsp;    @Value.Auxiliary
&nbsp;    abstract Proto.Interning interner();
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;TypeAdaptersMirror&gt; typeAdapters() {
<b class="nc">&nbsp;      return TypeAdaptersMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;OkTypeAdaptersMirror&gt; okTypeAdapters() {
<b class="nc">&nbsp;      return OkTypeAdaptersMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    List&lt;TypeElement&gt; includedTypes() {
<b class="nc">&nbsp;      Optional&lt;IncludeMirror&gt; includes = include();</b>
&nbsp;
<b class="nc">&nbsp;      ImmutableList&lt;TypeMirror&gt; typeMirrors = includes.isPresent()</b>
<b class="nc">&nbsp;          ? ImmutableList.copyOf(includes.get().valueMirror())</b>
<b class="nc">&nbsp;          : ImmutableList.&lt;TypeMirror&gt;of();</b>
&nbsp;
<b class="nc">&nbsp;      FluentIterable&lt;TypeElement&gt; typeElements = FluentIterable.from(typeMirrors)</b>
<b class="nc">&nbsp;          .filter(DeclaredType.class)</b>
<b class="nc">&nbsp;          .transform(DeclatedTypeToElement.FUNCTION);</b>
&nbsp;
<b class="nc">&nbsp;      ImmutableSet&lt;String&gt; uniqueTypeNames = typeElements</b>
<b class="nc">&nbsp;          .filter(IsPublic.PREDICATE)</b>
<b class="nc">&nbsp;          .transform(ElementToName.FUNCTION)</b>
<b class="nc">&nbsp;          .toSet();</b>
&nbsp;
<b class="nc">&nbsp;      if (uniqueTypeNames.size() != typeMirrors.size()) {</b>
<b class="nc">&nbsp;        report().annotationNamed(IncludeMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.INCOMPAT,</b>
&nbsp;                &quot;Some types were ignored, non-supported for inclusion: duplicates,&quot;
&nbsp;                    + &quot; non declared reference types, non-public&quot;);
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return typeElements.toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    List&lt;TypeElement&gt; builderIncludedTypes() {
<b class="nc">&nbsp;      Optional&lt;FIncludeMirror&gt; includes = builderInclude();</b>
&nbsp;
<b class="nc">&nbsp;      ImmutableList&lt;TypeMirror&gt; typeMirrors = includes.isPresent()</b>
<b class="nc">&nbsp;          ? ImmutableList.copyOf(includes.get().valueMirror())</b>
<b class="nc">&nbsp;          : ImmutableList.&lt;TypeMirror&gt;of();</b>
&nbsp;
<b class="nc">&nbsp;      FluentIterable&lt;TypeElement&gt; typeElements = FluentIterable.from(typeMirrors)</b>
<b class="nc">&nbsp;          .filter(DeclaredType.class)</b>
<b class="nc">&nbsp;          .transform(DeclatedTypeToElement.FUNCTION);</b>
&nbsp;
<b class="nc">&nbsp;      ImmutableSet&lt;String&gt; uniqueTypeNames = typeElements</b>
<b class="nc">&nbsp;          .filter(IsPublic.PREDICATE)</b>
<b class="nc">&nbsp;          .transform(ElementToName.FUNCTION)</b>
<b class="nc">&nbsp;          .toSet();</b>
&nbsp;
<b class="nc">&nbsp;      if (uniqueTypeNames.size() != typeMirrors.size()) {</b>
<b class="nc">&nbsp;        report().annotationNamed(IncludeMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.INCOMPAT,</b>
&nbsp;                &quot;Some types were ignored, non-supported for inclusion: duplicates,&quot;
&nbsp;                    + &quot; non declared reference types, non-public&quot;);
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return typeElements.toList();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private final List&lt;AnnotationInjection&gt; annotationInjections = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    public List&lt;AnnotationInjection&gt; getAnnotationInjections() {
<b class="nc">&nbsp;      if (!environment().hasAnnotateModule()) {</b>
<b class="nc">&nbsp;        return ImmutableList.of();</b>
&nbsp;      }
&nbsp;      // force initialization of annotationInjections list
<b class="nc">&nbsp;      metaAnnotated();</b>
&nbsp;
<b class="nc">&nbsp;      synchronized (annotationInjections) {</b>
<b class="nc">&nbsp;        return ImmutableList.copyOf(annotationInjections);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    List&lt;MetaAnnotated&gt; metaAnnotated() {
<b class="nc">&nbsp;      ImmutableList.Builder&lt;MetaAnnotated&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;      for (AnnotationMirror mirror : element().getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;        MetaAnnotated meta = MetaAnnotated.from(mirror, environment());</b>
<b class="nc">&nbsp;        registerAnnotationInjection(mirror, meta);</b>
<b class="nc">&nbsp;        builder.add(meta);</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return builder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void registerAnnotationInjection(AnnotationMirror mirror, MetaAnnotated meta) {
<b class="nc">&nbsp;      for (InjectionInfo info : meta.injectAnnotation()) {</b>
<b class="nc">&nbsp;        AnnotationInjection injection = info.injectionFor(mirror, environment());</b>
<b class="nc">&nbsp;        synchronized (annotationInjections) {</b>
<b class="nc">&nbsp;          annotationInjections.add(injection);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
<b class="nc">&nbsp;      Optional&lt;StyleInfo&gt; style = StyleMirror.find(element()).transform(ToStyleInfo.FUNCTION);</b>
&nbsp;
<b class="nc">&nbsp;      if (style.isPresent()) {</b>
<b class="nc">&nbsp;        return style;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (MetaAnnotated m : metaAnnotated()) {</b>
<b class="nc">&nbsp;        Optional&lt;StyleInfo&gt; metaStyle = m.style();</b>
<b class="nc">&nbsp;        if (metaStyle.isPresent()) {</b>
<b class="nc">&nbsp;          return metaStyle;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
<b class="nc">&nbsp;      Optional&lt;DataMirror&gt; datatypeOwn = DataMirror.find(element());</b>
<b class="nc">&nbsp;      if (datatypeOwn.isPresent()) {</b>
<b class="nc">&nbsp;        return datatypeOwn;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (MetaAnnotated m : metaAnnotated()) {</b>
<b class="nc">&nbsp;        Optional&lt;DataMirror&gt; d = m.datatypeEnabled();</b>
<b class="nc">&nbsp;        if (d.isPresent()) {</b>
<b class="nc">&nbsp;          return d;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
<b class="nc">&nbsp;      Optional&lt;VersionMirror&gt; version = VersionMirror.find(element());</b>
<b class="nc">&nbsp;      if (version.isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.of(version.get().value());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;        Optional&lt;Long&gt; serialVersion = metaAnnotated.serialVersion();</b>
<b class="nc">&nbsp;        if (serialVersion.isPresent()) {</b>
<b class="nc">&nbsp;          return serialVersion;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Optional.&lt;Long&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isSerialStructural() {
<b class="nc">&nbsp;      return StructuralMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonSerialized() {
<b class="nc">&nbsp;      if (jacksonSerializeMode() == JacksonMode.DELEGATED) {</b>
&nbsp;        // while DeclaringPackage cannot have those annotations
&nbsp;        // directly, just checking them as a general computation path
&nbsp;        // will not hurt much.
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;        if (metaAnnotated.isJacksonSerialized()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public JacksonMode jacksonSerializeMode() {
<b class="nc">&nbsp;      return Proto.isJacksonSerializedAnnotated(element())</b>
<b class="nc">&nbsp;          ? JacksonMode.DELEGATED</b>
<b class="nc">&nbsp;          : JacksonMode.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonDeserialized() {
<b class="nc">&nbsp;      if (isJacksonDeserializedAnnotated()) {</b>
&nbsp;        // while DeclaringPackage cannot have those annotations
&nbsp;        // directly, just checking them as a general computation path
&nbsp;        // will not hurt much.
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;        if (metaAnnotated.isJacksonDeserialized()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void collectEncodings(Collection&lt;EncodingInfo&gt; encodings) {
<b class="nc">&nbsp;      for (MetaAnnotated m : metaAnnotated()) {</b>
<b class="nc">&nbsp;        encodings.addAll(m.encodings());</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
<b class="nc">&nbsp;      @Nullable String[] dictionary = null;</b>
<b class="nc">&nbsp;      for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;        Optional&lt;String[]&gt; depluralize = metaAnnotated.depluralize();</b>
<b class="nc">&nbsp;        if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;          dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;DepluralizeMirror&gt; depluralize = DepluralizeMirror.find(element());</b>
<b class="nc">&nbsp;      if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;        dictionary = concat(dictionary, depluralize.get().dictionary());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Optional.fromNullable(dictionary);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonDeserializedAnnotated() {
<b class="nc">&nbsp;      return Proto.isJacksonDeserializedAnnotated(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonJsonTypeInfo() {
<b class="nc">&nbsp;      if (isJacksonJsonTypeInfoAnnotated(element())) {</b>
&nbsp;        // while DeclaringPackage cannot have those annotations
&nbsp;        // directly, just checking them as a general computation path
&nbsp;        // will not hurt much.
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;        if (metaAnnotated.isJacksonJsonTypeInfo()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public enum JacksonMode {</b>
<b class="nc">&nbsp;    NONE, DELEGATED, BUILDER;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Value.Immutable
<b class="nc">&nbsp;  public static abstract class DeclaringPackage extends AbstractDeclaring {</b>
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract PackageElement element();
&nbsp;
&nbsp;    @Override
&nbsp;    public DeclaringPackage packageOf() {
<b class="nc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Auxiliary
&nbsp;    @Value.Derived
&nbsp;    public String simpleName() {
<b class="nc">&nbsp;      return element().isUnnamed() ? &quot;&quot; : element().getSimpleName().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Name is the only equivalence attribute. Basically packages are interned by name.
&nbsp;     * @return package name
&nbsp;     */
&nbsp;    @Override
&nbsp;    @Value.Derived
&nbsp;    public String name() {
<b class="nc">&nbsp;      return element().isUnnamed() ? &quot;&quot; : element().getQualifiedName().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    Optional&lt;DeclaringPackage&gt; namedParentPackage() {
<b class="nc">&nbsp;      String parentPackageName = SourceNames.parentPackageName(element());</b>
<b class="nc">&nbsp;      while (!parentPackageName.isEmpty()) {</b>
<b class="nc">&nbsp;        @Nullable PackageElement parentPackage =</b>
<b class="nc">&nbsp;            environment().processing()</b>
<b class="nc">&nbsp;                .getElementUtils()</b>
<b class="nc">&nbsp;                .getPackageElement(parentPackageName);</b>
&nbsp;
<b class="nc">&nbsp;        if (parentPackage != null) {</b>
<b class="nc">&nbsp;          return Optional.of(interner().forPackage(</b>
<b class="nc">&nbsp;              ImmutableProto.DeclaringPackage.builder()</b>
<b class="nc">&nbsp;                  .environment(environment())</b>
<b class="nc">&nbsp;                  .interner(interner())</b>
<b class="nc">&nbsp;                  .element(parentPackage)</b>
<b class="nc">&nbsp;                  .build()));</b>
&nbsp;        }
&nbsp;
&nbsp;        // With JDK 9+ package elements are only returned for packages with a
&nbsp;        // `package-info.class` file. So although the parent may not be found,
&nbsp;        // there may be &quot;ancestor packages&quot; further up the hierarchy.
<b class="nc">&nbsp;        parentPackageName = SourceNames.parentPackageName(parentPackageName);</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonSerialized() {
<b class="nc">&nbsp;      boolean isJacksonSerialized = super.isJacksonSerialized();</b>
<b class="nc">&nbsp;      if (isJacksonSerialized) {</b>
<b class="nc">&nbsp;        return isJacksonSerialized;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().isJacksonSerialized();</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonDeserialized() {
<b class="nc">&nbsp;      if (super.isJacksonDeserialized()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().isJacksonDeserialized();</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonJsonTypeInfo() {
<b class="nc">&nbsp;      if (super.isJacksonJsonTypeInfo()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().isJacksonJsonTypeInfo();</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public boolean isSerialStructural() {
<b class="nc">&nbsp;      boolean isSerialStructural = super.isSerialStructural();</b>
<b class="nc">&nbsp;      if (isSerialStructural) {</b>
<b class="nc">&nbsp;        return isSerialStructural;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().isSerialStructural();</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
<b class="nc">&nbsp;      Optional&lt;Long&gt; serialVersion = super.serialVersion();</b>
<b class="nc">&nbsp;      if (serialVersion.isPresent()) {</b>
<b class="nc">&nbsp;        return serialVersion;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().serialVersion();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
<b class="nc">&nbsp;      Optional&lt;StyleInfo&gt; style = super.style();</b>
<b class="nc">&nbsp;      if (style.isPresent()) {</b>
<b class="nc">&nbsp;        return style;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().style();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
<b class="nc">&nbsp;      @Nullable String[] dictionary = null;</b>
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        Optional&lt;String[]&gt; depluralize = parent.get().depluralize();</b>
<b class="nc">&nbsp;        if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;          dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;String[]&gt; depluralize = super.depluralize();</b>
<b class="nc">&nbsp;      if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;        dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.fromNullable(dictionary);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void collectEncodings(Collection&lt;EncodingInfo&gt; encodings) {
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        parent.get().collectEncodings(encodings);</b>
&nbsp;      }
<b class="nc">&nbsp;      super.collectEncodings(encodings);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
<b class="nc">&nbsp;      Optional&lt;DataMirror&gt; datatypeMarker = super.datatypeEnabled();</b>
<b class="nc">&nbsp;      if (datatypeMarker.isPresent()) {</b>
<b class="nc">&nbsp;        return datatypeMarker;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;DeclaringPackage&gt; parent = namedParentPackage();</b>
<b class="nc">&nbsp;      if (parent.isPresent()) {</b>
<b class="nc">&nbsp;        return parent.get().datatypeEnabled();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Value.Immutable
<b class="nc">&nbsp;  public static abstract class DeclaringType extends AbstractDeclaring {</b>
&nbsp;    @Override
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract TypeElement element();
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Derived
&nbsp;    public String name() {
<b class="nc">&nbsp;      return element().getQualifiedName().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * returns this class if it&#39;s top level or enclosing top level type.
&nbsp;     * @return accossiated top level type.
&nbsp;     */
&nbsp;    public DeclaringType associatedTopLevel() {
<b class="nc">&nbsp;      return enclosingTopLevel().or(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;DeclaringType&gt; enclosingTopLevel() {
<b class="nc">&nbsp;      TypeElement top = element();</b>
<b class="nc">&nbsp;      for (Element e = top; e.getKind() != ElementKind.PACKAGE; e = e.getEnclosingElement()) {</b>
<b class="nc">&nbsp;        top = (TypeElement) e;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (top == element()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.of(interner().forType(</b>
<b class="nc">&nbsp;          ImmutableProto.DeclaringType.builder()</b>
<b class="nc">&nbsp;              .environment(environment())</b>
<b class="nc">&nbsp;              .interner(interner())</b>
<b class="nc">&nbsp;              .element(top)</b>
<b class="nc">&nbsp;              .build()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;CriteriaMirror&gt; criteria() {
<b class="nc">&nbsp;      return CriteriaMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;RepositoryMirror&gt; repository() {
<b class="nc">&nbsp;      return RepositoryMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository() {
<b class="nc">&nbsp;      return CriteriaRepositoryMirror.find(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;DeclaringType&gt; enclosingOf() {
<b class="nc">&nbsp;      Optional&lt;DeclaringType&gt; topLevel = enclosingTopLevel();</b>
<b class="nc">&nbsp;      if (topLevel.isPresent() &amp;&amp; topLevel.get().isEnclosing()) {</b>
<b class="nc">&nbsp;        return topLevel;</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public DeclaringPackage packageOf() {
<b class="nc">&nbsp;      Element e = element();</b>
<b class="nc">&nbsp;      for (; e.getKind() != ElementKind.PACKAGE; e = e.getEnclosingElement()) {</b>
&nbsp;      }
<b class="nc">&nbsp;      return interner().forPackage(</b>
<b class="nc">&nbsp;          ImmutableProto.DeclaringPackage.builder()</b>
<b class="nc">&nbsp;              .environment(environment())</b>
<b class="nc">&nbsp;              .interner(interner())</b>
<b class="nc">&nbsp;              .element((PackageElement) e)</b>
<b class="nc">&nbsp;              .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;ValueImmutableInfo&gt; features() {
<b class="nc">&nbsp;      Optional&lt;ValueImmutableInfo&gt; immutableAnnotation =</b>
<b class="nc">&nbsp;          ImmutableMirror.find(element()).transform(ToImmutableInfo.FUNCTION);</b>
&nbsp;
<b class="nc">&nbsp;      if (immutableAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;        return immutableAnnotation;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      for (String a : environment().round().customImmutableAnnotations()) {</b>
<b class="nc">&nbsp;        if (isAnnotatedWith(element(), a)) {</b>
<b class="nc">&nbsp;          return Optional.of(environment().defaultStyles().defaults());</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    @Override
&nbsp;    public JacksonMode jacksonSerializeMode() {
<b class="nc">&nbsp;      boolean wasJacksonSerialize = false;</b>
<b class="nc">&nbsp;      for (AnnotationMirror a : element().getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;        TypeElement e = (TypeElement) a.getAnnotationType().asElement();</b>
<b class="nc">&nbsp;        if (!wasJacksonSerialize &amp;&amp; e.getQualifiedName().contentEquals(JACKSON_SERIALIZE)) {</b>
<b class="nc">&nbsp;          wasJacksonSerialize = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (e.getQualifiedName().contentEquals(JACKSON_DESERIALIZE)) {</b>
<b class="nc">&nbsp;          for (ExecutableElement attr : a.getElementValues().keySet()) {</b>
<b class="nc">&nbsp;            if (attr.getSimpleName().contentEquals(&quot;builder&quot;)) {</b>
&nbsp;              // If builder attribute is specified, we don&#39;t consider this as
&nbsp;              // our, immutables, business to generate anything.
<b class="nc">&nbsp;              return JacksonMode.BUILDER;</b>
&nbsp;            }
<b class="nc">&nbsp;          }</b>
<b class="nc">&nbsp;          return JacksonMode.DELEGATED;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return wasJacksonSerialize</b>
<b class="nc">&nbsp;          ? JacksonMode.DELEGATED</b>
<b class="nc">&nbsp;          : JacksonMode.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean useImmutableDefaults() {
<b class="nc">&nbsp;      Optional&lt;ValueImmutableInfo&gt; immutables = features();</b>
<b class="nc">&nbsp;      if (immutables.isPresent()) {</b>
<b class="nc">&nbsp;        return immutables.get().isDefault();</b>
&nbsp;      }
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isEnclosing() {
<b class="nc">&nbsp;      if (EnclosingMirror.isPresent(element())) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (isTopLevel()) {</b>
<b class="nc">&nbsp;        for (MetaAnnotated metaAnnotated : metaAnnotated()) {</b>
<b class="nc">&nbsp;          if (metaAnnotated.isEnclosing()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isModifiable() {
<b class="nc">&nbsp;      return ModifiableMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true, if is top level
&nbsp;     */
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isTopLevel() {
<b class="nc">&nbsp;      return element().getNestingKind() == NestingKind.TOP_LEVEL;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this element is a regular POJO (not an interface or abstract class) simple
&nbsp;     * class with getters and setters
&nbsp;     */
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public boolean isJavaBean() {
<b class="nc">&nbsp;      return element().getKind().isClass()</b>
<b class="nc">&nbsp;          &amp;&amp; element().getKind() != ElementKind.ENUM</b>
<b class="nc">&nbsp;          &amp;&amp; !element().getModifiers().contains(Modifier.PRIVATE)</b>
<b class="nc">&nbsp;          &amp;&amp; !element().getModifiers().contains(Modifier.ABSTRACT)</b>
&nbsp;          &amp;&amp;
&nbsp;          // restrict to Criteria and Repository annotations for now
<b class="nc">&nbsp;          (CriteriaMirror.find(element()).isPresent() || CriteriaRepositoryMirror.find(element()).isPresent());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isImmutable() {
<b class="nc">&nbsp;      return features().isPresent();</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean verifiedFactory(ExecutableElement element) {
<b class="nc">&nbsp;      if (!isTopLevel() || !suitableForBuilderFactory(element)) {</b>
<b class="nc">&nbsp;        report().withElement(element)</b>
<b class="nc">&nbsp;            .annotationNamed(FactoryMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s method &#39;%s&#39; should be static, non-private, non-void and enclosed in top level type&quot;,</b>
<b class="nc">&nbsp;                FactoryMirror.simpleName(),</b>
<b class="nc">&nbsp;                element.getSimpleName());</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean verifiedConstructor(ExecutableElement element) {
<b class="nc">&nbsp;      if (!isTopLevel() || !suitableForBuilderConstructor(element)) {</b>
<b class="nc">&nbsp;        report().withElement(element)</b>
<b class="nc">&nbsp;            .annotationNamed(FConstructorMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s annotated element should be non-private constructor in a top level type&quot;,</b>
<b class="nc">&nbsp;                FConstructorMirror.simpleName(),</b>
<b class="nc">&nbsp;                element.getSimpleName());</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    static boolean suitableForBuilderConstructor(ExecutableElement element) {
<b class="nc">&nbsp;      return element.getKind() == ElementKind.CONSTRUCTOR</b>
<b class="nc">&nbsp;          &amp;&amp; !element.getModifiers().contains(Modifier.PRIVATE);</b>
&nbsp;    }
&nbsp;
&nbsp;    static boolean suitableForBuilderFactory(ExecutableElement element) {
<b class="nc">&nbsp;      return element.getKind() == ElementKind.METHOD</b>
<b class="nc">&nbsp;          &amp;&amp; element.getReturnType().getKind() != TypeKind.VOID</b>
<b class="nc">&nbsp;          &amp;&amp; !element.getModifiers().contains(Modifier.PRIVATE)</b>
<b class="nc">&nbsp;          &amp;&amp; element.getModifiers().contains(Modifier.STATIC);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some validations, not exhaustive.
&nbsp;     */
&nbsp;    @Value.Check
&nbsp;    protected void validate() {
<b class="nc">&nbsp;      if (include().isPresent() &amp;&amp; !isTopLevel()) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(IncludeMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s could not be used on nested types.&quot;, IncludeMirror.simpleName());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (builderInclude().isPresent() &amp;&amp; !isTopLevel()) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(FIncludeMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s could not be used on nested types.&quot;, FIncludeMirror.simpleName());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (isEnclosing() &amp;&amp; !isTopLevel()) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(EnclosingMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s should only be used on a top-level types.&quot;, EnclosingMirror.simpleName());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (isImmutable() &amp;&amp; element().getKind() == ElementKind.ENUM) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(ImmutableMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s is not supported on enums&quot;, ImmutableMirror.simpleName());</b>
&nbsp;      }
<b class="nc">&nbsp;      if (isModifiable() &amp;&amp; (isEnclosed() || isEnclosing())) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(ModifiableMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s could not be used with or within @%s&quot;,</b>
<b class="nc">&nbsp;                ModifiableMirror.simpleName(),</b>
<b class="nc">&nbsp;                EnclosingMirror.simpleName());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public CharSequence sourceCode() {
<b class="nc">&nbsp;      if (!isTopLevel()) {</b>
<b class="nc">&nbsp;        return associatedTopLevel().sourceCode();</b>
&nbsp;      }
<b class="nc">&nbsp;      return SourceExtraction.extract(processing(), CachingElements.getDelegate(element()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public CharSequence headerComments() {
<b class="nc">&nbsp;      if (!isTopLevel()) {</b>
<b class="nc">&nbsp;        return associatedTopLevel().headerComments();</b>
&nbsp;      }
<b class="nc">&nbsp;      return SourceExtraction.headerFrom(sourceCode());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public SourceExtraction.Imports sourceImports() {
<b class="nc">&nbsp;      if (!isTopLevel()) {</b>
<b class="nc">&nbsp;        return associatedTopLevel().sourceImports();</b>
&nbsp;      }
<b class="nc">&nbsp;      return SourceExtraction.importsFrom(sourceCode());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isTransformer() {
<b class="nc">&nbsp;      return getTransform().isPresent();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isVisitor() {
<b class="nc">&nbsp;      return getVisit().isPresent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;TransformMirror&gt; getTransform() {
<b class="nc">&nbsp;      return environment().hasTreesModule()</b>
<b class="nc">&nbsp;          ? TransformMirror.find(element())</b>
<b class="nc">&nbsp;          : Optional.&lt;TransformMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;TreesIncludeMirror&gt; getTreesInclude() {
<b class="nc">&nbsp;      return environment().hasTreesModule()</b>
<b class="nc">&nbsp;          ? TreesIncludeMirror.find(element())</b>
<b class="nc">&nbsp;          : Optional.&lt;TreesIncludeMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;VisitMirror&gt; getVisit() {
<b class="nc">&nbsp;      return environment().hasTreesModule()</b>
<b class="nc">&nbsp;          ? VisitMirror.find(element())</b>
<b class="nc">&nbsp;          : Optional.&lt;VisitMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isAst() {
&nbsp;      // considering ast is still in tree module
<b class="nc">&nbsp;      return environment().hasTreesModule()</b>
<b class="nc">&nbsp;          &amp;&amp; AstMirror.isPresent(element());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEnclosed() {
<b class="nc">&nbsp;      return enclosingOf().isPresent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void collectEncodings(Collection&lt;EncodingInfo&gt; encodings) {
<b class="nc">&nbsp;      if (enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;        enclosingTopLevel().get().collectEncodings(encodings);</b>
&nbsp;      }
<b class="nc">&nbsp;      super.collectEncodings(encodings);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Prototypical model for generated derived classes. {@code Protoclass} could be used to projects
&nbsp;   * different kind of derived classes.
&nbsp;   */
&nbsp;  @Value.Immutable
<b class="nc">&nbsp;  public static abstract class Protoclass extends Diagnosable {</b>
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    public String name() {
<b class="nc">&nbsp;      return SourceNames.sourceQualifiedNameFor(sourceElement());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Source type elements stores type element which is used as a source of value type model.
&nbsp;     * It is the annotated class for {@code @Value.Immutable} or type referenced in
&nbsp;     * {@code @Value.Include}.
&nbsp;     * @return source element
&nbsp;     */
&nbsp;    @Value.Auxiliary
&nbsp;    public abstract Element sourceElement();
&nbsp;
&nbsp;    /**
&nbsp;     * Declaring package that defines value type (usually by import).
&nbsp;     * Or the package in which {@link #declaringType()} resides.
&nbsp;     * @return declaring package
&nbsp;     */
&nbsp;    public abstract DeclaringPackage packageOf();
&nbsp;
&nbsp;    /**
&nbsp;     * The class, which is annotated to be a {@code @Value.Immutable}, {@code @Value.Include} or
&nbsp;     * {@code @Value.Enclosing}.
&nbsp;     * @return declaring type
&nbsp;     */
&nbsp;    public abstract Optional&lt;DeclaringType&gt; declaringType();
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;CriteriaMirror&gt; criteria() {
<b class="nc">&nbsp;      if (!declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      return kind().isIncluded() || kind().isDefinedValue() || kind().isJavaBean()</b>
<b class="nc">&nbsp;          ? declaringType().get().criteria()</b>
<b class="nc">&nbsp;          : Optional.&lt;CriteriaMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;RepositoryMirror&gt; repository() {
<b class="nc">&nbsp;      if (!declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      return kind().isIncluded() || kind().isDefinedValue()</b>
<b class="nc">&nbsp;          ? declaringType().get().repository()</b>
<b class="nc">&nbsp;          : Optional.&lt;RepositoryMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository() {
<b class="nc">&nbsp;      if (!declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      return kind().isIncluded() || kind().isDefinedValue() || kind().isJavaBean()</b>
<b class="nc">&nbsp;          ? declaringType().get().criteriaRepository()</b>
<b class="nc">&nbsp;          : Optional.&lt;CriteriaRepositoryMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;TypeAdaptersMirror&gt; gsonTypeAdapters() {
<b class="nc">&nbsp;      Optional&lt;AbstractDeclaring&gt; typeAdaptersProvider = typeAdaptersProvider();</b>
<b class="nc">&nbsp;      if (typeAdaptersProvider.isPresent()) {</b>
<b class="nc">&nbsp;        return typeAdaptersProvider.get().typeAdapters();</b>
&nbsp;      }
<b class="nc">&nbsp;      if ((kind().isDefinedValue() || kind().isIncluded())</b>
<b class="nc">&nbsp;          &amp;&amp; !kind().isNested()</b>
<b class="nc">&nbsp;          &amp;&amp; repository().isPresent()) {</b>
<b class="nc">&nbsp;        return Optional.of(environment().defaultTypeAdapters());</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;AbstractDeclaring&gt; typeAdaptersProvider() {
&nbsp;      Optional&lt;DeclaringType&gt; typeDefining =
<b class="nc">&nbsp;          declaringType().isPresent()</b>
<b class="nc">&nbsp;              ? Optional.of(declaringType().get().associatedTopLevel())</b>
<b class="nc">&nbsp;              : Optional.&lt;DeclaringType&gt;absent();</b>
&nbsp;
&nbsp;      Optional&lt;TypeAdaptersMirror&gt; typeDefined =
<b class="nc">&nbsp;          typeDefining.isPresent()</b>
<b class="nc">&nbsp;              ? typeDefining.get().typeAdapters()</b>
<b class="nc">&nbsp;              : Optional.&lt;TypeAdaptersMirror&gt;absent();</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;TypeAdaptersMirror&gt; packageDefined = packageOf().typeAdapters();</b>
&nbsp;
<b class="nc">&nbsp;      if (packageDefined.isPresent()) {</b>
<b class="nc">&nbsp;        if (typeDefined.isPresent()) {</b>
<b class="nc">&nbsp;          report()</b>
<b class="nc">&nbsp;              .withElement(typeDefining.get().element())</b>
<b class="nc">&nbsp;              .annotationNamed(TypeAdaptersMirror.simpleName())</b>
<b class="nc">&nbsp;              .warning(About.INCOMPAT,</b>
&nbsp;                  &quot;@%s is also used on the package, this type level annotation is ignored&quot;,
<b class="nc">&nbsp;                  TypeAdaptersMirror.simpleName());</b>
&nbsp;        }
<b class="nc">&nbsp;        return Optional.&lt;AbstractDeclaring&gt;of(packageOf());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return typeDefined.isPresent()</b>
<b class="nc">&nbsp;          ? Optional.&lt;AbstractDeclaring&gt;of(typeDefining.get())</b>
<b class="nc">&nbsp;          : Optional.&lt;AbstractDeclaring&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;OkTypeAdaptersMirror&gt; okJsonTypeAdapters() {
<b class="nc">&nbsp;      Optional&lt;AbstractDeclaring&gt; typeAdaptersProvider = okTypeAdaptersProvider();</b>
<b class="nc">&nbsp;      if (typeAdaptersProvider.isPresent()) {</b>
<b class="nc">&nbsp;        return typeAdaptersProvider.get().okTypeAdapters();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;AbstractDeclaring&gt; okTypeAdaptersProvider() {
&nbsp;      Optional&lt;DeclaringType&gt; typeDefining =
<b class="nc">&nbsp;          declaringType().isPresent()</b>
<b class="nc">&nbsp;              ? Optional.of(declaringType().get().associatedTopLevel())</b>
<b class="nc">&nbsp;              : Optional.&lt;DeclaringType&gt;absent();</b>
&nbsp;
&nbsp;      Optional&lt;OkTypeAdaptersMirror&gt; typeDefined =
<b class="nc">&nbsp;          typeDefining.isPresent()</b>
<b class="nc">&nbsp;              ? typeDefining.get().okTypeAdapters()</b>
<b class="nc">&nbsp;              : Optional.&lt;OkTypeAdaptersMirror&gt;absent();</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;OkTypeAdaptersMirror&gt; packageDefined = packageOf().okTypeAdapters();</b>
&nbsp;
<b class="nc">&nbsp;      if (packageDefined.isPresent()) {</b>
<b class="nc">&nbsp;        if (typeDefined.isPresent()) {</b>
<b class="nc">&nbsp;          report()</b>
<b class="nc">&nbsp;              .withElement(typeDefining.get().element())</b>
<b class="nc">&nbsp;              .annotationNamed(OkTypeAdaptersMirror.simpleName())</b>
<b class="nc">&nbsp;              .warning(&quot;@%s is also used on the package, this type level annotation is ignored&quot;,</b>
<b class="nc">&nbsp;                  OkTypeAdaptersMirror.simpleName());</b>
&nbsp;        }
<b class="nc">&nbsp;        return Optional.&lt;AbstractDeclaring&gt;of(packageOf());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return typeDefined.isPresent()</b>
<b class="nc">&nbsp;          ? Optional.&lt;AbstractDeclaring&gt;of(typeDefining.get())</b>
<b class="nc">&nbsp;          : Optional.&lt;AbstractDeclaring&gt;absent();</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;DataMirror&gt; datatypeMarker() {
<b class="nc">&nbsp;      Optional&lt;AbstractDeclaring&gt; provider = datatypeProvider();</b>
<b class="nc">&nbsp;      if (provider.isPresent()) {</b>
<b class="nc">&nbsp;        return provider.get().datatypeEnabled();</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;AbstractDeclaring&gt; datatypeProvider() {
&nbsp;      Optional&lt;DeclaringType&gt; typeDefining =
<b class="nc">&nbsp;          declaringType().isPresent()</b>
<b class="nc">&nbsp;              ? Optional.of(declaringType().get().associatedTopLevel())</b>
<b class="nc">&nbsp;              : Optional.&lt;DeclaringType&gt;absent();</b>
&nbsp;
&nbsp;      Optional&lt;DataMirror&gt; typeDefined =
<b class="nc">&nbsp;          typeDefining.isPresent()</b>
<b class="nc">&nbsp;              ? typeDefining.get().datatypeEnabled()</b>
<b class="nc">&nbsp;              : Optional.&lt;DataMirror&gt;absent();</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;DataMirror&gt; packageDefined = packageOf().datatypeEnabled();</b>
&nbsp;
<b class="nc">&nbsp;      if (packageDefined.isPresent()) {</b>
<b class="nc">&nbsp;        if (typeDefined.isPresent()) {</b>
<b class="nc">&nbsp;          report()</b>
<b class="nc">&nbsp;              .withElement(typeDefining.get().element())</b>
<b class="nc">&nbsp;              .annotationNamed(DataMirror.simpleName())</b>
<b class="nc">&nbsp;              .warning(&quot;@%s is also used on the package, this type level annotation is ignored&quot;,</b>
<b class="nc">&nbsp;                  DataMirror.simpleName());</b>
&nbsp;        }
<b class="nc">&nbsp;        return Optional.&lt;AbstractDeclaring&gt;of(packageOf());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return typeDefined.isPresent()</b>
<b class="nc">&nbsp;          ? Optional.&lt;AbstractDeclaring&gt;of(typeDefining.get())</b>
<b class="nc">&nbsp;          : Optional.&lt;AbstractDeclaring&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Kind of protoclass declaration, it specifies how exactly the protoclass was declared.
&nbsp;     * @return definition kind
&nbsp;     */
&nbsp;    public abstract Kind kind();
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    public Visibility visibility() {
<b class="nc">&nbsp;      return Visibility.of(sourceElement());</b>
&nbsp;    }
&nbsp;
&nbsp;    public Visibility declaringVisibility() {
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        return Visibility.of(declaringType().get().element());</b>
&nbsp;      }
<b class="nc">&nbsp;      return Visibility.PUBLIC;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Element used mostly for error reporting,
&nbsp;     * real model provided by {@link #sourceElement()}.
&nbsp;     */
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    @Override
&nbsp;    public Element element() {
<b class="nc">&nbsp;      if (kind().isFactory()) {</b>
<b class="nc">&nbsp;        return sourceElement();</b>
&nbsp;      }
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        return declaringType().get().element();</b>
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().element();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType t = declaringType().get();</b>
<b class="nc">&nbsp;        if (t.serialVersion().isPresent()) {</b>
<b class="nc">&nbsp;          return t.serialVersion();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;          if (t.enclosingTopLevel().get().serialVersion().isPresent()) {</b>
<b class="nc">&nbsp;            return t.enclosingTopLevel().get().serialVersion();</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().serialVersion();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isSerialStructural() {
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType t = declaringType().get();</b>
<b class="nc">&nbsp;        if (t.isSerialStructural()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;          if (t.enclosingTopLevel().get().isSerialStructural()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().isSerialStructural();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonSerialized() {
<b class="nc">&nbsp;      if (!styles().style().jacksonIntegration()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType t = declaringType().get();</b>
<b class="nc">&nbsp;        if (t.isJacksonSerialized()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;          if (t.enclosingTopLevel().get().isJacksonSerialized()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().isJacksonSerialized();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonDeserialized() {
<b class="nc">&nbsp;      if (!styles().style().jacksonIntegration()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType t = declaringType().get();</b>
<b class="nc">&nbsp;        if (t.isJacksonDeserialized()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (t.enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;          if (t.enclosingTopLevel().get().isJacksonDeserialized()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().isJacksonDeserialized();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public ValueImmutableInfo features() {
<b class="nc">&nbsp;      if (declaringType().isPresent()</b>
<b class="nc">&nbsp;          &amp;&amp; !declaringType().get().useImmutableDefaults()) {</b>
<b class="nc">&nbsp;        Optional&lt;ValueImmutableInfo&gt; features = declaringType().get().features();</b>
<b class="nc">&nbsp;        if (features.isPresent()) {</b>
<b class="nc">&nbsp;          return features.get();</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return styles().defaults();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Styles styles() {
<b class="nc">&nbsp;      StyleInfo styleInfo = determineStyle().or(environment().defaultStyles());</b>
<b class="nc">&nbsp;      Optional&lt;String[]&gt; depluralize = depluralize();</b>
<b class="nc">&nbsp;      if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;        styleInfo = ImmutableStyleInfo.copyOf(styleInfo)</b>
<b class="nc">&nbsp;            .withDepluralize(true)</b>
<b class="nc">&nbsp;            .withDepluralizeDictionary(concat(styleInfo.depluralizeDictionary(), depluralize.get()));</b>
&nbsp;      }
<b class="nc">&nbsp;      return styleInfo.getStyles();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
<b class="nc">&nbsp;      @Nullable String[] dictionary = null;</b>
&nbsp;
<b class="nc">&nbsp;      Optional&lt;String[]&gt; depluralize = packageOf().depluralize();</b>
<b class="nc">&nbsp;      if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;        dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType type = declaringType().get();</b>
&nbsp;
<b class="nc">&nbsp;        if (type.enclosingTopLevel().isPresent()) {</b>
<b class="nc">&nbsp;          depluralize = type.enclosingTopLevel().get().depluralize();</b>
&nbsp;
<b class="nc">&nbsp;          if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;            dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;          }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        depluralize = type.depluralize();</b>
<b class="nc">&nbsp;        if (depluralize.isPresent()) {</b>
<b class="nc">&nbsp;          dictionary = concat(dictionary, depluralize.get());</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Optional.fromNullable(dictionary);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Optional&lt;StyleInfo&gt; determineStyle() {
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType type = declaringType().get();</b>
&nbsp;
<b class="nc">&nbsp;        Optional&lt;DeclaringType&gt; enclosing = type.enclosingOf();</b>
<b class="nc">&nbsp;        if (enclosing.isPresent()) {</b>
<b class="nc">&nbsp;          Optional&lt;StyleInfo&gt; enclosingStyle = enclosing.get().style();</b>
<b class="nc">&nbsp;          if (enclosing.get() != type) {</b>
<b class="nc">&nbsp;            Optional&lt;StyleInfo&gt; style = type.style();</b>
<b class="nc">&nbsp;            if (style.isPresent()</b>
<b class="nc">&nbsp;                &amp;&amp; enclosingStyle.isPresent()</b>
<b class="nc">&nbsp;                &amp;&amp; !style.equals(enclosingStyle)) {</b>
<b class="nc">&nbsp;              warnAboutIncompatibleStyles();</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          if (enclosingStyle.isPresent()) {</b>
<b class="nc">&nbsp;            return enclosingStyle;</b>
&nbsp;          }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;          Optional&lt;StyleInfo&gt; style = type.style();</b>
<b class="nc">&nbsp;          if (style.isPresent()) {</b>
<b class="nc">&nbsp;            return style;</b>
&nbsp;          }
<b class="nc">&nbsp;          Optional&lt;DeclaringType&gt; topLevel = type.enclosingTopLevel();</b>
<b class="nc">&nbsp;          if (topLevel.isPresent() &amp;&amp; topLevel.get().style().isPresent()) {</b>
<b class="nc">&nbsp;            return topLevel.get().style();</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().style();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void warnAboutIncompatibleStyles() {
<b class="nc">&nbsp;      report().annotationNamed(StyleMirror.simpleName())</b>
<b class="nc">&nbsp;          .warning(About.INCOMPAT,</b>
&nbsp;              &quot;Use styles only on enclosing types.&quot;
&nbsp;                  + &quot; All nested styles will inherit it.&quot;
&nbsp;                  + &quot; Nested immutables cannot deviate in style from enclosing type,&quot;
&nbsp;                  + &quot; so generated stucture will be consistent&quot;);
&nbsp;    }
&nbsp;
&nbsp;    @Value.Derived
&nbsp;    @Value.Auxiliary
&nbsp;    public Optional&lt;DeclaringType&gt; enclosingOf() {
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        if (kind().isFactory()) {</b>
<b class="nc">&nbsp;          return declaringType();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (kind().isNested()) {</b>
<b class="nc">&nbsp;          if (kind().isIncluded()) {</b>
<b class="nc">&nbsp;            return declaringType();</b>
&nbsp;          }
<b class="nc">&nbsp;          return declaringType().get().enclosingOf();</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    TypeNames createTypeNames() {
<b class="nc">&nbsp;      Element sourceElement = sourceElement();</b>
<b class="nc">&nbsp;      if (sourceElement.getKind() == ElementKind.CONSTRUCTOR) {</b>
<b class="nc">&nbsp;        sourceElement = sourceElement.getEnclosingElement();</b>
&nbsp;      }
<b class="nc">&nbsp;      return styles().forType(sourceElement.getSimpleName().toString());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public enum Kind {</b>
<b class="nc">&nbsp;      INCLUDED_IN_PACKAGE,</b>
<b class="nc">&nbsp;      INCLUDED_ON_TYPE,</b>
<b class="nc">&nbsp;      INCLUDED_FACTORY_IN_PACKAGE,</b>
<b class="nc">&nbsp;      INCLUDED_FACTORY_ON_TYPE,</b>
<b class="nc">&nbsp;      INCLUDED_CONSTRUCTOR_IN_PACKAGE,</b>
<b class="nc">&nbsp;      INCLUDED_CONSTRUCTOR_ON_TYPE,</b>
<b class="nc">&nbsp;      INCLUDED_IN_TYPE,</b>
<b class="nc">&nbsp;      DEFINED_FACTORY,</b>
<b class="nc">&nbsp;      DEFINED_NESTED_FACTORY,</b>
<b class="nc">&nbsp;      DEFINED_CONSTRUCTOR,</b>
<b class="nc">&nbsp;      DEFINED_NESTED_CONSTRUCTOR,</b>
<b class="nc">&nbsp;      DEFINED_TYPE,</b>
<b class="nc">&nbsp;      DEFINED_JAVABEAN,</b>
<b class="nc">&nbsp;      DEFINED_TYPE_AND_COMPANION,</b>
<b class="nc">&nbsp;      DEFINED_COMPANION,</b>
<b class="nc">&nbsp;      DEFINED_AND_ENCLOSING_TYPE,</b>
<b class="nc">&nbsp;      DEFINED_ENCLOSING_TYPE,</b>
<b class="nc">&nbsp;      DEFINED_NESTED_TYPE;</b>
&nbsp;
&nbsp;      public boolean isNested() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case INCLUDED_IN_TYPE:
&nbsp;        case DEFINED_NESTED_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isNestedFactoryOrConstructor() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_NESTED_FACTORY:
&nbsp;        case DEFINED_NESTED_CONSTRUCTOR:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isIncluded() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case INCLUDED_IN_PACKAGE:
&nbsp;        case INCLUDED_IN_TYPE:
&nbsp;        case INCLUDED_ON_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isEnclosing() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_AND_ENCLOSING_TYPE:
&nbsp;        case DEFINED_ENCLOSING_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isJavaBean() {
<b class="nc">&nbsp;        return this == DEFINED_JAVABEAN;</b>
&nbsp;      }
&nbsp;
&nbsp;      public boolean isValue() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case INCLUDED_IN_PACKAGE:
&nbsp;        case INCLUDED_ON_TYPE:
&nbsp;        case INCLUDED_IN_TYPE:
&nbsp;        case DEFINED_TYPE:
&nbsp;        case DEFINED_TYPE_AND_COMPANION:
&nbsp;        case DEFINED_AND_ENCLOSING_TYPE:
&nbsp;        case DEFINED_NESTED_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isDefinedValue() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_TYPE:
&nbsp;        case DEFINED_TYPE_AND_COMPANION:
&nbsp;        case DEFINED_AND_ENCLOSING_TYPE:
&nbsp;        case DEFINED_NESTED_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isModifiable() {
<b class="nc">&nbsp;        return this == DEFINED_TYPE_AND_COMPANION</b>
&nbsp;            || this == DEFINED_COMPANION;
&nbsp;      }
&nbsp;
&nbsp;      public boolean isConstructor() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_CONSTRUCTOR:
&nbsp;        case INCLUDED_CONSTRUCTOR_IN_PACKAGE:
&nbsp;        case INCLUDED_CONSTRUCTOR_ON_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isFactoryNotNested() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_FACTORY:
&nbsp;        case INCLUDED_FACTORY_IN_PACKAGE:
&nbsp;        case INCLUDED_FACTORY_ON_TYPE:
&nbsp;        case DEFINED_CONSTRUCTOR:
&nbsp;        case INCLUDED_CONSTRUCTOR_IN_PACKAGE:
&nbsp;        case INCLUDED_CONSTRUCTOR_ON_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isFactory() {
<b class="nc">&nbsp;        switch (this) {</b>
&nbsp;        case DEFINED_FACTORY:
&nbsp;        case DEFINED_NESTED_FACTORY:
&nbsp;        case INCLUDED_FACTORY_IN_PACKAGE:
&nbsp;        case INCLUDED_FACTORY_ON_TYPE:
&nbsp;        case DEFINED_CONSTRUCTOR:
&nbsp;        case DEFINED_NESTED_CONSTRUCTOR:
&nbsp;        case INCLUDED_CONSTRUCTOR_IN_PACKAGE:
&nbsp;        case INCLUDED_CONSTRUCTOR_ON_TYPE:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        default:
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      public boolean isEnclosingOnly() {
<b class="nc">&nbsp;        return this == DEFINED_ENCLOSING_TYPE;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public boolean isJacksonJsonTypeInfo() {
<b class="nc">&nbsp;      if (!styles().style().jacksonIntegration()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        DeclaringType type = declaringType().get();</b>
<b class="nc">&nbsp;        if (type.isJacksonJsonTypeInfo()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return packageOf().isJacksonJsonTypeInfo();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isAst() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          &amp;&amp; declaringType().get().isAst();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isTransformer() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          &amp;&amp; declaringType().get().isTransformer();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isVisitor() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          &amp;&amp; declaringType().get().isVisitor();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Optional&lt;TransformMirror&gt; getTransform() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          ? declaringType().get().getTransform()</b>
<b class="nc">&nbsp;          : Optional.&lt;TransformMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Optional&lt;VisitMirror&gt; getVisit() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          ? declaringType().get().getVisit()</b>
<b class="nc">&nbsp;          : Optional.&lt;VisitMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Optional&lt;TreesIncludeMirror&gt; getTreesInclude() {
<b class="nc">&nbsp;      return declaringType().isPresent()</b>
<b class="nc">&nbsp;          ? declaringType().get().getTreesInclude()</b>
<b class="nc">&nbsp;          : Optional.&lt;TreesIncludeMirror&gt;absent();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Constitution constitution() {
<b class="nc">&nbsp;      return ImmutableConstitution.builder()</b>
<b class="nc">&nbsp;          .protoclass(this)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Value.Lazy
&nbsp;    public Instantiator encodingInstantiator() {
<b class="nc">&nbsp;      List&lt;EncodingInfo&gt; results = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      packageOf().collectEncodings(results);</b>
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        declaringType().get().collectEncodings(results);</b>
&nbsp;      }
<b class="nc">&nbsp;      return environment().instantiatorFor(FluentIterable.from(results).toSet());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isJacksonProperties() {
<b class="nc">&nbsp;      if (!styles().style().jacksonIntegration()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        if (declaringType().get().jacksonSerializeMode() != JacksonMode.NONE) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return isJacksonSerialized();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private List&lt;String&gt; debugLines = ImmutableList.of();</b>
&nbsp;
&nbsp;    // This is not part of the logical structure of the protoclass
&nbsp;    // but it seems that this is the best place to have this info
&nbsp;    Protoclass debug(String line) {
&nbsp;      if (!DEBUG_ON)
<b class="nc">&nbsp;        return this;</b>
&nbsp;      if (debugLines.isEmpty()) {
&nbsp;        debugLines = Lists.newArrayList();
&nbsp;      }
&nbsp;      debugLines.add(line);
&nbsp;      return this;
&nbsp;    }
&nbsp;
&nbsp;    List&lt;String&gt; getDebugLines() {
<b class="nc">&nbsp;      return debugLines;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum ElementToName implements Function&lt;TypeElement, String&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public String apply(TypeElement input) {
<b class="nc">&nbsp;      return input.getQualifiedName().toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum DeclatedTypeToElement implements Function&lt;DeclaredType, TypeElement&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeElement apply(DeclaredType input) {
<b class="nc">&nbsp;      return (TypeElement) input.asElement();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum IsPublic implements Predicate&lt;Element&gt; {</b>
<b class="nc">&nbsp;    PREDICATE;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean apply(Element input) {
<b class="nc">&nbsp;      return input.getModifiers().contains(Modifier.PUBLIC);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum ToImmutableInfo implements Function&lt;ImmutableMirror, ValueImmutableInfo&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public ValueImmutableInfo apply(ImmutableMirror input) {
<b class="nc">&nbsp;      return ValueImmutableInfo.infoFrom(input);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum ToStyleInfo implements Function&lt;StyleMirror, StyleInfo&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public StyleInfo apply(StyleMirror input) {
<b class="nc">&nbsp;      return StyleInfo.infoFrom(input);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum ToInjectionInfo implements Function&lt;InjectAnnotationMirror, InjectionInfo&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public InjectionInfo apply(InjectAnnotationMirror input) {
<b class="nc">&nbsp;      return AnnotationInjections.infoFrom(input);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  static boolean isJacksonSerializedAnnotated(Element element) {
<b class="nc">&nbsp;    return isAnnotatedWith(element, JACKSON_SERIALIZE)</b>
<b class="nc">&nbsp;        || isAnnotatedWith(element, JACKSON_DESERIALIZE);</b>
&nbsp;  }
&nbsp;
&nbsp;  static boolean isJacksonDeserializedAnnotated(Element element) {
<b class="nc">&nbsp;    return isAnnotatedWith(element, JACKSON_DESERIALIZE);</b>
&nbsp;  }
&nbsp;
&nbsp;  static boolean isJacksonJsonTypeInfoAnnotated(Element element) {
<b class="nc">&nbsp;    return isAnnotatedWith(element, JACKSON_TYPE_INFO);</b>
&nbsp;  }
&nbsp;
&nbsp;  static boolean isAnnotatedWith(Element element, String annotation) {
<b class="nc">&nbsp;    for (AnnotationMirror a : element.getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;      TypeElement e = (TypeElement) a.getAnnotationType().asElement();</b>
<b class="nc">&nbsp;      if (e.getQualifiedName().contentEquals(annotation)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (Annotations.hasJacksonPackagePrefix(annotation)</b>
<b class="nc">&nbsp;          &amp;&amp; !annotation.equals(JACKSON_ANNOTATIONS_INSIDE)</b>
<b class="nc">&nbsp;          &amp;&amp; isAnnotatedWith(e, JACKSON_ANNOTATIONS_INSIDE)</b>
<b class="nc">&nbsp;          &amp;&amp; isAnnotatedWith(e, annotation)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  static @Nullable String[] concat(@Nullable String[] first, @Nullable String[] second) {
<b class="nc">&nbsp;    if (first == null)</b>
<b class="nc">&nbsp;      return second;</b>
<b class="nc">&nbsp;    if (second == null)</b>
<b class="nc">&nbsp;      return first;</b>
<b class="nc">&nbsp;    return ObjectArrays.concat(first, second, String.class);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static final boolean DEBUG_ON = false;
&nbsp;
&nbsp;  static final String ORDINAL_VALUE_INTERFACE_TYPE = &quot;org.immutables.ordinal.OrdinalValue&quot;;
&nbsp;  static final String JACKSON_TYPE_INFO = &quot;com.fasterxml.jackson.annotation.JsonTypeInfo&quot;;
&nbsp;  static final String JACKSON_DESERIALIZE = &quot;com.fasterxml.jackson.databind.annotation.JsonDeserialize&quot;;
&nbsp;  static final String JACKSON_SERIALIZE = &quot;com.fasterxml.jackson.databind.annotation.JsonSerialize&quot;;
&nbsp;  static final String JACKSON_ANNOTATIONS_INSIDE = &quot;com.fasterxml.jackson.annotation.JacksonAnnotationsInside&quot;;
&nbsp;  static final String PARCELABLE_INTERFACE_TYPE = &quot;android.os.Parcelable&quot;;
&nbsp;  static final String PARCELABLE_CREATOR_FIELD = &quot;CREATOR&quot;;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
