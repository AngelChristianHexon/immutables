


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CachingElements</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: CachingElements (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CachingElements</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CachingElements$Caching</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingAnnotationMirror</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingDeclaredType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingExecutableElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingPackageElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachingElements$CachingTypeElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/120)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2015 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import javax.lang.model.element.AnnotationMirror;
&nbsp;import javax.lang.model.element.AnnotationValue;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ElementVisitor;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.Name;
&nbsp;import javax.lang.model.element.NestingKind;
&nbsp;import javax.lang.model.element.PackageElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.element.TypeParameterElement;
&nbsp;import javax.lang.model.element.VariableElement;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.type.TypeVisitor;
&nbsp;import org.immutables.generator.Delegated;
&nbsp;
&nbsp;/**
&nbsp; * Some annotation processors have {@code javax.lang.model} being implemented using relatively
&nbsp; * expensive conversions from internal model. When some properties are being queried again and
&nbsp; * again, annotation mirrors or enclosed elements are worth to store. Implementations wrappers cache
&nbsp; * some properties eagerly and some lazily.
&nbsp; */
<b class="nc">&nbsp;public final class CachingElements {</b>
&nbsp;  private CachingElements() {}
&nbsp;
&nbsp;  public static Element asCaching(Element element) {
<b class="nc">&nbsp;    if (element instanceof Caching) {</b>
<b class="nc">&nbsp;      return element;</b>
&nbsp;    }
<b class="nc">&nbsp;    return new CachingElement(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static TypeElement asCaching(TypeElement element) {
<b class="nc">&nbsp;    if (element instanceof Caching) {</b>
<b class="nc">&nbsp;      return element;</b>
&nbsp;    }
<b class="nc">&nbsp;    return new CachingTypeElement(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static &lt;E extends Element&gt; E getDelegate(E element) {
<b class="nc">&nbsp;    return Delegated.unwrap(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static &lt;E extends AnnotationMirror&gt; E getDelegate(E element) {
<b class="nc">&nbsp;    return Delegated.unwrap(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static PackageElement asCaching(PackageElement element) {
<b class="nc">&nbsp;    if (element instanceof Caching) {</b>
<b class="nc">&nbsp;      return element;</b>
&nbsp;    }
<b class="nc">&nbsp;    return new CachingPackageElement(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static ExecutableElement asCaching(ExecutableElement element) {
<b class="nc">&nbsp;    if (element instanceof Caching) {</b>
<b class="nc">&nbsp;      return element;</b>
&nbsp;    }
<b class="nc">&nbsp;    return new CachingExecutableElement(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static AnnotationMirror asCaching(AnnotationMirror mirror) {
<b class="nc">&nbsp;    if (mirror instanceof Caching) {</b>
<b class="nc">&nbsp;      return mirror;</b>
&nbsp;    }
<b class="nc">&nbsp;    return new CachingAnnotationMirror(mirror);</b>
&nbsp;  }
&nbsp;
&nbsp;  public static boolean equals(Element left, Element right) {
<b class="nc">&nbsp;    return getDelegate(left).equals(getDelegate(right));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static List&lt;AnnotationMirror&gt; asCaching(List&lt;? extends AnnotationMirror&gt; mirrors) {
<b class="nc">&nbsp;    List&lt;AnnotationMirror&gt; cachingMirrors = Lists.newArrayListWithCapacity(mirrors.size());</b>
<b class="nc">&nbsp;    for (AnnotationMirror mirror : mirrors) {</b>
<b class="nc">&nbsp;      cachingMirrors.add(new CachingAnnotationMirror(mirror));</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return cachingMirrors;</b>
&nbsp;  }
&nbsp;
&nbsp;  private interface Caching extends Delegated {}
&nbsp;
&nbsp;  private static class CachingExecutableElement extends CachingElement implements ExecutableElement {
&nbsp;    private final ExecutableElement delegate;
&nbsp;    private final TypeMirror returnType;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private List&lt;? extends VariableElement&gt; parameters;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private List&lt;? extends TypeParameterElement&gt; typeParameters;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private AnnotationValue defaultValue;
&nbsp;
&nbsp;    CachingExecutableElement(ExecutableElement delegate) {
<b class="nc">&nbsp;      super(delegate);</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.returnType = delegate.getReturnType();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends VariableElement&gt; getParameters() {
<b class="nc">&nbsp;      List&lt;? extends VariableElement&gt; ps = parameters;</b>
<b class="nc">&nbsp;      if (ps == null) {</b>
<b class="nc">&nbsp;        ps = delegate.getParameters();</b>
<b class="nc">&nbsp;        parameters = ps;</b>
&nbsp;      }
<b class="nc">&nbsp;      return ps;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends TypeParameterElement&gt; getTypeParameters() {
<b class="nc">&nbsp;      List&lt;? extends TypeParameterElement&gt; tps = typeParameters;</b>
<b class="nc">&nbsp;      if (tps == null) {</b>
<b class="nc">&nbsp;        tps = delegate.getTypeParameters();</b>
<b class="nc">&nbsp;        typeParameters = tps;</b>
&nbsp;      }
<b class="nc">&nbsp;      return tps;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeMirror getReturnType() {
<b class="nc">&nbsp;      return returnType;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends TypeMirror&gt; getThrownTypes() {
<b class="nc">&nbsp;      return delegate.getThrownTypes();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotationValue getDefaultValue() {
<b class="nc">&nbsp;      AnnotationValue dv = defaultValue;</b>
<b class="nc">&nbsp;      if (dv == null) {</b>
<b class="nc">&nbsp;        dv = delegate.getDefaultValue();</b>
<b class="nc">&nbsp;        defaultValue = dv;</b>
&nbsp;      }
<b class="nc">&nbsp;      return dv;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isVarArgs() {
<b class="nc">&nbsp;      return delegate.isVarArgs();</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public boolean isDefault() {
<b class="nc">&nbsp;      return delegate.isDefault();</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public TypeMirror getReceiverType() {
<b class="nc">&nbsp;      return delegate.getReceiverType();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class CachingPackageElement extends CachingElement implements PackageElement {
&nbsp;    private final PackageElement delegate;
&nbsp;    private final Name qualifiedName;
&nbsp;
&nbsp;    CachingPackageElement(PackageElement delegate) {
<b class="nc">&nbsp;      super(delegate);</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.qualifiedName = delegate.getQualifiedName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Name getQualifiedName() {
<b class="nc">&nbsp;      return qualifiedName;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isUnnamed() {
<b class="nc">&nbsp;      return delegate.isUnnamed();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class CachingTypeElement extends CachingElement implements TypeElement {
&nbsp;    private final TypeElement delegate;
&nbsp;    private final Name qualifiedName;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private List&lt;? extends TypeParameterElement&gt; typeParameters;
&nbsp;
&nbsp;    CachingTypeElement(TypeElement delegate) {
<b class="nc">&nbsp;      super(delegate);</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.qualifiedName = delegate.getQualifiedName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestingKind getNestingKind() {
<b class="nc">&nbsp;      return delegate.getNestingKind();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Name getQualifiedName() {
<b class="nc">&nbsp;      return qualifiedName;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeMirror getSuperclass() {
<b class="nc">&nbsp;      return delegate.getSuperclass();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends TypeMirror&gt; getInterfaces() {
<b class="nc">&nbsp;      return delegate.getInterfaces();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends TypeParameterElement&gt; getTypeParameters() {
<b class="nc">&nbsp;      List&lt;? extends TypeParameterElement&gt; tps = typeParameters;</b>
<b class="nc">&nbsp;      if (tps == null) {</b>
<b class="nc">&nbsp;        tps = delegate.getTypeParameters();</b>
<b class="nc">&nbsp;        typeParameters = tps;</b>
&nbsp;      }
<b class="nc">&nbsp;      return tps;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class CachingElement implements Element, Caching {
&nbsp;    private final Element delegate;
&nbsp;    private final ElementKind kind;
&nbsp;    private final Name simpleName;
&nbsp;    private final Set&lt;Modifier&gt; modifiers;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private Element enclosingElement;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private List&lt;? extends Element&gt; enclosedElements;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private List&lt;? extends AnnotationMirror&gt; annotationMirrors;
&nbsp;
<b class="nc">&nbsp;    CachingElement(Element delegate) {</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.kind = delegate.getKind();</b>
<b class="nc">&nbsp;      this.simpleName = delegate.getSimpleName();</b>
<b class="nc">&nbsp;      this.modifiers = delegate.getModifiers();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Element delegate() {
<b class="nc">&nbsp;      return delegate;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors() {
<b class="nc">&nbsp;      List&lt;? extends AnnotationMirror&gt; ms = annotationMirrors;</b>
<b class="nc">&nbsp;      if (ms == null) {</b>
<b class="nc">&nbsp;        ms = asCaching(delegate.getAnnotationMirrors());</b>
<b class="nc">&nbsp;        annotationMirrors = ms;</b>
&nbsp;      }
<b class="nc">&nbsp;      return ms;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Set&lt;Modifier&gt; getModifiers() {
<b class="nc">&nbsp;      return modifiers;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Name getSimpleName() {
<b class="nc">&nbsp;      return simpleName;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Element getEnclosingElement() {
<b class="nc">&nbsp;      Element e = enclosingElement;</b>
<b class="nc">&nbsp;      if (e == null) {</b>
<b class="nc">&nbsp;        e = delegate.getEnclosingElement();</b>
<b class="nc">&nbsp;        enclosingElement = e;</b>
&nbsp;      }
<b class="nc">&nbsp;      return e;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends Element&gt; getEnclosedElements() {
<b class="nc">&nbsp;      List&lt;? extends Element&gt; es = enclosedElements;</b>
<b class="nc">&nbsp;      if (es == null) {</b>
<b class="nc">&nbsp;        es = delegate.getEnclosedElements();</b>
<b class="nc">&nbsp;        enclosedElements = es;</b>
&nbsp;      }
<b class="nc">&nbsp;      return es;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeMirror asType() {
<b class="nc">&nbsp;      return delegate.asType();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ElementKind getKind() {
<b class="nc">&nbsp;      return kind;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
<b class="nc">&nbsp;      return delegate.getAnnotation(annotationType);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="nc">&nbsp;      return delegate.equals(obj);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;      return delegate.hashCode();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
<b class="nc">&nbsp;      return delegate.accept(v, p);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; type) {
<b class="nc">&nbsp;      return delegate.getAnnotationsByType(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return delegate.toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class CachingAnnotationMirror implements AnnotationMirror, Caching {
&nbsp;    private final AnnotationMirror delegate;
&nbsp;    // not volatile, it&#39;s ok to have some additional instances at race condition
&nbsp;    private Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; elementValues;
&nbsp;    private final DeclaredType annotationType;
&nbsp;
<b class="nc">&nbsp;    CachingAnnotationMirror(AnnotationMirror delegate) {</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.annotationType = new CachingDeclaredType(delegate.getAnnotationType());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public DeclaredType getAnnotationType() {
<b class="nc">&nbsp;      return annotationType;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; getElementValues() {
<b class="nc">&nbsp;      Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; vs = elementValues;</b>
<b class="nc">&nbsp;      if (vs == null) {</b>
<b class="nc">&nbsp;        vs = delegate.getElementValues();</b>
<b class="nc">&nbsp;        elementValues = vs;</b>
&nbsp;      }
<b class="nc">&nbsp;      return vs;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotationMirror delegate() {
<b class="nc">&nbsp;      return delegate;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return delegate.toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class CachingDeclaredType implements DeclaredType, Caching {
&nbsp;    private final DeclaredType delegate;
&nbsp;    private final TypeKind kind;
&nbsp;    private final Element element;
&nbsp;
<b class="nc">&nbsp;    CachingDeclaredType(DeclaredType delegate) {</b>
<b class="nc">&nbsp;      this.delegate = delegate;</b>
<b class="nc">&nbsp;      this.kind = delegate.getKind();</b>
<b class="nc">&nbsp;      this.element = new CachingTypeElement((TypeElement) delegate.asElement());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public DeclaredType delegate() {
<b class="nc">&nbsp;      return delegate;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Element asElement() {
<b class="nc">&nbsp;      return element;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeKind getKind() {
<b class="nc">&nbsp;      return kind;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
<b class="nc">&nbsp;      return delegate.accept(v, p);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TypeMirror getEnclosingType() {
<b class="nc">&nbsp;      return delegate.getEnclosingType();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;? extends TypeMirror&gt; getTypeArguments() {
<b class="nc">&nbsp;      return delegate.getTypeArguments();</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; type) {
<b class="nc">&nbsp;      return delegate.getAnnotation(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; type) {
<b class="nc">&nbsp;      return delegate.getAnnotationsByType(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors() {
<b class="nc">&nbsp;      return delegate.getAnnotationMirrors();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return delegate.toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
