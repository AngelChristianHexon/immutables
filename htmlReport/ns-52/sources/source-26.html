


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FromSupertypesModel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: FromSupertypesModel (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FromSupertypesModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/91)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FromSupertypesModel$FromSupertype</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/102)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2015 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Functions;
&nbsp;import com.google.common.collect.HashMultimap;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableListMultimap;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Maps;
&nbsp;import com.google.common.collect.Multimaps;
&nbsp;import com.google.common.collect.SetMultimap;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.element.TypeParameterElement;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import javax.lang.model.util.Elements;
&nbsp;import javax.lang.model.util.Types;
&nbsp;
&nbsp;import org.immutables.generator.SourceTypes;
&nbsp;import org.immutables.value.processor.encode.Type;
&nbsp;import org.immutables.value.processor.meta.LongBits.LongPositions;
&nbsp;import org.immutables.value.processor.meta.Reporter.About;
&nbsp;
&nbsp;public final class FromSupertypesModel {
&nbsp;  private final ProcessingEnvironment processing;
<b class="nc">&nbsp;  private static final AtomicBoolean typeParseExceptionReported = new AtomicBoolean();</b>
&nbsp;
&nbsp;  public final ImmutableList&lt;FromSupertypesModel.FromSupertype&gt; supertypes;
&nbsp;  public final ImmutableList&lt;String&gt; repeating;
&nbsp;  public final LongPositions positions;
&nbsp;  private final Reporter reporter;
&nbsp;
&nbsp;  public final static class FromSupertype {
&nbsp;    public final String type;
&nbsp;    public final String wildcard;
&nbsp;    public final boolean hasGenerics;
&nbsp;    public final ImmutableList&lt;ValueAttribute&gt; attributes;
&nbsp;    public final String raw;
&nbsp;
<b class="nc">&nbsp;    FromSupertype(String type, Iterable&lt;ValueAttribute&gt; attribute) {</b>
<b class="nc">&nbsp;      this.type = type;</b>
<b class="nc">&nbsp;      this.hasGenerics = type.indexOf(&#39;&lt;&#39;) &gt; 0;</b>
<b class="nc">&nbsp;      Map.Entry&lt;String, List&lt;String&gt;&gt; withArgs = SourceTypes.extract(type);</b>
<b class="nc">&nbsp;      this.raw = withArgs.getKey();</b>
<b class="nc">&nbsp;      this.wildcard = hasGenerics</b>
<b class="nc">&nbsp;          ? SourceTypes.stringify(Maps.immutableEntry(withArgs.getKey(),</b>
<b class="nc">&nbsp;              Collections.nCopies(withArgs.getValue().size(), &quot;?&quot;)))</b>
<b class="nc">&nbsp;          : type;</b>
<b class="nc">&nbsp;      this.attributes = ImmutableList.copyOf(attribute);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return type + &quot; -&gt; &quot; + attributes;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  FromSupertypesModel(
&nbsp;      Reporter reporter,
&nbsp;      String abstractTypeName,
&nbsp;      Collection&lt;ValueAttribute&gt; attributes,
&nbsp;      ImmutableListMultimap&lt;String, TypeElement&gt; accessorMapping,
&nbsp;      ProcessingEnvironment processing,
&nbsp;      List&lt;TypeElement&gt; extendedClasses,
<b class="nc">&nbsp;      Set&lt;TypeElement&gt; implementedInterfaces) {</b>
&nbsp;
<b class="nc">&nbsp;    this.reporter = reporter;</b>
<b class="nc">&nbsp;    this.processing = processing;</b>
<b class="nc">&nbsp;    SetMultimap&lt;String, String&gt; typesByAttribute = HashMultimap.create();</b>
&nbsp;
<b class="nc">&nbsp;    for (ValueAttribute a : attributes) {</b>
<b class="nc">&nbsp;      String name = a.name();</b>
<b class="nc">&nbsp;      for (TypeElement t : Iterables.concat(implementedInterfaces, extendedClasses)) {</b>
<b class="nc">&nbsp;        if (isEligibleFromType(t, a)) {</b>
<b class="nc">&nbsp;          List&lt;String&gt; typeParamNames = new ArrayList&lt;&gt;(t.getTypeParameters().size());</b>
<b class="nc">&nbsp;          for (TypeParameterElement typeParameterElement : t.getTypeParameters()) {</b>
<b class="nc">&nbsp;            typeParamNames.add(typeParameterElement.toString());</b>
<b class="nc">&nbsp;          }</b>
<b class="nc">&nbsp;          typesByAttribute.put(name, SourceTypes.stringify(Maps.immutableEntry(t.getQualifiedName().toString(), typeParamNames)));</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;          typesByAttribute.put(name, abstractTypeName);</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    SetMultimap&lt;String, String&gt; attributeByType =</b>
<b class="nc">&nbsp;        Multimaps.invertFrom(typesByAttribute, HashMultimap.&lt;String, String&gt;create());</b>
&nbsp;
<b class="nc">&nbsp;    Map&lt;String, ValueAttribute&gt; attributeMap = Maps.newHashMapWithExpectedSize(attributes.size());</b>
&nbsp;
<b class="nc">&nbsp;    for (ValueAttribute a : attributes) {</b>
<b class="nc">&nbsp;      attributeMap.put(a.name(), a);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    Function&lt;String, ValueAttribute&gt; getAttribute = Functions.forMap(attributeMap);</b>
&nbsp;
<b class="nc">&nbsp;    ImmutableList.Builder&lt;FromSupertypesModel.FromSupertype&gt; builder = ImmutableList.builder();</b>
&nbsp;
<b class="nc">&nbsp;    for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; e : attributeByType.asMap().entrySet()) {</b>
<b class="nc">&nbsp;      builder.add(new FromSupertype(e.getKey(), Iterables.transform(e.getValue(), getAttribute)));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // This abstract value type should be always present and be a from target,
&nbsp;    // even if it doesn&#39;t define any specific attributes (just inherits)
<b class="nc">&nbsp;    if (!attributeByType.containsKey(abstractTypeName)) {</b>
<b class="nc">&nbsp;      builder.add(new FromSupertype(abstractTypeName, ImmutableList.&lt;ValueAttribute&gt;of()));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    this.supertypes = builder.build();</b>
&nbsp;
<b class="nc">&nbsp;    ImmutableList.Builder&lt;String&gt; repeatingBuilder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (Map.Entry&lt;String, Collection&lt;String&gt;&gt; e : typesByAttribute.asMap().entrySet()) {</b>
<b class="nc">&nbsp;      if (e.getValue().size() &gt; 1) {</b>
<b class="nc">&nbsp;        repeatingBuilder.add(e.getKey());</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    this.repeating = repeatingBuilder.build();</b>
<b class="nc">&nbsp;    this.positions = new LongBits().apply(repeating);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isDirectAncestor(TypeElement parent, TypeElement child) {
<b class="nc">&nbsp;    Types typeUtils = processing.getTypeUtils();</b>
<b class="nc">&nbsp;    TypeMirror erasedParent = typeUtils.erasure(parent.asType());</b>
&nbsp;
&nbsp;    // check for superclass
<b class="nc">&nbsp;    if (typeUtils.isSameType(erasedParent, typeUtils.erasure(child.getSuperclass()))) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // check interfaces
<b class="nc">&nbsp;    for (TypeMirror interfaceType : child.getInterfaces()) {</b>
<b class="nc">&nbsp;      if (typeUtils.isSameType(erasedParent, typeUtils.erasure(interfaceType))) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean boundsMatch(List&lt;? extends TypeMirror&gt; a, List&lt;? extends TypeMirror&gt; b) {
<b class="nc">&nbsp;    if (a.size() != b.size()) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (int i = 0; i &lt; a.size(); i++) {</b>
<b class="nc">&nbsp;      if (!processing.getTypeUtils().isSameType(a.get(i), b.get(i))) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isEligibleFromType(TypeElement typeElement, ValueAttribute attr) {
<b class="nc">&nbsp;    @Nullable ExecutableElement accessor = findMethod(typeElement, attr.names.get);</b>
<b class="nc">&nbsp;    if (accessor == null) {</b>
&nbsp;      // it can be now as we&#39;ve changed upper loop
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!typeElement.getTypeParameters().isEmpty()) {</b>
<b class="nc">&nbsp;      TypeElement containingTypeElement = (TypeElement) attr.containingType.originalElement();</b>
&nbsp;
&nbsp;      // bail early if types don&#39;t both have 1 parameter
<b class="nc">&nbsp;      if ((typeElement.getTypeParameters().size() != 1) || (containingTypeElement.getTypeParameters().size() != 1)) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
&nbsp;      // ensure this is a direct ancestor
<b class="nc">&nbsp;      if (!isDirectAncestor(typeElement, containingTypeElement)) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
&nbsp;      // confirm bounds match
<b class="nc">&nbsp;      for (int i = 0; i &lt; typeElement.getTypeParameters().size(); i++) {</b>
<b class="nc">&nbsp;        if (!boundsMatch(typeElement.getTypeParameters().get(i).getBounds(), containingTypeElement.getTypeParameters().get(i).getBounds())) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;    try {
<b class="nc">&nbsp;      String ownType = accessor.getReturnType().toString();</b>
<b class="nc">&nbsp;      String inheritedType = attr.returnType.toString();</b>
&nbsp;      // This kind of parsing normalizes and ignores type annotations
<b class="nc">&nbsp;      Type.Producer tf = new Type.Producer();</b>
<b class="nc">&nbsp;      Type.Parser parser = new Type.Parser(tf, tf.parameters());</b>
&nbsp;
<b class="nc">&nbsp;      if (parser.parse(ownType).equals(parser.parse(inheritedType))) {</b>
<b class="nc">&nbsp;        attr.initNullabilitySupertype(accessor);</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    } catch (Exception typeParseException) {</b>
<b class="nc">&nbsp;      if (typeParseExceptionReported.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;        reporter.warning(&quot;Type parsing problem in FromSupertypesModel: %s&quot;, typeParseException);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    reporter.warning(About.FROM,</b>
&nbsp;        &quot;Generated builder &#39;.from&#39; method will not copy from attribute &#39;%s&#39;&quot;
&nbsp;        + &quot; because it has different return type in supertype&quot;
&nbsp;        + &quot; (And we cannot handle generic specialization or covariant overrides yet).&quot;
&nbsp;        + &quot; Sometimes it is possible to avoid this by providing abstract override method in this value object&quot;,
<b class="nc">&nbsp;        attr.name());</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable ExecutableElement findMethod(TypeElement typeElement, String getter) {
<b class="nc">&nbsp;    for (ExecutableElement m : ElementFilter.methodsIn(processing.getElementUtils().getAllMembers(typeElement))) {</b>
<b class="nc">&nbsp;      if (m.getSimpleName().contentEquals(getter) &amp;&amp; m.getParameters().isEmpty()) {</b>
<b class="nc">&nbsp;        return m;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasManySupertypes() {
<b class="nc">&nbsp;    return supertypes.size() &gt; 1;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasWildcards() {
<b class="nc">&nbsp;    for (FromSupertype s : supertypes) {</b>
<b class="nc">&nbsp;      if (s.hasGenerics) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
