


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ImmutableProto</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: ImmutableProto (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
</tr>
  <tr>
    <td class="name">ImmutableProto$1</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringPackage</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringPackage$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringPackage$InitShim</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringType</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringType$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$DeclaringType$InitShim</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$Environment</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$Environment$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$MetaAnnotated</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$MetaAnnotated$InitShim</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$Protoclass</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$Protoclass$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableProto$Protoclass$InitShim</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.MoreObjects;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.errorprone.annotations.CanIgnoreReturnValue;
&nbsp;import com.google.errorprone.annotations.Var;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.CheckReturnValue;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.ParametersAreNonnullByDefault;
&nbsp;import javax.annotation.concurrent.Immutable;
&nbsp;import javax.annotation.concurrent.NotThreadSafe;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.PackageElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import org.immutables.generator.SourceExtraction;
&nbsp;import org.immutables.value.Generated;
&nbsp;import org.immutables.value.processor.encode.EncodingInfo;
&nbsp;import org.immutables.value.processor.encode.Instantiator;
&nbsp;
&nbsp;/**
&nbsp; * {@code ImmutableProto} contains immutable implementation classes generated from
&nbsp; * abstract value types defined as nested inside {@link Proto}.
&nbsp; * @see ImmutableProto.MetaAnnotated
&nbsp; * @see ImmutableProto.Environment
&nbsp; * @see ImmutableProto.DeclaringPackage
&nbsp; * @see ImmutableProto.DeclaringType
&nbsp; * @see ImmutableProto.Protoclass
&nbsp; */
&nbsp;@Generated(from = &quot;Proto&quot;, generator = &quot;Immutables&quot;)
&nbsp;@SuppressWarnings({&quot;all&quot;})
&nbsp;@ParametersAreNonnullByDefault
&nbsp;@javax.annotation.processing.Generated(&quot;org.immutables.processor.ProxyProcessor&quot;)
&nbsp;public final class ImmutableProto {
&nbsp;  private ImmutableProto() {}
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Proto.MetaAnnotated}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableProto.MetaAnnotated.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Proto.MetaAnnotated&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class MetaAnnotated extends Proto.MetaAnnotated {
&nbsp;    private final Element element;
&nbsp;    private final String qualifiedName;
&nbsp;    private final Proto.Environment environment;
&nbsp;    private transient final Set&lt;EncodingInfo&gt; encodings;
&nbsp;    private transient final Optional&lt;DataMirror&gt; datatypeEnabled;
&nbsp;    private transient final Optional&lt;StyleInfo&gt; style;
&nbsp;    private transient final Optional&lt;String[]&gt; depluralize;
&nbsp;    private transient final Optional&lt;Long&gt; serialVersion;
&nbsp;    private transient final boolean isSerialStructural;
&nbsp;    private transient final boolean isJacksonSerialized;
&nbsp;    private transient final boolean isJacksonDeserialized;
&nbsp;    private transient final boolean isJacksonJsonTypeInfo;
&nbsp;    private transient final boolean isJsonQualifier;
&nbsp;    private transient final boolean isEnclosing;
&nbsp;    private transient final ImmutableList&lt;AnnotationInjections.InjectionInfo&gt; injectAnnotation;
&nbsp;
&nbsp;    private MetaAnnotated(
&nbsp;        Element element,
&nbsp;        String qualifiedName,
&nbsp;        Proto.Environment environment) {
&nbsp;      this.element = Objects.requireNonNull(element, &quot;element&quot;);
&nbsp;      this.qualifiedName = Objects.requireNonNull(qualifiedName, &quot;qualifiedName&quot;);
&nbsp;      this.environment = Objects.requireNonNull(environment, &quot;environment&quot;);
&nbsp;      this.encodings = initShim.encodings();
&nbsp;      this.datatypeEnabled = initShim.datatypeEnabled();
&nbsp;      this.style = initShim.style();
&nbsp;      this.depluralize = initShim.depluralize();
&nbsp;      this.serialVersion = initShim.serialVersion();
&nbsp;      this.isSerialStructural = initShim.isSerialStructural();
&nbsp;      this.isJacksonSerialized = initShim.isJacksonSerialized();
&nbsp;      this.isJacksonDeserialized = initShim.isJacksonDeserialized();
&nbsp;      this.isJacksonJsonTypeInfo = initShim.isJacksonJsonTypeInfo();
&nbsp;      this.isJsonQualifier = initShim.isJsonQualifier();
&nbsp;      this.isEnclosing = initShim.isEnclosing();
&nbsp;      this.injectAnnotation = initShim.injectAnnotation();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private MetaAnnotated(
&nbsp;        ImmutableProto.MetaAnnotated original,
&nbsp;        Element element,
&nbsp;        String qualifiedName,
&nbsp;        Proto.Environment environment) {
&nbsp;      this.element = element;
&nbsp;      this.qualifiedName = qualifiedName;
&nbsp;      this.environment = environment;
&nbsp;      this.encodings = initShim.encodings();
&nbsp;      this.datatypeEnabled = initShim.datatypeEnabled();
&nbsp;      this.style = initShim.style();
&nbsp;      this.depluralize = initShim.depluralize();
&nbsp;      this.serialVersion = initShim.serialVersion();
&nbsp;      this.isSerialStructural = initShim.isSerialStructural();
&nbsp;      this.isJacksonSerialized = initShim.isJacksonSerialized();
&nbsp;      this.isJacksonDeserialized = initShim.isJacksonDeserialized();
&nbsp;      this.isJacksonJsonTypeInfo = initShim.isJacksonJsonTypeInfo();
&nbsp;      this.isJsonQualifier = initShim.isJsonQualifier();
&nbsp;      this.isEnclosing = initShim.isEnclosing();
&nbsp;      this.injectAnnotation = initShim.injectAnnotation();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private static final byte STAGE_INITIALIZING = -1;
&nbsp;    private static final byte STAGE_UNINITIALIZED = 0;
&nbsp;    private static final byte STAGE_INITIALIZED = 1;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile InitShim initShim = new InitShim();
&nbsp;
&nbsp;    @Generated(from = &quot;Proto.MetaAnnotated&quot;, generator = &quot;Immutables&quot;)
&nbsp;    private final class InitShim {
&nbsp;      private byte encodingsBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Set&lt;EncodingInfo&gt; encodings;
&nbsp;
&nbsp;      Set&lt;EncodingInfo&gt; encodings() {
&nbsp;        if (encodingsBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (encodingsBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          encodingsBuildStage = STAGE_INITIALIZING;
&nbsp;          this.encodings = Objects.requireNonNull(MetaAnnotated.super.encodings(), &quot;encodings&quot;);
&nbsp;          encodingsBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.encodings;
&nbsp;      }
&nbsp;
&nbsp;      private byte datatypeEnabledBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Optional&lt;DataMirror&gt; datatypeEnabled;
&nbsp;
&nbsp;      Optional&lt;DataMirror&gt; datatypeEnabled() {
&nbsp;        if (datatypeEnabledBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (datatypeEnabledBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          datatypeEnabledBuildStage = STAGE_INITIALIZING;
&nbsp;          this.datatypeEnabled = Objects.requireNonNull(MetaAnnotated.super.datatypeEnabled(), &quot;datatypeEnabled&quot;);
&nbsp;          datatypeEnabledBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.datatypeEnabled;
&nbsp;      }
&nbsp;
&nbsp;      private byte styleBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Optional&lt;StyleInfo&gt; style;
&nbsp;
&nbsp;      Optional&lt;StyleInfo&gt; style() {
&nbsp;        if (styleBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (styleBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          styleBuildStage = STAGE_INITIALIZING;
&nbsp;          this.style = Objects.requireNonNull(MetaAnnotated.super.style(), &quot;style&quot;);
&nbsp;          styleBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.style;
&nbsp;      }
&nbsp;
&nbsp;      private byte depluralizeBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Optional&lt;String[]&gt; depluralize;
&nbsp;
&nbsp;      Optional&lt;String[]&gt; depluralize() {
&nbsp;        if (depluralizeBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (depluralizeBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          depluralizeBuildStage = STAGE_INITIALIZING;
&nbsp;          this.depluralize = Objects.requireNonNull(MetaAnnotated.super.depluralize(), &quot;depluralize&quot;);
&nbsp;          depluralizeBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.depluralize;
&nbsp;      }
&nbsp;
&nbsp;      private byte serialVersionBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Optional&lt;Long&gt; serialVersion;
&nbsp;
&nbsp;      Optional&lt;Long&gt; serialVersion() {
&nbsp;        if (serialVersionBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (serialVersionBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          serialVersionBuildStage = STAGE_INITIALIZING;
&nbsp;          this.serialVersion = Objects.requireNonNull(MetaAnnotated.super.serialVersion(), &quot;serialVersion&quot;);
&nbsp;          serialVersionBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.serialVersion;
&nbsp;      }
&nbsp;
&nbsp;      private byte isSerialStructuralBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isSerialStructural;
&nbsp;
&nbsp;      boolean isSerialStructural() {
&nbsp;        if (isSerialStructuralBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isSerialStructuralBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isSerialStructuralBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isSerialStructural = MetaAnnotated.super.isSerialStructural();
&nbsp;          isSerialStructuralBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isSerialStructural;
&nbsp;      }
&nbsp;
&nbsp;      private byte isJacksonSerializedBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isJacksonSerialized;
&nbsp;
&nbsp;      boolean isJacksonSerialized() {
&nbsp;        if (isJacksonSerializedBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isJacksonSerializedBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isJacksonSerializedBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isJacksonSerialized = MetaAnnotated.super.isJacksonSerialized();
&nbsp;          isJacksonSerializedBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isJacksonSerialized;
&nbsp;      }
&nbsp;
&nbsp;      private byte isJacksonDeserializedBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isJacksonDeserialized;
&nbsp;
&nbsp;      boolean isJacksonDeserialized() {
&nbsp;        if (isJacksonDeserializedBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isJacksonDeserializedBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isJacksonDeserializedBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isJacksonDeserialized = MetaAnnotated.super.isJacksonDeserialized();
&nbsp;          isJacksonDeserializedBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isJacksonDeserialized;
&nbsp;      }
&nbsp;
&nbsp;      private byte isJacksonJsonTypeInfoBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isJacksonJsonTypeInfo;
&nbsp;
&nbsp;      boolean isJacksonJsonTypeInfo() {
&nbsp;        if (isJacksonJsonTypeInfoBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isJacksonJsonTypeInfoBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isJacksonJsonTypeInfoBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isJacksonJsonTypeInfo = MetaAnnotated.super.isJacksonJsonTypeInfo();
&nbsp;          isJacksonJsonTypeInfoBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isJacksonJsonTypeInfo;
&nbsp;      }
&nbsp;
&nbsp;      private byte isJsonQualifierBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isJsonQualifier;
&nbsp;
&nbsp;      boolean isJsonQualifier() {
&nbsp;        if (isJsonQualifierBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isJsonQualifierBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isJsonQualifierBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isJsonQualifier = MetaAnnotated.super.isJsonQualifier();
&nbsp;          isJsonQualifierBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isJsonQualifier;
&nbsp;      }
&nbsp;
&nbsp;      private byte isEnclosingBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isEnclosing;
&nbsp;
&nbsp;      boolean isEnclosing() {
&nbsp;        if (isEnclosingBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isEnclosingBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isEnclosingBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isEnclosing = MetaAnnotated.super.isEnclosing();
&nbsp;          isEnclosingBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isEnclosing;
&nbsp;      }
&nbsp;
&nbsp;      private byte injectAnnotationBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private ImmutableList&lt;AnnotationInjections.InjectionInfo&gt; injectAnnotation;
&nbsp;
&nbsp;      ImmutableList&lt;AnnotationInjections.InjectionInfo&gt; injectAnnotation() {
&nbsp;        if (injectAnnotationBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (injectAnnotationBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          injectAnnotationBuildStage = STAGE_INITIALIZING;
&nbsp;          this.injectAnnotation = Objects.requireNonNull(MetaAnnotated.super.injectAnnotation(), &quot;injectAnnotation&quot;);
&nbsp;          injectAnnotationBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.injectAnnotation;
&nbsp;      }
&nbsp;
&nbsp;      private String formatInitCycleMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (encodingsBuildStage == STAGE_INITIALIZING) attributes.add(&quot;encodings&quot;);
&nbsp;        if (datatypeEnabledBuildStage == STAGE_INITIALIZING) attributes.add(&quot;datatypeEnabled&quot;);
&nbsp;        if (styleBuildStage == STAGE_INITIALIZING) attributes.add(&quot;style&quot;);
&nbsp;        if (depluralizeBuildStage == STAGE_INITIALIZING) attributes.add(&quot;depluralize&quot;);
&nbsp;        if (serialVersionBuildStage == STAGE_INITIALIZING) attributes.add(&quot;serialVersion&quot;);
&nbsp;        if (isSerialStructuralBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isSerialStructural&quot;);
&nbsp;        if (isJacksonSerializedBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isJacksonSerialized&quot;);
&nbsp;        if (isJacksonDeserializedBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isJacksonDeserialized&quot;);
&nbsp;        if (isJacksonJsonTypeInfoBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isJacksonJsonTypeInfo&quot;);
&nbsp;        if (isJsonQualifierBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isJsonQualifier&quot;);
&nbsp;        if (isEnclosingBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isEnclosing&quot;);
&nbsp;        if (injectAnnotationBuildStage == STAGE_INITIALIZING) attributes.add(&quot;injectAnnotation&quot;);
&nbsp;        return &quot;Cannot build MetaAnnotated, attribute initializers form cycle &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code element} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Element element() {
&nbsp;      return element;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code qualifiedName} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String qualifiedName() {
&nbsp;      return qualifiedName;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code environment} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.Environment environment() {
&nbsp;      return environment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code encodings} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Set&lt;EncodingInfo&gt; encodings() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.encodings()
&nbsp;          : this.encodings;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code datatypeEnabled} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.datatypeEnabled()
&nbsp;          : this.datatypeEnabled;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code style} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.style()
&nbsp;          : this.style;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code depluralize} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.depluralize()
&nbsp;          : this.depluralize;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code serialVersion} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.serialVersion()
&nbsp;          : this.serialVersion;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isSerialStructural} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isSerialStructural() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isSerialStructural()
&nbsp;          : this.isSerialStructural;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isJacksonSerialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonSerialized() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isJacksonSerialized()
&nbsp;          : this.isJacksonSerialized;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isJacksonDeserialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserialized() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isJacksonDeserialized()
&nbsp;          : this.isJacksonDeserialized;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isJacksonJsonTypeInfo} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonJsonTypeInfo() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isJacksonJsonTypeInfo()
&nbsp;          : this.isJacksonJsonTypeInfo;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isJsonQualifier} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJsonQualifier() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isJsonQualifier()
&nbsp;          : this.isJsonQualifier;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code isEnclosing} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isEnclosing() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isEnclosing()
&nbsp;          : this.isEnclosing;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code injectAnnotation} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;AnnotationInjections.InjectionInfo&gt; injectAnnotation() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.injectAnnotation()
&nbsp;          : this.injectAnnotation;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.MetaAnnotated#element() element} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for element
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.MetaAnnotated withElement(Element value) {
&nbsp;      if (this.element == value) return this;
&nbsp;      Element newValue = Objects.requireNonNull(value, &quot;element&quot;);
&nbsp;      return new ImmutableProto.MetaAnnotated(this, newValue, this.qualifiedName, this.environment);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.MetaAnnotated#qualifiedName() qualifiedName} attribute.
&nbsp;     * An equals check used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for qualifiedName
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.MetaAnnotated withQualifiedName(String value) {
&nbsp;      String newValue = Objects.requireNonNull(value, &quot;qualifiedName&quot;);
&nbsp;      if (this.qualifiedName.equals(newValue)) return this;
&nbsp;      return new ImmutableProto.MetaAnnotated(this, this.element, newValue, this.environment);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.MetaAnnotated#environment() environment} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for environment
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.MetaAnnotated withEnvironment(Proto.Environment value) {
&nbsp;      if (this.environment == value) return this;
&nbsp;      Proto.Environment newValue = Objects.requireNonNull(value, &quot;environment&quot;);
&nbsp;      return new ImmutableProto.MetaAnnotated(this, this.element, this.qualifiedName, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code MetaAnnotated} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableProto.MetaAnnotated
&nbsp;          &amp;&amp; equalTo((ImmutableProto.MetaAnnotated) another);
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;MethodCanBeStatic&quot;)
&nbsp;    private boolean equalTo(ImmutableProto.MetaAnnotated another) {
&nbsp;      return true;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 2091445391;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code MetaAnnotated}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;MetaAnnotated{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code MetaAnnotated} instance.
&nbsp;     * @param element The value for the {@code element} attribute
&nbsp;     * @param qualifiedName The value for the {@code qualifiedName} attribute
&nbsp;     * @param environment The value for the {@code environment} attribute
&nbsp;     * @return An immutable MetaAnnotated instance
&nbsp;     */
&nbsp;    public static ImmutableProto.MetaAnnotated of(Element element, String qualifiedName, Proto.Environment environment) {
&nbsp;      return new ImmutableProto.MetaAnnotated(element, qualifiedName, environment);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Proto.MetaAnnotated} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable MetaAnnotated instance
&nbsp;     */
&nbsp;    public static ImmutableProto.MetaAnnotated copyOf(Proto.MetaAnnotated instance) {
&nbsp;      if (instance instanceof ImmutableProto.MetaAnnotated) {
&nbsp;        return (ImmutableProto.MetaAnnotated) instance;
&nbsp;      }
&nbsp;      return ImmutableProto.MetaAnnotated.of(instance.element(), instance.qualifiedName(), instance.environment());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Proto.Environment}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableProto.Environment.builder()}.
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableProto.Environment.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Proto.Environment&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Environment extends Proto.Environment {
&nbsp;    private final ProcessingEnvironment processing;
&nbsp;    private final Round round;
&nbsp;    private transient final StyleInfo defaultStyles;
&nbsp;
&nbsp;    private Environment(
&nbsp;        ProcessingEnvironment processing,
&nbsp;        Round round) {
&nbsp;      this.processing = Objects.requireNonNull(processing, &quot;processing&quot;);
&nbsp;      this.round = Objects.requireNonNull(round, &quot;round&quot;);
&nbsp;      this.defaultStyles = Objects.requireNonNull(super.defaultStyles(), &quot;defaultStyles&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private Environment(
&nbsp;        ImmutableProto.Environment original,
&nbsp;        ProcessingEnvironment processing,
&nbsp;        Round round) {
&nbsp;      this.processing = processing;
&nbsp;      this.round = round;
&nbsp;      this.defaultStyles = Objects.requireNonNull(super.defaultStyles(), &quot;defaultStyles&quot;);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code processing} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    ProcessingEnvironment processing() {
&nbsp;      return processing;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code round} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    Round round() {
&nbsp;      return round;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code defaultStyles} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    StyleInfo defaultStyles() {
&nbsp;      return defaultStyles;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Environment#processing() processing} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for processing
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Environment withProcessing(ProcessingEnvironment value) {
&nbsp;      if (this.processing == value) return this;
&nbsp;      ProcessingEnvironment newValue = Objects.requireNonNull(value, &quot;processing&quot;);
&nbsp;      return new ImmutableProto.Environment(this, newValue, this.round);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Environment#round() round} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for round
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Environment withRound(Round value) {
&nbsp;      if (this.round == value) return this;
&nbsp;      Round newValue = Objects.requireNonNull(value, &quot;round&quot;);
&nbsp;      return new ImmutableProto.Environment(this, this.processing, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Environment} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableProto.Environment
&nbsp;          &amp;&amp; equalTo((ImmutableProto.Environment) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableProto.Environment another) {
&nbsp;      return processing.equals(another.processing)
&nbsp;          &amp;&amp; round.equals(another.round)
&nbsp;          &amp;&amp; defaultStyles.equals(another.defaultStyles);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code processing}, {@code round}, {@code defaultStyles}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + processing.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + round.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + defaultStyles.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Environment} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Environment&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;processing&quot;, processing)
&nbsp;          .add(&quot;round&quot;, round)
&nbsp;          .add(&quot;defaultStyles&quot;, defaultStyles)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile long lazyInitBitmap;
&nbsp;
&nbsp;    private static final long TYPE_MORE_OBJECTS_LAZY_INIT_BIT = 0x1L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient String typeMoreObjects;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#typeMoreObjects() typeMoreObjects} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code typeMoreObjects} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    String typeMoreObjects() {
&nbsp;      if ((lazyInitBitmap &amp; TYPE_MORE_OBJECTS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TYPE_MORE_OBJECTS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.typeMoreObjects = super.typeMoreObjects();
&nbsp;            lazyInitBitmap |= TYPE_MORE_OBJECTS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return typeMoreObjects;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_OK_JSON_LIB_LAZY_INIT_BIT = 0x2L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasOkJsonLib;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasOkJsonLib() hasOkJsonLib} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasOkJsonLib} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasOkJsonLib() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_OK_JSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_OK_JSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasOkJsonLib = super.hasOkJsonLib();
&nbsp;            lazyInitBitmap |= HAS_OK_JSON_LIB_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasOkJsonLib;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_GSON_LIB_LAZY_INIT_BIT = 0x4L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasGsonLib;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasGsonLib() hasGsonLib} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasGsonLib} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasGsonLib() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_GSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_GSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasGsonLib = super.hasGsonLib();
&nbsp;            lazyInitBitmap |= HAS_GSON_LIB_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasGsonLib;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_DATATYPES_MODULE_LAZY_INIT_BIT = 0x8L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasDatatypesModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasDatatypesModule() hasDatatypesModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasDatatypesModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasDatatypesModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_DATATYPES_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_DATATYPES_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasDatatypesModule = super.hasDatatypesModule();
&nbsp;            lazyInitBitmap |= HAS_DATATYPES_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasDatatypesModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_JACKSON_LIB_LAZY_INIT_BIT = 0x10L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasJacksonLib;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasJacksonLib() hasJacksonLib} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasJacksonLib} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasJacksonLib() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_JACKSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_JACKSON_LIB_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasJacksonLib = super.hasJacksonLib();
&nbsp;            lazyInitBitmap |= HAS_JACKSON_LIB_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasJacksonLib;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_CRITERIA_MODULE_LAZY_INIT_BIT = 0x20L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasCriteriaModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasCriteriaModule() hasCriteriaModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasCriteriaModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasCriteriaModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_CRITERIA_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_CRITERIA_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasCriteriaModule = super.hasCriteriaModule();
&nbsp;            lazyInitBitmap |= HAS_CRITERIA_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasCriteriaModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_MONGO_MODULE_LAZY_INIT_BIT = 0x40L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasMongoModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasMongoModule() hasMongoModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasMongoModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasMongoModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_MONGO_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_MONGO_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasMongoModule = super.hasMongoModule();
&nbsp;            lazyInitBitmap |= HAS_MONGO_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasMongoModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_SERIAL_MODULE_LAZY_INIT_BIT = 0x80L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasSerialModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasSerialModule() hasSerialModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasSerialModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasSerialModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_SERIAL_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_SERIAL_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasSerialModule = super.hasSerialModule();
&nbsp;            lazyInitBitmap |= HAS_SERIAL_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasSerialModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_TREES_MODULE_LAZY_INIT_BIT = 0x100L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasTreesModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasTreesModule() hasTreesModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasTreesModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasTreesModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_TREES_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_TREES_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasTreesModule = super.hasTreesModule();
&nbsp;            lazyInitBitmap |= HAS_TREES_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasTreesModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_AST_MODULE_LAZY_INIT_BIT = 0x200L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasAstModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasAstModule() hasAstModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasAstModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasAstModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_AST_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_AST_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasAstModule = super.hasAstModule();
&nbsp;            lazyInitBitmap |= HAS_AST_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasAstModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_ORDINAL_MODULE_LAZY_INIT_BIT = 0x400L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasOrdinalModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasOrdinalModule() hasOrdinalModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasOrdinalModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasOrdinalModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_ORDINAL_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_ORDINAL_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasOrdinalModule = super.hasOrdinalModule();
&nbsp;            lazyInitBitmap |= HAS_ORDINAL_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasOrdinalModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_BUILDER_MODULE_LAZY_INIT_BIT = 0x800L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasBuilderModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasBuilderModule() hasBuilderModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasBuilderModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasBuilderModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_BUILDER_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_BUILDER_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasBuilderModule = super.hasBuilderModule();
&nbsp;            lazyInitBitmap |= HAS_BUILDER_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasBuilderModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_FUNC_MODULE_LAZY_INIT_BIT = 0x1000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasFuncModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasFuncModule() hasFuncModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasFuncModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasFuncModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_FUNC_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_FUNC_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasFuncModule = super.hasFuncModule();
&nbsp;            lazyInitBitmap |= HAS_FUNC_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasFuncModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_ENCODE_MODULE_LAZY_INIT_BIT = 0x2000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasEncodeModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasEncodeModule() hasEncodeModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasEncodeModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasEncodeModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_ENCODE_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_ENCODE_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasEncodeModule = super.hasEncodeModule();
&nbsp;            lazyInitBitmap |= HAS_ENCODE_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasEncodeModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_ANNOTATE_MODULE_LAZY_INIT_BIT = 0x4000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasAnnotateModule;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasAnnotateModule() hasAnnotateModule} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasAnnotateModule} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasAnnotateModule() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_ANNOTATE_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_ANNOTATE_MODULE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasAnnotateModule = super.hasAnnotateModule();
&nbsp;            lazyInitBitmap |= HAS_ANNOTATE_MODULE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasAnnotateModule;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HAS_JAVA9_COLLECTIONS_LAZY_INIT_BIT = 0x8000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean hasJava9Collections;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#hasJava9Collections() hasJava9Collections} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code hasJava9Collections} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasJava9Collections() {
&nbsp;      if ((lazyInitBitmap &amp; HAS_JAVA9_COLLECTIONS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HAS_JAVA9_COLLECTIONS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.hasJava9Collections = super.hasJava9Collections();
&nbsp;            lazyInitBitmap |= HAS_JAVA9_COLLECTIONS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return hasJava9Collections;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DEFAULT_TYPE_ADAPTERS_LAZY_INIT_BIT = 0x10000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient TypeAdaptersMirror defaultTypeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#defaultTypeAdapters() defaultTypeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code defaultTypeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    TypeAdaptersMirror defaultTypeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; DEFAULT_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DEFAULT_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.defaultTypeAdapters = Objects.requireNonNull(super.defaultTypeAdapters(), &quot;defaultTypeAdapters&quot;);
&nbsp;            lazyInitBitmap |= DEFAULT_TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return defaultTypeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long CHECKED_EXCEPTION_PROBE_LAZY_INIT_BIT = 0x20000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient CheckedExceptionProbe checkedExceptionProbe;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Environment#checkedExceptionProbe() checkedExceptionProbe} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code checkedExceptionProbe} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    CheckedExceptionProbe checkedExceptionProbe() {
&nbsp;      if ((lazyInitBitmap &amp; CHECKED_EXCEPTION_PROBE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CHECKED_EXCEPTION_PROBE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.checkedExceptionProbe = Objects.requireNonNull(super.checkedExceptionProbe(), &quot;checkedExceptionProbe&quot;);
&nbsp;            lazyInitBitmap |= CHECKED_EXCEPTION_PROBE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return checkedExceptionProbe;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code Environment} instance.
&nbsp;     * @param processing The value for the {@code processing} attribute
&nbsp;     * @param round The value for the {@code round} attribute
&nbsp;     * @return An immutable Environment instance
&nbsp;     */
&nbsp;    public static ImmutableProto.Environment of(ProcessingEnvironment processing, Round round) {
&nbsp;      return new ImmutableProto.Environment(processing, round);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Proto.Environment} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Environment instance
&nbsp;     */
&nbsp;    public static ImmutableProto.Environment copyOf(Proto.Environment instance) {
&nbsp;      if (instance instanceof ImmutableProto.Environment) {
&nbsp;        return (ImmutableProto.Environment) instance;
&nbsp;      }
&nbsp;      return ImmutableProto.Environment.builder()
&nbsp;          .processing(instance.processing())
&nbsp;          .round(instance.round())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableProto.Environment Environment}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableProto.Environment.builder()
&nbsp;     *    .processing(javax.annotation.processing.ProcessingEnvironment) // required {@link Proto.Environment#processing() processing}
&nbsp;     *    .round(org.immutables.value.processor.meta.Round) // required {@link Proto.Environment#round() round}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Environment builder
&nbsp;     */
&nbsp;    public static ImmutableProto.Environment.Builder builder() {
&nbsp;      return new ImmutableProto.Environment.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableProto.Environment Environment}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Proto.Environment&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_PROCESSING = 0x1L;
&nbsp;      private static final long INIT_BIT_ROUND = 0x2L;
&nbsp;      private long initBits = 0x3L;
&nbsp;
&nbsp;      private @Nullable ProcessingEnvironment processing;
&nbsp;      private @Nullable Round round;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Environment#processing() processing} attribute.
&nbsp;       * @param processing The value for processing 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder processing(ProcessingEnvironment processing) {
&nbsp;        checkNotIsSet(processingIsSet(), &quot;processing&quot;);
&nbsp;        this.processing = Objects.requireNonNull(processing, &quot;processing&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_PROCESSING;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Environment#round() round} attribute.
&nbsp;       * @param round The value for round 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder round(Round round) {
&nbsp;        checkNotIsSet(roundIsSet(), &quot;round&quot;);
&nbsp;        this.round = Objects.requireNonNull(round, &quot;round&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ROUND;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableProto.Environment Environment}.
&nbsp;       * @return An immutable instance of Environment
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableProto.Environment build() {
&nbsp;        checkRequiredAttributes();
&nbsp;        return new ImmutableProto.Environment(null, processing, round);
&nbsp;      }
&nbsp;
&nbsp;      private boolean processingIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_PROCESSING) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean roundIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ROUND) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private static void checkNotIsSet(boolean isSet, String name) {
&nbsp;        if (isSet) throw new IllegalStateException(&quot;Builder of Environment is strict, attribute is already set: &quot;.concat(name));
&nbsp;      }
&nbsp;
&nbsp;      private void checkRequiredAttributes() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (!processingIsSet()) attributes.add(&quot;processing&quot;);
&nbsp;        if (!roundIsSet()) attributes.add(&quot;round&quot;);
&nbsp;        return &quot;Cannot build Environment, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Proto.DeclaringPackage}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableProto.DeclaringPackage.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Proto.DeclaringPackage&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class DeclaringPackage extends Proto.DeclaringPackage {
&nbsp;    private final Proto.Environment environment;
&nbsp;    private final Proto.Interning interner;
&nbsp;    private final PackageElement element;
&nbsp;    private transient final String simpleName;
&nbsp;    private transient final String name;
&nbsp;
&nbsp;    private DeclaringPackage(
&nbsp;        Proto.Environment environment,
&nbsp;        Proto.Interning interner,
&nbsp;        PackageElement element) {
&nbsp;      this.environment = environment;
&nbsp;      this.interner = interner;
&nbsp;      this.element = element;
&nbsp;      this.simpleName = initShim.simpleName();
&nbsp;      this.name = initShim.name();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private static final byte STAGE_INITIALIZING = -1;
&nbsp;    private static final byte STAGE_UNINITIALIZED = 0;
&nbsp;    private static final byte STAGE_INITIALIZED = 1;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile InitShim initShim = new InitShim();
&nbsp;
&nbsp;    @Generated(from = &quot;Proto.DeclaringPackage&quot;, generator = &quot;Immutables&quot;)
&nbsp;    private final class InitShim {
&nbsp;      private byte simpleNameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String simpleName;
&nbsp;
&nbsp;      String simpleName() {
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (simpleNameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.simpleName = Objects.requireNonNull(DeclaringPackage.super.simpleName(), &quot;simpleName&quot;);
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.simpleName;
&nbsp;      }
&nbsp;
&nbsp;      private byte nameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String name;
&nbsp;
&nbsp;      String name() {
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (nameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          nameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.name = Objects.requireNonNull(DeclaringPackage.super.name(), &quot;name&quot;);
&nbsp;          nameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.name;
&nbsp;      }
&nbsp;
&nbsp;      private String formatInitCycleMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;simpleName&quot;);
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;name&quot;);
&nbsp;        return &quot;Cannot build DeclaringPackage, attribute initializers form cycle &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code environment} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    Proto.Environment environment() {
&nbsp;      return environment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * used to intern packaged created internally
&nbsp;     */
&nbsp;    @Override
&nbsp;    Proto.Interning interner() {
&nbsp;      return interner;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code element} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public PackageElement element() {
&nbsp;      return element;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code simpleName} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String simpleName() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.simpleName()
&nbsp;          : this.simpleName;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Name is the only equivalence attribute. Basically packages are interned by name.
&nbsp;     * @return package name
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String name() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.name()
&nbsp;          : this.name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringPackage#environment() environment} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for environment
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringPackage withEnvironment(Proto.Environment value) {
&nbsp;      if (this.environment == value) return this;
&nbsp;      Proto.Environment newValue = Objects.requireNonNull(value, &quot;environment&quot;);
&nbsp;      return new ImmutableProto.DeclaringPackage(newValue, this.interner, this.element);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringPackage#interner() interner} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for interner
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringPackage withInterner(Proto.Interning value) {
&nbsp;      if (this.interner == value) return this;
&nbsp;      Proto.Interning newValue = Objects.requireNonNull(value, &quot;interner&quot;);
&nbsp;      return new ImmutableProto.DeclaringPackage(this.environment, newValue, this.element);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringPackage#element() element} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for element
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringPackage withElement(PackageElement value) {
&nbsp;      if (this.element == value) return this;
&nbsp;      PackageElement newValue = Objects.requireNonNull(value, &quot;element&quot;);
&nbsp;      return new ImmutableProto.DeclaringPackage(this.environment, this.interner, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code DeclaringPackage} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableProto.DeclaringPackage
&nbsp;          &amp;&amp; equalTo((ImmutableProto.DeclaringPackage) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableProto.DeclaringPackage another) {
&nbsp;      return name.equals(another.name);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code DeclaringPackage} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;DeclaringPackage&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile long lazyInitBitmap;
&nbsp;
&nbsp;    private static final long INCLUDE_LAZY_INIT_BIT = 0x1L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;IncludeMirror&gt; include;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#include() include} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code include} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected Optional&lt;IncludeMirror&gt; include() {
&nbsp;      if ((lazyInitBitmap &amp; INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.include = Objects.requireNonNull(super.include(), &quot;include&quot;);
&nbsp;            lazyInitBitmap |= INCLUDE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return include;
&nbsp;    }
&nbsp;
&nbsp;    private static final long BUILDER_INCLUDE_LAZY_INIT_BIT = 0x2L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;FIncludeMirror&gt; builderInclude;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#builderInclude() builderInclude} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code builderInclude} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected Optional&lt;FIncludeMirror&gt; builderInclude() {
&nbsp;      if ((lazyInitBitmap &amp; BUILDER_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; BUILDER_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.builderInclude = Objects.requireNonNull(super.builderInclude(), &quot;builderInclude&quot;);
&nbsp;            lazyInitBitmap |= BUILDER_INCLUDE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return builderInclude;
&nbsp;    }
&nbsp;
&nbsp;    private static final long TYPE_ADAPTERS_LAZY_INIT_BIT = 0x4L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;TypeAdaptersMirror&gt; typeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#typeAdapters() typeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code typeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;TypeAdaptersMirror&gt; typeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.typeAdapters = Objects.requireNonNull(super.typeAdapters(), &quot;typeAdapters&quot;);
&nbsp;            lazyInitBitmap |= TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return typeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long OK_TYPE_ADAPTERS_LAZY_INIT_BIT = 0x8L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;OkTypeAdaptersMirror&gt; okTypeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#okTypeAdapters() okTypeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code okTypeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;OkTypeAdaptersMirror&gt; okTypeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.okTypeAdapters = Objects.requireNonNull(super.okTypeAdapters(), &quot;okTypeAdapters&quot;);
&nbsp;            lazyInitBitmap |= OK_TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return okTypeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long INCLUDED_TYPES_LAZY_INIT_BIT = 0x10L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;TypeElement&gt; includedTypes;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#includedTypes() includedTypes} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code includedTypes} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;TypeElement&gt; includedTypes() {
&nbsp;      if ((lazyInitBitmap &amp; INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.includedTypes = Objects.requireNonNull(super.includedTypes(), &quot;includedTypes&quot;);
&nbsp;            lazyInitBitmap |= INCLUDED_TYPES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return includedTypes;
&nbsp;    }
&nbsp;
&nbsp;    private static final long BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT = 0x20L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;TypeElement&gt; builderIncludedTypes;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#builderIncludedTypes() builderIncludedTypes} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code builderIncludedTypes} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;TypeElement&gt; builderIncludedTypes() {
&nbsp;      if ((lazyInitBitmap &amp; BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.builderIncludedTypes = Objects.requireNonNull(super.builderIncludedTypes(), &quot;builderIncludedTypes&quot;);
&nbsp;            lazyInitBitmap |= BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return builderIncludedTypes;
&nbsp;    }
&nbsp;
&nbsp;    private static final long META_ANNOTATED_LAZY_INIT_BIT = 0x40L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;Proto.MetaAnnotated&gt; metaAnnotated;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#metaAnnotated() metaAnnotated} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code metaAnnotated} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;Proto.MetaAnnotated&gt; metaAnnotated() {
&nbsp;      if ((lazyInitBitmap &amp; META_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; META_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.metaAnnotated = Objects.requireNonNull(super.metaAnnotated(), &quot;metaAnnotated&quot;);
&nbsp;            lazyInitBitmap |= META_ANNOTATED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return metaAnnotated;
&nbsp;    }
&nbsp;
&nbsp;    private static final long JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT = 0x80L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Proto.JacksonMode jacksonSerializeMode;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#jacksonSerializeMode() jacksonSerializeMode} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code jacksonSerializeMode} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.JacksonMode jacksonSerializeMode() {
&nbsp;      if ((lazyInitBitmap &amp; JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.jacksonSerializeMode = Objects.requireNonNull(super.jacksonSerializeMode(), &quot;jacksonSerializeMode&quot;);
&nbsp;            lazyInitBitmap |= JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return jacksonSerializeMode;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT = 0x100L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonDeserializedAnnotated;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#isJacksonDeserializedAnnotated() isJacksonDeserializedAnnotated} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonDeserializedAnnotated} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserializedAnnotated() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonDeserializedAnnotated = super.isJacksonDeserializedAnnotated();
&nbsp;            lazyInitBitmap |= IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonDeserializedAnnotated;
&nbsp;    }
&nbsp;
&nbsp;    private static final long NAMED_PARENT_PACKAGE_LAZY_INIT_BIT = 0x200L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.DeclaringPackage&gt; namedParentPackage;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#namedParentPackage() namedParentPackage} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code namedParentPackage} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    Optional&lt;Proto.DeclaringPackage&gt; namedParentPackage() {
&nbsp;      if ((lazyInitBitmap &amp; NAMED_PARENT_PACKAGE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; NAMED_PARENT_PACKAGE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.namedParentPackage = Objects.requireNonNull(super.namedParentPackage(), &quot;namedParentPackage&quot;);
&nbsp;            lazyInitBitmap |= NAMED_PARENT_PACKAGE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return namedParentPackage;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_SERIALIZED_LAZY_INIT_BIT = 0x400L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonSerialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#isJacksonSerialized() isJacksonSerialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonSerialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonSerialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonSerialized = super.isJacksonSerialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_SERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonSerialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT = 0x800L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonDeserialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#isJacksonDeserialized() isJacksonDeserialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonDeserialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonDeserialized = super.isJacksonDeserialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonDeserialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT = 0x1000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonJsonTypeInfo;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#isJacksonJsonTypeInfo() isJacksonJsonTypeInfo} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonJsonTypeInfo} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonJsonTypeInfo() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonJsonTypeInfo = super.isJacksonJsonTypeInfo();
&nbsp;            lazyInitBitmap |= IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonJsonTypeInfo;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT = 0x2000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isSerialStructural;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#isSerialStructural() isSerialStructural} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isSerialStructural} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isSerialStructural() {
&nbsp;      if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isSerialStructural = super.isSerialStructural();
&nbsp;            lazyInitBitmap |= IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isSerialStructural;
&nbsp;    }
&nbsp;
&nbsp;    private static final long SERIAL_VERSION_LAZY_INIT_BIT = 0x4000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Long&gt; serialVersion;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#serialVersion() serialVersion} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code serialVersion} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
&nbsp;      if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;            this.serialVersion = Objects.requireNonNull(super.serialVersion(), &quot;serialVersion&quot;);
&nbsp;            lazyInitBitmap |= SERIAL_VERSION_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return serialVersion;
&nbsp;    }
&nbsp;
&nbsp;    private static final long STYLE_LAZY_INIT_BIT = 0x8000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;StyleInfo&gt; style;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#style() style} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code style} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
&nbsp;      if ((lazyInitBitmap &amp; STYLE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; STYLE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.style = Objects.requireNonNull(super.style(), &quot;style&quot;);
&nbsp;            lazyInitBitmap |= STYLE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return style;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DEPLURALIZE_LAZY_INIT_BIT = 0x10000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;String[]&gt; depluralize;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#depluralize() depluralize} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code depluralize} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
&nbsp;      if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.depluralize = Objects.requireNonNull(super.depluralize(), &quot;depluralize&quot;);
&nbsp;            lazyInitBitmap |= DEPLURALIZE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return depluralize;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DATATYPE_ENABLED_LAZY_INIT_BIT = 0x20000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;DataMirror&gt; datatypeEnabled;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringPackage#datatypeEnabled() datatypeEnabled} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code datatypeEnabled} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
&nbsp;      if ((lazyInitBitmap &amp; DATATYPE_ENABLED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DATATYPE_ENABLED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.datatypeEnabled = Objects.requireNonNull(super.datatypeEnabled(), &quot;datatypeEnabled&quot;);
&nbsp;            lazyInitBitmap |= DATATYPE_ENABLED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return datatypeEnabled;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Proto.DeclaringPackage} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable DeclaringPackage instance
&nbsp;     */
&nbsp;    public static ImmutableProto.DeclaringPackage copyOf(Proto.DeclaringPackage instance) {
&nbsp;      if (instance instanceof ImmutableProto.DeclaringPackage) {
&nbsp;        return (ImmutableProto.DeclaringPackage) instance;
&nbsp;      }
&nbsp;      return ImmutableProto.DeclaringPackage.builder()
&nbsp;          .environment(instance.environment())
&nbsp;          .interner(instance.interner())
&nbsp;          .element(instance.element())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableProto.DeclaringPackage DeclaringPackage}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableProto.DeclaringPackage.builder()
&nbsp;     *    .environment(org.immutables.value.processor.meta.Proto.Environment) // required {@link Proto.DeclaringPackage#environment() environment}
&nbsp;     *    .interner(org.immutables.value.processor.meta.Proto.Interning) // required {@link Proto.DeclaringPackage#interner() interner}
&nbsp;     *    .element(javax.lang.model.element.PackageElement) // required {@link Proto.DeclaringPackage#element() element}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new DeclaringPackage builder
&nbsp;     */
&nbsp;    public static ImmutableProto.DeclaringPackage.Builder builder() {
&nbsp;      return new ImmutableProto.DeclaringPackage.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableProto.DeclaringPackage DeclaringPackage}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Proto.DeclaringPackage&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_ENVIRONMENT = 0x1L;
&nbsp;      private static final long INIT_BIT_INTERNER = 0x2L;
&nbsp;      private static final long INIT_BIT_ELEMENT = 0x4L;
&nbsp;      private long initBits = 0x7L;
&nbsp;
&nbsp;      private @Nullable Proto.Environment environment;
&nbsp;      private @Nullable Proto.Interning interner;
&nbsp;      private @Nullable PackageElement element;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringPackage#environment() environment} attribute.
&nbsp;       * @param environment The value for environment 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder environment(Proto.Environment environment) {
&nbsp;        checkNotIsSet(environmentIsSet(), &quot;environment&quot;);
&nbsp;        this.environment = Objects.requireNonNull(environment, &quot;environment&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ENVIRONMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringPackage#interner() interner} attribute.
&nbsp;       * @param interner The value for interner 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder interner(Proto.Interning interner) {
&nbsp;        checkNotIsSet(internerIsSet(), &quot;interner&quot;);
&nbsp;        this.interner = Objects.requireNonNull(interner, &quot;interner&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_INTERNER;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringPackage#element() element} attribute.
&nbsp;       * @param element The value for element 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder element(PackageElement element) {
&nbsp;        checkNotIsSet(elementIsSet(), &quot;element&quot;);
&nbsp;        this.element = Objects.requireNonNull(element, &quot;element&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ELEMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableProto.DeclaringPackage DeclaringPackage}.
&nbsp;       * @return An immutable instance of DeclaringPackage
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableProto.DeclaringPackage build() {
&nbsp;        checkRequiredAttributes();
&nbsp;        return new ImmutableProto.DeclaringPackage(environment, interner, element);
&nbsp;      }
&nbsp;
&nbsp;      private boolean environmentIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ENVIRONMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean internerIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_INTERNER) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean elementIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ELEMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private static void checkNotIsSet(boolean isSet, String name) {
&nbsp;        if (isSet) throw new IllegalStateException(&quot;Builder of DeclaringPackage is strict, attribute is already set: &quot;.concat(name));
&nbsp;      }
&nbsp;
&nbsp;      private void checkRequiredAttributes() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (!environmentIsSet()) attributes.add(&quot;environment&quot;);
&nbsp;        if (!internerIsSet()) attributes.add(&quot;interner&quot;);
&nbsp;        if (!elementIsSet()) attributes.add(&quot;element&quot;);
&nbsp;        return &quot;Cannot build DeclaringPackage, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Proto.DeclaringType}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableProto.DeclaringType.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Proto.DeclaringType&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class DeclaringType extends Proto.DeclaringType {
&nbsp;    private final Proto.Environment environment;
&nbsp;    private transient final String simpleName;
&nbsp;    private final Proto.Interning interner;
&nbsp;    private final TypeElement element;
&nbsp;    private transient final String name;
&nbsp;    private transient final Proto.DeclaringPackage packageOf;
&nbsp;    private transient final boolean isTopLevel;
&nbsp;    private transient final boolean isJavaBean;
&nbsp;
&nbsp;    private DeclaringType(
&nbsp;        Proto.Environment environment,
&nbsp;        Proto.Interning interner,
&nbsp;        TypeElement element) {
&nbsp;      this.environment = environment;
&nbsp;      this.interner = interner;
&nbsp;      this.element = element;
&nbsp;      this.simpleName = initShim.simpleName();
&nbsp;      this.name = initShim.name();
&nbsp;      this.packageOf = initShim.packageOf();
&nbsp;      this.isTopLevel = initShim.isTopLevel();
&nbsp;      this.isJavaBean = initShim.isJavaBean();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private static final byte STAGE_INITIALIZING = -1;
&nbsp;    private static final byte STAGE_UNINITIALIZED = 0;
&nbsp;    private static final byte STAGE_INITIALIZED = 1;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile InitShim initShim = new InitShim();
&nbsp;
&nbsp;    @Generated(from = &quot;Proto.DeclaringType&quot;, generator = &quot;Immutables&quot;)
&nbsp;    private final class InitShim {
&nbsp;      private byte simpleNameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String simpleName;
&nbsp;
&nbsp;      String simpleName() {
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (simpleNameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.simpleName = Objects.requireNonNull(DeclaringType.super.simpleName(), &quot;simpleName&quot;);
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.simpleName;
&nbsp;      }
&nbsp;
&nbsp;      private byte nameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String name;
&nbsp;
&nbsp;      String name() {
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (nameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          nameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.name = Objects.requireNonNull(DeclaringType.super.name(), &quot;name&quot;);
&nbsp;          nameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.name;
&nbsp;      }
&nbsp;
&nbsp;      private byte packageOfBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Proto.DeclaringPackage packageOf;
&nbsp;
&nbsp;      Proto.DeclaringPackage packageOf() {
&nbsp;        if (packageOfBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (packageOfBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          packageOfBuildStage = STAGE_INITIALIZING;
&nbsp;          this.packageOf = Objects.requireNonNull(DeclaringType.super.packageOf(), &quot;packageOf&quot;);
&nbsp;          packageOfBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.packageOf;
&nbsp;      }
&nbsp;
&nbsp;      private byte isTopLevelBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isTopLevel;
&nbsp;
&nbsp;      boolean isTopLevel() {
&nbsp;        if (isTopLevelBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isTopLevelBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isTopLevelBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isTopLevel = DeclaringType.super.isTopLevel();
&nbsp;          isTopLevelBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isTopLevel;
&nbsp;      }
&nbsp;
&nbsp;      private byte isJavaBeanBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean isJavaBean;
&nbsp;
&nbsp;      boolean isJavaBean() {
&nbsp;        if (isJavaBeanBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (isJavaBeanBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          isJavaBeanBuildStage = STAGE_INITIALIZING;
&nbsp;          this.isJavaBean = DeclaringType.super.isJavaBean();
&nbsp;          isJavaBeanBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.isJavaBean;
&nbsp;      }
&nbsp;
&nbsp;      private String formatInitCycleMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;simpleName&quot;);
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;name&quot;);
&nbsp;        if (packageOfBuildStage == STAGE_INITIALIZING) attributes.add(&quot;packageOf&quot;);
&nbsp;        if (isTopLevelBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isTopLevel&quot;);
&nbsp;        if (isJavaBeanBuildStage == STAGE_INITIALIZING) attributes.add(&quot;isJavaBean&quot;);
&nbsp;        return &quot;Cannot build DeclaringType, attribute initializers form cycle &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code environment} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    Proto.Environment environment() {
&nbsp;      return environment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code simpleName} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String simpleName() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.simpleName()
&nbsp;          : this.simpleName;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * used to intern packaged created internally
&nbsp;     */
&nbsp;    @Override
&nbsp;    Proto.Interning interner() {
&nbsp;      return interner;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code element} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public TypeElement element() {
&nbsp;      return element;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code name} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String name() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.name()
&nbsp;          : this.name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code packageOf} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.DeclaringPackage packageOf() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.packageOf()
&nbsp;          : this.packageOf;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true, if is top level
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isTopLevel() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isTopLevel()
&nbsp;          : this.isTopLevel;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this element is a regular POJO (not an interface or abstract class) simple
&nbsp;     * class with getters and setters
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJavaBean() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.isJavaBean()
&nbsp;          : this.isJavaBean;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringType#environment() environment} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for environment
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringType withEnvironment(Proto.Environment value) {
&nbsp;      if (this.environment == value) return this;
&nbsp;      Proto.Environment newValue = Objects.requireNonNull(value, &quot;environment&quot;);
&nbsp;      return validate(new ImmutableProto.DeclaringType(newValue, this.interner, this.element));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringType#interner() interner} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for interner
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringType withInterner(Proto.Interning value) {
&nbsp;      if (this.interner == value) return this;
&nbsp;      Proto.Interning newValue = Objects.requireNonNull(value, &quot;interner&quot;);
&nbsp;      return validate(new ImmutableProto.DeclaringType(this.environment, newValue, this.element));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.DeclaringType#element() element} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for element
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.DeclaringType withElement(TypeElement value) {
&nbsp;      if (this.element == value) return this;
&nbsp;      TypeElement newValue = Objects.requireNonNull(value, &quot;element&quot;);
&nbsp;      return validate(new ImmutableProto.DeclaringType(this.environment, this.interner, newValue));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code DeclaringType} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableProto.DeclaringType
&nbsp;          &amp;&amp; equalTo((ImmutableProto.DeclaringType) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableProto.DeclaringType another) {
&nbsp;      return name.equals(another.name);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code DeclaringType} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;DeclaringType&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile long lazyInitBitmap;
&nbsp;
&nbsp;    private static final long INCLUDE_LAZY_INIT_BIT = 0x1L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;IncludeMirror&gt; include;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#include() include} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code include} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected Optional&lt;IncludeMirror&gt; include() {
&nbsp;      if ((lazyInitBitmap &amp; INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.include = Objects.requireNonNull(super.include(), &quot;include&quot;);
&nbsp;            lazyInitBitmap |= INCLUDE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return include;
&nbsp;    }
&nbsp;
&nbsp;    private static final long BUILDER_INCLUDE_LAZY_INIT_BIT = 0x2L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;FIncludeMirror&gt; builderInclude;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#builderInclude() builderInclude} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code builderInclude} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected Optional&lt;FIncludeMirror&gt; builderInclude() {
&nbsp;      if ((lazyInitBitmap &amp; BUILDER_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; BUILDER_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.builderInclude = Objects.requireNonNull(super.builderInclude(), &quot;builderInclude&quot;);
&nbsp;            lazyInitBitmap |= BUILDER_INCLUDE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return builderInclude;
&nbsp;    }
&nbsp;
&nbsp;    private static final long TYPE_ADAPTERS_LAZY_INIT_BIT = 0x4L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;TypeAdaptersMirror&gt; typeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#typeAdapters() typeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code typeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;TypeAdaptersMirror&gt; typeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.typeAdapters = Objects.requireNonNull(super.typeAdapters(), &quot;typeAdapters&quot;);
&nbsp;            lazyInitBitmap |= TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return typeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long OK_TYPE_ADAPTERS_LAZY_INIT_BIT = 0x8L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;OkTypeAdaptersMirror&gt; okTypeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#okTypeAdapters() okTypeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code okTypeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;OkTypeAdaptersMirror&gt; okTypeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.okTypeAdapters = Objects.requireNonNull(super.okTypeAdapters(), &quot;okTypeAdapters&quot;);
&nbsp;            lazyInitBitmap |= OK_TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return okTypeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long INCLUDED_TYPES_LAZY_INIT_BIT = 0x10L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;TypeElement&gt; includedTypes;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#includedTypes() includedTypes} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code includedTypes} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;TypeElement&gt; includedTypes() {
&nbsp;      if ((lazyInitBitmap &amp; INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.includedTypes = Objects.requireNonNull(super.includedTypes(), &quot;includedTypes&quot;);
&nbsp;            lazyInitBitmap |= INCLUDED_TYPES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return includedTypes;
&nbsp;    }
&nbsp;
&nbsp;    private static final long BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT = 0x20L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;TypeElement&gt; builderIncludedTypes;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#builderIncludedTypes() builderIncludedTypes} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code builderIncludedTypes} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;TypeElement&gt; builderIncludedTypes() {
&nbsp;      if ((lazyInitBitmap &amp; BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.builderIncludedTypes = Objects.requireNonNull(super.builderIncludedTypes(), &quot;builderIncludedTypes&quot;);
&nbsp;            lazyInitBitmap |= BUILDER_INCLUDED_TYPES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return builderIncludedTypes;
&nbsp;    }
&nbsp;
&nbsp;    private static final long META_ANNOTATED_LAZY_INIT_BIT = 0x40L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient List&lt;Proto.MetaAnnotated&gt; metaAnnotated;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#metaAnnotated() metaAnnotated} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code metaAnnotated} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    List&lt;Proto.MetaAnnotated&gt; metaAnnotated() {
&nbsp;      if ((lazyInitBitmap &amp; META_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; META_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.metaAnnotated = Objects.requireNonNull(super.metaAnnotated(), &quot;metaAnnotated&quot;);
&nbsp;            lazyInitBitmap |= META_ANNOTATED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return metaAnnotated;
&nbsp;    }
&nbsp;
&nbsp;    private static final long STYLE_LAZY_INIT_BIT = 0x80L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;StyleInfo&gt; style;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#style() style} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code style} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;StyleInfo&gt; style() {
&nbsp;      if ((lazyInitBitmap &amp; STYLE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; STYLE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.style = Objects.requireNonNull(super.style(), &quot;style&quot;);
&nbsp;            lazyInitBitmap |= STYLE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return style;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DATATYPE_ENABLED_LAZY_INIT_BIT = 0x100L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;DataMirror&gt; datatypeEnabled;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#datatypeEnabled() datatypeEnabled} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code datatypeEnabled} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;DataMirror&gt; datatypeEnabled() {
&nbsp;      if ((lazyInitBitmap &amp; DATATYPE_ENABLED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DATATYPE_ENABLED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.datatypeEnabled = Objects.requireNonNull(super.datatypeEnabled(), &quot;datatypeEnabled&quot;);
&nbsp;            lazyInitBitmap |= DATATYPE_ENABLED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return datatypeEnabled;
&nbsp;    }
&nbsp;
&nbsp;    private static final long SERIAL_VERSION_LAZY_INIT_BIT = 0x200L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Long&gt; serialVersion;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#serialVersion() serialVersion} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code serialVersion} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
&nbsp;      if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;            this.serialVersion = Objects.requireNonNull(super.serialVersion(), &quot;serialVersion&quot;);
&nbsp;            lazyInitBitmap |= SERIAL_VERSION_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return serialVersion;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT = 0x400L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isSerialStructural;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isSerialStructural() isSerialStructural} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isSerialStructural} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isSerialStructural() {
&nbsp;      if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isSerialStructural = super.isSerialStructural();
&nbsp;            lazyInitBitmap |= IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isSerialStructural;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_SERIALIZED_LAZY_INIT_BIT = 0x800L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonSerialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isJacksonSerialized() isJacksonSerialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonSerialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonSerialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonSerialized = super.isJacksonSerialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_SERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonSerialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT = 0x1000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonDeserialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isJacksonDeserialized() isJacksonDeserialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonDeserialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonDeserialized = super.isJacksonDeserialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonDeserialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DEPLURALIZE_LAZY_INIT_BIT = 0x2000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;String[]&gt; depluralize;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#depluralize() depluralize} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code depluralize} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
&nbsp;      if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.depluralize = Objects.requireNonNull(super.depluralize(), &quot;depluralize&quot;);
&nbsp;            lazyInitBitmap |= DEPLURALIZE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return depluralize;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT = 0x4000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonDeserializedAnnotated;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isJacksonDeserializedAnnotated() isJacksonDeserializedAnnotated} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonDeserializedAnnotated} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserializedAnnotated() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonDeserializedAnnotated = super.isJacksonDeserializedAnnotated();
&nbsp;            lazyInitBitmap |= IS_JACKSON_DESERIALIZED_ANNOTATED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonDeserializedAnnotated;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT = 0x8000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonJsonTypeInfo;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isJacksonJsonTypeInfo() isJacksonJsonTypeInfo} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonJsonTypeInfo} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonJsonTypeInfo() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonJsonTypeInfo = super.isJacksonJsonTypeInfo();
&nbsp;            lazyInitBitmap |= IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonJsonTypeInfo;
&nbsp;    }
&nbsp;
&nbsp;    private static final long ENCLOSING_TOP_LEVEL_LAZY_INIT_BIT = 0x10000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.DeclaringType&gt; enclosingTopLevel;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#enclosingTopLevel() enclosingTopLevel} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code enclosingTopLevel} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.DeclaringType&gt; enclosingTopLevel() {
&nbsp;      if ((lazyInitBitmap &amp; ENCLOSING_TOP_LEVEL_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; ENCLOSING_TOP_LEVEL_LAZY_INIT_BIT) == 0) {
&nbsp;            this.enclosingTopLevel = Objects.requireNonNull(super.enclosingTopLevel(), &quot;enclosingTopLevel&quot;);
&nbsp;            lazyInitBitmap |= ENCLOSING_TOP_LEVEL_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return enclosingTopLevel;
&nbsp;    }
&nbsp;
&nbsp;    private static final long CRITERIA_LAZY_INIT_BIT = 0x20000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;CriteriaMirror&gt; criteria;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#criteria() criteria} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code criteria} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;CriteriaMirror&gt; criteria() {
&nbsp;      if ((lazyInitBitmap &amp; CRITERIA_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CRITERIA_LAZY_INIT_BIT) == 0) {
&nbsp;            this.criteria = Objects.requireNonNull(super.criteria(), &quot;criteria&quot;);
&nbsp;            lazyInitBitmap |= CRITERIA_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return criteria;
&nbsp;    }
&nbsp;
&nbsp;    private static final long REPOSITORY_LAZY_INIT_BIT = 0x40000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;RepositoryMirror&gt; repository;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#repository() repository} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code repository} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;RepositoryMirror&gt; repository() {
&nbsp;      if ((lazyInitBitmap &amp; REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;            this.repository = Objects.requireNonNull(super.repository(), &quot;repository&quot;);
&nbsp;            lazyInitBitmap |= REPOSITORY_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return repository;
&nbsp;    }
&nbsp;
&nbsp;    private static final long CRITERIA_REPOSITORY_LAZY_INIT_BIT = 0x80000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#criteriaRepository() criteriaRepository} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code criteriaRepository} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository() {
&nbsp;      if ((lazyInitBitmap &amp; CRITERIA_REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CRITERIA_REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;            this.criteriaRepository = Objects.requireNonNull(super.criteriaRepository(), &quot;criteriaRepository&quot;);
&nbsp;            lazyInitBitmap |= CRITERIA_REPOSITORY_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return criteriaRepository;
&nbsp;    }
&nbsp;
&nbsp;    private static final long ENCLOSING_OF_LAZY_INIT_BIT = 0x100000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.DeclaringType&gt; enclosingOf;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#enclosingOf() enclosingOf} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code enclosingOf} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.DeclaringType&gt; enclosingOf() {
&nbsp;      if ((lazyInitBitmap &amp; ENCLOSING_OF_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; ENCLOSING_OF_LAZY_INIT_BIT) == 0) {
&nbsp;            this.enclosingOf = Objects.requireNonNull(super.enclosingOf(), &quot;enclosingOf&quot;);
&nbsp;            lazyInitBitmap |= ENCLOSING_OF_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return enclosingOf;
&nbsp;    }
&nbsp;
&nbsp;    private static final long FEATURES_LAZY_INIT_BIT = 0x200000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;ValueImmutableInfo&gt; features;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#features() features} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code features} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;ValueImmutableInfo&gt; features() {
&nbsp;      if ((lazyInitBitmap &amp; FEATURES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; FEATURES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.features = Objects.requireNonNull(super.features(), &quot;features&quot;);
&nbsp;            lazyInitBitmap |= FEATURES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return features;
&nbsp;    }
&nbsp;
&nbsp;    private static final long JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT = 0x400000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Proto.JacksonMode jacksonSerializeMode;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#jacksonSerializeMode() jacksonSerializeMode} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code jacksonSerializeMode} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.JacksonMode jacksonSerializeMode() {
&nbsp;      if ((lazyInitBitmap &amp; JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.jacksonSerializeMode = Objects.requireNonNull(super.jacksonSerializeMode(), &quot;jacksonSerializeMode&quot;);
&nbsp;            lazyInitBitmap |= JACKSON_SERIALIZE_MODE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return jacksonSerializeMode;
&nbsp;    }
&nbsp;
&nbsp;    private static final long USE_IMMUTABLE_DEFAULTS_LAZY_INIT_BIT = 0x800000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean useImmutableDefaults;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#useImmutableDefaults() useImmutableDefaults} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code useImmutableDefaults} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean useImmutableDefaults() {
&nbsp;      if ((lazyInitBitmap &amp; USE_IMMUTABLE_DEFAULTS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; USE_IMMUTABLE_DEFAULTS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.useImmutableDefaults = super.useImmutableDefaults();
&nbsp;            lazyInitBitmap |= USE_IMMUTABLE_DEFAULTS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return useImmutableDefaults;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_ENCLOSING_LAZY_INIT_BIT = 0x1000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isEnclosing;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isEnclosing() isEnclosing} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isEnclosing} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isEnclosing() {
&nbsp;      if ((lazyInitBitmap &amp; IS_ENCLOSING_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_ENCLOSING_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isEnclosing = super.isEnclosing();
&nbsp;            lazyInitBitmap |= IS_ENCLOSING_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isEnclosing;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_MODIFIABLE_LAZY_INIT_BIT = 0x2000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isModifiable;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isModifiable() isModifiable} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isModifiable} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isModifiable() {
&nbsp;      if ((lazyInitBitmap &amp; IS_MODIFIABLE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_MODIFIABLE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isModifiable = super.isModifiable();
&nbsp;            lazyInitBitmap |= IS_MODIFIABLE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isModifiable;
&nbsp;    }
&nbsp;
&nbsp;    private static final long SOURCE_CODE_LAZY_INIT_BIT = 0x4000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient CharSequence sourceCode;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#sourceCode() sourceCode} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code sourceCode} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public CharSequence sourceCode() {
&nbsp;      if ((lazyInitBitmap &amp; SOURCE_CODE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; SOURCE_CODE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.sourceCode = Objects.requireNonNull(super.sourceCode(), &quot;sourceCode&quot;);
&nbsp;            lazyInitBitmap |= SOURCE_CODE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return sourceCode;
&nbsp;    }
&nbsp;
&nbsp;    private static final long HEADER_COMMENTS_LAZY_INIT_BIT = 0x8000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient CharSequence headerComments;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#headerComments() headerComments} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code headerComments} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public CharSequence headerComments() {
&nbsp;      if ((lazyInitBitmap &amp; HEADER_COMMENTS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; HEADER_COMMENTS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.headerComments = Objects.requireNonNull(super.headerComments(), &quot;headerComments&quot;);
&nbsp;            lazyInitBitmap |= HEADER_COMMENTS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return headerComments;
&nbsp;    }
&nbsp;
&nbsp;    private static final long SOURCE_IMPORTS_LAZY_INIT_BIT = 0x10000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient SourceExtraction.Imports sourceImports;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#sourceImports() sourceImports} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code sourceImports} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public SourceExtraction.Imports sourceImports() {
&nbsp;      if ((lazyInitBitmap &amp; SOURCE_IMPORTS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; SOURCE_IMPORTS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.sourceImports = Objects.requireNonNull(super.sourceImports(), &quot;sourceImports&quot;);
&nbsp;            lazyInitBitmap |= SOURCE_IMPORTS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return sourceImports;
&nbsp;    }
&nbsp;
&nbsp;    private static final long TRANSFORM_LAZY_INIT_BIT = 0x20000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;TransformMirror&gt; transform;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#getTransform() transform} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code transform} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;TransformMirror&gt; getTransform() {
&nbsp;      if ((lazyInitBitmap &amp; TRANSFORM_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TRANSFORM_LAZY_INIT_BIT) == 0) {
&nbsp;            this.transform = Objects.requireNonNull(super.getTransform(), &quot;transform&quot;);
&nbsp;            lazyInitBitmap |= TRANSFORM_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return transform;
&nbsp;    }
&nbsp;
&nbsp;    private static final long TREES_INCLUDE_LAZY_INIT_BIT = 0x40000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;TreesIncludeMirror&gt; treesInclude;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#getTreesInclude() treesInclude} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code treesInclude} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;TreesIncludeMirror&gt; getTreesInclude() {
&nbsp;      if ((lazyInitBitmap &amp; TREES_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TREES_INCLUDE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.treesInclude = Objects.requireNonNull(super.getTreesInclude(), &quot;treesInclude&quot;);
&nbsp;            lazyInitBitmap |= TREES_INCLUDE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return treesInclude;
&nbsp;    }
&nbsp;
&nbsp;    private static final long VISIT_LAZY_INIT_BIT = 0x80000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;VisitMirror&gt; visit;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#getVisit() visit} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code visit} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;VisitMirror&gt; getVisit() {
&nbsp;      if ((lazyInitBitmap &amp; VISIT_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; VISIT_LAZY_INIT_BIT) == 0) {
&nbsp;            this.visit = Objects.requireNonNull(super.getVisit(), &quot;visit&quot;);
&nbsp;            lazyInitBitmap |= VISIT_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return visit;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_AST_LAZY_INIT_BIT = 0x100000000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isAst;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.DeclaringType#isAst() isAst} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isAst} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isAst() {
&nbsp;      if ((lazyInitBitmap &amp; IS_AST_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_AST_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isAst = super.isAst();
&nbsp;            lazyInitBitmap |= IS_AST_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isAst;
&nbsp;    }
&nbsp;
&nbsp;    private static ImmutableProto.DeclaringType validate(ImmutableProto.DeclaringType instance) {
&nbsp;      instance.validate();
&nbsp;      return instance;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Proto.DeclaringType} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable DeclaringType instance
&nbsp;     */
&nbsp;    public static ImmutableProto.DeclaringType copyOf(Proto.DeclaringType instance) {
&nbsp;      if (instance instanceof ImmutableProto.DeclaringType) {
&nbsp;        return (ImmutableProto.DeclaringType) instance;
&nbsp;      }
&nbsp;      return ImmutableProto.DeclaringType.builder()
&nbsp;          .environment(instance.environment())
&nbsp;          .interner(instance.interner())
&nbsp;          .element(instance.element())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableProto.DeclaringType DeclaringType}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableProto.DeclaringType.builder()
&nbsp;     *    .environment(org.immutables.value.processor.meta.Proto.Environment) // required {@link Proto.DeclaringType#environment() environment}
&nbsp;     *    .interner(org.immutables.value.processor.meta.Proto.Interning) // required {@link Proto.DeclaringType#interner() interner}
&nbsp;     *    .element(javax.lang.model.element.TypeElement) // required {@link Proto.DeclaringType#element() element}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new DeclaringType builder
&nbsp;     */
&nbsp;    public static ImmutableProto.DeclaringType.Builder builder() {
&nbsp;      return new ImmutableProto.DeclaringType.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableProto.DeclaringType DeclaringType}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Proto.DeclaringType&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_ENVIRONMENT = 0x1L;
&nbsp;      private static final long INIT_BIT_INTERNER = 0x2L;
&nbsp;      private static final long INIT_BIT_ELEMENT = 0x4L;
&nbsp;      private long initBits = 0x7L;
&nbsp;
&nbsp;      private @Nullable Proto.Environment environment;
&nbsp;      private @Nullable Proto.Interning interner;
&nbsp;      private @Nullable TypeElement element;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringType#environment() environment} attribute.
&nbsp;       * @param environment The value for environment 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder environment(Proto.Environment environment) {
&nbsp;        checkNotIsSet(environmentIsSet(), &quot;environment&quot;);
&nbsp;        this.environment = Objects.requireNonNull(environment, &quot;environment&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ENVIRONMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringType#interner() interner} attribute.
&nbsp;       * @param interner The value for interner 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder interner(Proto.Interning interner) {
&nbsp;        checkNotIsSet(internerIsSet(), &quot;interner&quot;);
&nbsp;        this.interner = Objects.requireNonNull(interner, &quot;interner&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_INTERNER;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.DeclaringType#element() element} attribute.
&nbsp;       * @param element The value for element 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder element(TypeElement element) {
&nbsp;        checkNotIsSet(elementIsSet(), &quot;element&quot;);
&nbsp;        this.element = Objects.requireNonNull(element, &quot;element&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ELEMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableProto.DeclaringType DeclaringType}.
&nbsp;       * @return An immutable instance of DeclaringType
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableProto.DeclaringType build() {
&nbsp;        checkRequiredAttributes();
&nbsp;        return ImmutableProto.DeclaringType.validate(new ImmutableProto.DeclaringType(environment, interner, element));
&nbsp;      }
&nbsp;
&nbsp;      private boolean environmentIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ENVIRONMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean internerIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_INTERNER) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean elementIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ELEMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private static void checkNotIsSet(boolean isSet, String name) {
&nbsp;        if (isSet) throw new IllegalStateException(&quot;Builder of DeclaringType is strict, attribute is already set: &quot;.concat(name));
&nbsp;      }
&nbsp;
&nbsp;      private void checkRequiredAttributes() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (!environmentIsSet()) attributes.add(&quot;environment&quot;);
&nbsp;        if (!internerIsSet()) attributes.add(&quot;interner&quot;);
&nbsp;        if (!elementIsSet()) attributes.add(&quot;element&quot;);
&nbsp;        return &quot;Cannot build DeclaringType, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Proto.Protoclass}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableProto.Protoclass.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Proto.Protoclass&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Protoclass extends Proto.Protoclass {
&nbsp;    private final Proto.Environment environment;
&nbsp;    private transient final String simpleName;
&nbsp;    private transient final String name;
&nbsp;    private final Element sourceElement;
&nbsp;    private final Proto.DeclaringPackage packageOf;
&nbsp;    private final Optional&lt;Proto.DeclaringType&gt; declaringType;
&nbsp;    private final Proto.Protoclass.Kind kind;
&nbsp;    private transient final Visibility visibility;
&nbsp;    private transient final Element element;
&nbsp;    private transient final Optional&lt;Proto.DeclaringType&gt; enclosingOf;
&nbsp;
&nbsp;    private Protoclass(
&nbsp;        Proto.Environment environment,
&nbsp;        Element sourceElement,
&nbsp;        Proto.DeclaringPackage packageOf,
&nbsp;        Optional&lt;Proto.DeclaringType&gt; declaringType,
&nbsp;        Proto.Protoclass.Kind kind) {
&nbsp;      this.environment = environment;
&nbsp;      this.sourceElement = sourceElement;
&nbsp;      this.packageOf = packageOf;
&nbsp;      this.declaringType = declaringType;
&nbsp;      this.kind = kind;
&nbsp;      this.simpleName = initShim.simpleName();
&nbsp;      this.name = initShim.name();
&nbsp;      this.visibility = initShim.visibility();
&nbsp;      this.element = initShim.element();
&nbsp;      this.enclosingOf = initShim.enclosingOf();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private static final byte STAGE_INITIALIZING = -1;
&nbsp;    private static final byte STAGE_UNINITIALIZED = 0;
&nbsp;    private static final byte STAGE_INITIALIZED = 1;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile InitShim initShim = new InitShim();
&nbsp;
&nbsp;    @Generated(from = &quot;Proto.Protoclass&quot;, generator = &quot;Immutables&quot;)
&nbsp;    private final class InitShim {
&nbsp;      private byte simpleNameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String simpleName;
&nbsp;
&nbsp;      String simpleName() {
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (simpleNameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.simpleName = Objects.requireNonNull(Protoclass.super.simpleName(), &quot;simpleName&quot;);
&nbsp;          simpleNameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.simpleName;
&nbsp;      }
&nbsp;
&nbsp;      private byte nameBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private String name;
&nbsp;
&nbsp;      String name() {
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (nameBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          nameBuildStage = STAGE_INITIALIZING;
&nbsp;          this.name = Objects.requireNonNull(Protoclass.super.name(), &quot;name&quot;);
&nbsp;          nameBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.name;
&nbsp;      }
&nbsp;
&nbsp;      private byte visibilityBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Visibility visibility;
&nbsp;
&nbsp;      Visibility visibility() {
&nbsp;        if (visibilityBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (visibilityBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          visibilityBuildStage = STAGE_INITIALIZING;
&nbsp;          this.visibility = Objects.requireNonNull(Protoclass.super.visibility(), &quot;visibility&quot;);
&nbsp;          visibilityBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.visibility;
&nbsp;      }
&nbsp;
&nbsp;      private byte elementBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Element element;
&nbsp;
&nbsp;      Element element() {
&nbsp;        if (elementBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (elementBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          elementBuildStage = STAGE_INITIALIZING;
&nbsp;          this.element = Objects.requireNonNull(Protoclass.super.element(), &quot;element&quot;);
&nbsp;          elementBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.element;
&nbsp;      }
&nbsp;
&nbsp;      private byte enclosingOfBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private Optional&lt;Proto.DeclaringType&gt; enclosingOf;
&nbsp;
&nbsp;      Optional&lt;Proto.DeclaringType&gt; enclosingOf() {
&nbsp;        if (enclosingOfBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (enclosingOfBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          enclosingOfBuildStage = STAGE_INITIALIZING;
&nbsp;          this.enclosingOf = Objects.requireNonNull(Protoclass.super.enclosingOf(), &quot;enclosingOf&quot;);
&nbsp;          enclosingOfBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.enclosingOf;
&nbsp;      }
&nbsp;
&nbsp;      private String formatInitCycleMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (simpleNameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;simpleName&quot;);
&nbsp;        if (nameBuildStage == STAGE_INITIALIZING) attributes.add(&quot;name&quot;);
&nbsp;        if (visibilityBuildStage == STAGE_INITIALIZING) attributes.add(&quot;visibility&quot;);
&nbsp;        if (elementBuildStage == STAGE_INITIALIZING) attributes.add(&quot;element&quot;);
&nbsp;        if (enclosingOfBuildStage == STAGE_INITIALIZING) attributes.add(&quot;enclosingOf&quot;);
&nbsp;        return &quot;Cannot build Protoclass, attribute initializers form cycle &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code environment} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    Proto.Environment environment() {
&nbsp;      return environment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code simpleName} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String simpleName() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.simpleName()
&nbsp;          : this.simpleName;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code name} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String name() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.name()
&nbsp;          : this.name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Source type elements stores type element which is used as a source of value type model.
&nbsp;     * It is the annotated class for {@code @Value.Immutable} or type referenced in
&nbsp;     * {@code @Value.Include}.
&nbsp;     * @return source element
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Element sourceElement() {
&nbsp;      return sourceElement;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Declaring package that defines value type (usually by import).
&nbsp;     * Or the package in which {@link #declaringType()} resides.
&nbsp;     * @return declaring package
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.DeclaringPackage packageOf() {
&nbsp;      return packageOf;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The class, which is annotated to be a {@code @Value.Immutable}, {@code @Value.Include} or
&nbsp;     * {@code @Value.Enclosing}.
&nbsp;     * @return declaring type
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.DeclaringType&gt; declaringType() {
&nbsp;      return declaringType;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Kind of protoclass declaration, it specifies how exactly the protoclass was declared.
&nbsp;     * @return definition kind
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Proto.Protoclass.Kind kind() {
&nbsp;      return kind;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code visibility} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Visibility visibility() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.visibility()
&nbsp;          : this.visibility;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Element used mostly for error reporting,
&nbsp;     * real model provided by {@link #sourceElement()}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Element element() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.element()
&nbsp;          : this.element;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The computed-at-construction value of the {@code enclosingOf} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.DeclaringType&gt; enclosingOf() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.enclosingOf()
&nbsp;          : this.enclosingOf;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Protoclass#environment() environment} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for environment
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Protoclass withEnvironment(Proto.Environment value) {
&nbsp;      if (this.environment == value) return this;
&nbsp;      Proto.Environment newValue = Objects.requireNonNull(value, &quot;environment&quot;);
&nbsp;      return new ImmutableProto.Protoclass(newValue, this.sourceElement, this.packageOf, this.declaringType, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Protoclass#sourceElement() sourceElement} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for sourceElement
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Protoclass withSourceElement(Element value) {
&nbsp;      if (this.sourceElement == value) return this;
&nbsp;      Element newValue = Objects.requireNonNull(value, &quot;sourceElement&quot;);
&nbsp;      return new ImmutableProto.Protoclass(this.environment, newValue, this.packageOf, this.declaringType, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Protoclass#packageOf() packageOf} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for packageOf
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Protoclass withPackageOf(Proto.DeclaringPackage value) {
&nbsp;      if (this.packageOf == value) return this;
&nbsp;      Proto.DeclaringPackage newValue = Objects.requireNonNull(value, &quot;packageOf&quot;);
&nbsp;      return new ImmutableProto.Protoclass(this.environment, this.sourceElement, newValue, this.declaringType, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Proto.Protoclass#declaringType() declaringType} attribute.
&nbsp;     * @param value The value for declaringType
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Protoclass withDeclaringType(Proto.DeclaringType value) {
&nbsp;      Optional&lt;Proto.DeclaringType&gt; newValue = Optional.of(value);
&nbsp;      if (this.declaringType.isPresent() &amp;&amp; this.declaringType.get() == value) return this;
&nbsp;      return new ImmutableProto.Protoclass(this.environment, this.sourceElement, this.packageOf, newValue, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Proto.Protoclass#declaringType() declaringType} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for declaringType
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableProto.Protoclass withDeclaringType(Optional&lt;? extends Proto.DeclaringType&gt; optional) {
&nbsp;      Optional&lt;Proto.DeclaringType&gt; value = (Optional&lt;Proto.DeclaringType&gt;) optional;
&nbsp;      if (!this.declaringType.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.declaringType.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.declaringType.get() == value.get()) return this;
&nbsp;      return new ImmutableProto.Protoclass(this.environment, this.sourceElement, this.packageOf, value, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Proto.Protoclass#kind() kind} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for kind
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableProto.Protoclass withKind(Proto.Protoclass.Kind value) {
&nbsp;      if (this.kind == value) return this;
&nbsp;      Proto.Protoclass.Kind newValue = Objects.requireNonNull(value, &quot;kind&quot;);
&nbsp;      if (this.kind.equals(newValue)) return this;
&nbsp;      return new ImmutableProto.Protoclass(this.environment, this.sourceElement, this.packageOf, this.declaringType, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Protoclass} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableProto.Protoclass
&nbsp;          &amp;&amp; equalTo((ImmutableProto.Protoclass) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableProto.Protoclass another) {
&nbsp;      return name.equals(another.name)
&nbsp;          &amp;&amp; packageOf.equals(another.packageOf)
&nbsp;          &amp;&amp; declaringType.equals(another.declaringType)
&nbsp;          &amp;&amp; kind.equals(another.kind)
&nbsp;          &amp;&amp; visibility.equals(another.visibility);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}, {@code packageOf}, {@code declaringType}, {@code kind}, {@code visibility}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + packageOf.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + declaringType.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + kind.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + visibility.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Protoclass} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Protoclass&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .add(&quot;packageOf&quot;, packageOf)
&nbsp;          .add(&quot;declaringType&quot;, declaringType.orNull())
&nbsp;          .add(&quot;kind&quot;, kind)
&nbsp;          .add(&quot;visibility&quot;, visibility)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile long lazyInitBitmap;
&nbsp;
&nbsp;    private static final long CRITERIA_LAZY_INIT_BIT = 0x1L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;CriteriaMirror&gt; criteria;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#criteria() criteria} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code criteria} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;CriteriaMirror&gt; criteria() {
&nbsp;      if ((lazyInitBitmap &amp; CRITERIA_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CRITERIA_LAZY_INIT_BIT) == 0) {
&nbsp;            this.criteria = Objects.requireNonNull(super.criteria(), &quot;criteria&quot;);
&nbsp;            lazyInitBitmap |= CRITERIA_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return criteria;
&nbsp;    }
&nbsp;
&nbsp;    private static final long REPOSITORY_LAZY_INIT_BIT = 0x2L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;RepositoryMirror&gt; repository;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#repository() repository} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code repository} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;RepositoryMirror&gt; repository() {
&nbsp;      if ((lazyInitBitmap &amp; REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;            this.repository = Objects.requireNonNull(super.repository(), &quot;repository&quot;);
&nbsp;            lazyInitBitmap |= REPOSITORY_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return repository;
&nbsp;    }
&nbsp;
&nbsp;    private static final long CRITERIA_REPOSITORY_LAZY_INIT_BIT = 0x4L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#criteriaRepository() criteriaRepository} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code criteriaRepository} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;CriteriaRepositoryMirror&gt; criteriaRepository() {
&nbsp;      if ((lazyInitBitmap &amp; CRITERIA_REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CRITERIA_REPOSITORY_LAZY_INIT_BIT) == 0) {
&nbsp;            this.criteriaRepository = Objects.requireNonNull(super.criteriaRepository(), &quot;criteriaRepository&quot;);
&nbsp;            lazyInitBitmap |= CRITERIA_REPOSITORY_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return criteriaRepository;
&nbsp;    }
&nbsp;
&nbsp;    private static final long GSON_TYPE_ADAPTERS_LAZY_INIT_BIT = 0x8L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;TypeAdaptersMirror&gt; gsonTypeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#gsonTypeAdapters() gsonTypeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code gsonTypeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;TypeAdaptersMirror&gt; gsonTypeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; GSON_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; GSON_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.gsonTypeAdapters = Objects.requireNonNull(super.gsonTypeAdapters(), &quot;gsonTypeAdapters&quot;);
&nbsp;            lazyInitBitmap |= GSON_TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return gsonTypeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT = 0x10L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.AbstractDeclaring&gt; typeAdaptersProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#typeAdaptersProvider() typeAdaptersProvider} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code typeAdaptersProvider} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.AbstractDeclaring&gt; typeAdaptersProvider() {
&nbsp;      if ((lazyInitBitmap &amp; TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;            this.typeAdaptersProvider = Objects.requireNonNull(super.typeAdaptersProvider(), &quot;typeAdaptersProvider&quot;);
&nbsp;            lazyInitBitmap |= TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return typeAdaptersProvider;
&nbsp;    }
&nbsp;
&nbsp;    private static final long OK_JSON_TYPE_ADAPTERS_LAZY_INIT_BIT = 0x20L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;OkTypeAdaptersMirror&gt; okJsonTypeAdapters;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#okJsonTypeAdapters() okJsonTypeAdapters} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code okJsonTypeAdapters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;OkTypeAdaptersMirror&gt; okJsonTypeAdapters() {
&nbsp;      if ((lazyInitBitmap &amp; OK_JSON_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; OK_JSON_TYPE_ADAPTERS_LAZY_INIT_BIT) == 0) {
&nbsp;            this.okJsonTypeAdapters = Objects.requireNonNull(super.okJsonTypeAdapters(), &quot;okJsonTypeAdapters&quot;);
&nbsp;            lazyInitBitmap |= OK_JSON_TYPE_ADAPTERS_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return okJsonTypeAdapters;
&nbsp;    }
&nbsp;
&nbsp;    private static final long OK_TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT = 0x40L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.AbstractDeclaring&gt; okTypeAdaptersProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#okTypeAdaptersProvider() okTypeAdaptersProvider} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code okTypeAdaptersProvider} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.AbstractDeclaring&gt; okTypeAdaptersProvider() {
&nbsp;      if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; OK_TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;            this.okTypeAdaptersProvider = Objects.requireNonNull(super.okTypeAdaptersProvider(), &quot;okTypeAdaptersProvider&quot;);
&nbsp;            lazyInitBitmap |= OK_TYPE_ADAPTERS_PROVIDER_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return okTypeAdaptersProvider;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DATATYPE_MARKER_LAZY_INIT_BIT = 0x80L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;DataMirror&gt; datatypeMarker;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#datatypeMarker() datatypeMarker} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code datatypeMarker} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;DataMirror&gt; datatypeMarker() {
&nbsp;      if ((lazyInitBitmap &amp; DATATYPE_MARKER_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DATATYPE_MARKER_LAZY_INIT_BIT) == 0) {
&nbsp;            this.datatypeMarker = Objects.requireNonNull(super.datatypeMarker(), &quot;datatypeMarker&quot;);
&nbsp;            lazyInitBitmap |= DATATYPE_MARKER_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return datatypeMarker;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DATATYPE_PROVIDER_LAZY_INIT_BIT = 0x100L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Proto.AbstractDeclaring&gt; datatypeProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#datatypeProvider() datatypeProvider} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code datatypeProvider} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Proto.AbstractDeclaring&gt; datatypeProvider() {
&nbsp;      if ((lazyInitBitmap &amp; DATATYPE_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DATATYPE_PROVIDER_LAZY_INIT_BIT) == 0) {
&nbsp;            this.datatypeProvider = Objects.requireNonNull(super.datatypeProvider(), &quot;datatypeProvider&quot;);
&nbsp;            lazyInitBitmap |= DATATYPE_PROVIDER_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return datatypeProvider;
&nbsp;    }
&nbsp;
&nbsp;    private static final long SERIAL_VERSION_LAZY_INIT_BIT = 0x200L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;Long&gt; serialVersion;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#serialVersion() serialVersion} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code serialVersion} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Long&gt; serialVersion() {
&nbsp;      if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; SERIAL_VERSION_LAZY_INIT_BIT) == 0) {
&nbsp;            this.serialVersion = Objects.requireNonNull(super.serialVersion(), &quot;serialVersion&quot;);
&nbsp;            lazyInitBitmap |= SERIAL_VERSION_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return serialVersion;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT = 0x400L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isSerialStructural;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#isSerialStructural() isSerialStructural} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isSerialStructural} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isSerialStructural() {
&nbsp;      if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isSerialStructural = super.isSerialStructural();
&nbsp;            lazyInitBitmap |= IS_SERIAL_STRUCTURAL_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isSerialStructural;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_SERIALIZED_LAZY_INIT_BIT = 0x800L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonSerialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#isJacksonSerialized() isJacksonSerialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonSerialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonSerialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_SERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonSerialized = super.isJacksonSerialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_SERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonSerialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT = 0x1000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonDeserialized;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#isJacksonDeserialized() isJacksonDeserialized} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonDeserialized} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonDeserialized() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonDeserialized = super.isJacksonDeserialized();
&nbsp;            lazyInitBitmap |= IS_JACKSON_DESERIALIZED_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonDeserialized;
&nbsp;    }
&nbsp;
&nbsp;    private static final long FEATURES_LAZY_INIT_BIT = 0x2000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient ValueImmutableInfo features;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#features() features} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code features} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ValueImmutableInfo features() {
&nbsp;      if ((lazyInitBitmap &amp; FEATURES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; FEATURES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.features = Objects.requireNonNull(super.features(), &quot;features&quot;);
&nbsp;            lazyInitBitmap |= FEATURES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return features;
&nbsp;    }
&nbsp;
&nbsp;    private static final long STYLES_LAZY_INIT_BIT = 0x4000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Styles styles;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#styles() styles} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code styles} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Styles styles() {
&nbsp;      if ((lazyInitBitmap &amp; STYLES_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; STYLES_LAZY_INIT_BIT) == 0) {
&nbsp;            this.styles = Objects.requireNonNull(super.styles(), &quot;styles&quot;);
&nbsp;            lazyInitBitmap |= STYLES_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return styles;
&nbsp;    }
&nbsp;
&nbsp;    private static final long DEPLURALIZE_LAZY_INIT_BIT = 0x8000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Optional&lt;String[]&gt; depluralize;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#depluralize() depluralize} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code depluralize} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;String[]&gt; depluralize() {
&nbsp;      if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; DEPLURALIZE_LAZY_INIT_BIT) == 0) {
&nbsp;            this.depluralize = Objects.requireNonNull(super.depluralize(), &quot;depluralize&quot;);
&nbsp;            lazyInitBitmap |= DEPLURALIZE_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return depluralize;
&nbsp;    }
&nbsp;
&nbsp;    private static final long IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT = 0x10000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient boolean isJacksonJsonTypeInfo;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#isJacksonJsonTypeInfo() isJacksonJsonTypeInfo} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code isJacksonJsonTypeInfo} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isJacksonJsonTypeInfo() {
&nbsp;      if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT) == 0) {
&nbsp;            this.isJacksonJsonTypeInfo = super.isJacksonJsonTypeInfo();
&nbsp;            lazyInitBitmap |= IS_JACKSON_JSON_TYPE_INFO_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return isJacksonJsonTypeInfo;
&nbsp;    }
&nbsp;
&nbsp;    private static final long CONSTITUTION_LAZY_INIT_BIT = 0x20000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Constitution constitution;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#constitution() constitution} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code constitution} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Constitution constitution() {
&nbsp;      if ((lazyInitBitmap &amp; CONSTITUTION_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; CONSTITUTION_LAZY_INIT_BIT) == 0) {
&nbsp;            this.constitution = Objects.requireNonNull(super.constitution(), &quot;constitution&quot;);
&nbsp;            lazyInitBitmap |= CONSTITUTION_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return constitution;
&nbsp;    }
&nbsp;
&nbsp;    private static final long ENCODING_INSTANTIATOR_LAZY_INIT_BIT = 0x40000L;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient Instantiator encodingInstantiator;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a lazily initialized value of the {@link Proto.Protoclass#encodingInstantiator() encodingInstantiator} attribute.
&nbsp;     * Initialized once and only once and stored for subsequent access with proper synchronization.
&nbsp;     * In case of any exception or error thrown by the lazy value initializer,
&nbsp;     * the result will not be memoised (i.e. remembered) and on next call computation
&nbsp;     * will be attempted again.
&nbsp;     * @return A lazily initialized value of the {@code encodingInstantiator} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Instantiator encodingInstantiator() {
&nbsp;      if ((lazyInitBitmap &amp; ENCODING_INSTANTIATOR_LAZY_INIT_BIT) == 0) {
&nbsp;        synchronized (this) {
&nbsp;          if ((lazyInitBitmap &amp; ENCODING_INSTANTIATOR_LAZY_INIT_BIT) == 0) {
&nbsp;            this.encodingInstantiator = Objects.requireNonNull(super.encodingInstantiator(), &quot;encodingInstantiator&quot;);
&nbsp;            lazyInitBitmap |= ENCODING_INSTANTIATOR_LAZY_INIT_BIT;
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;      return encodingInstantiator;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Proto.Protoclass} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Protoclass instance
&nbsp;     */
&nbsp;    public static ImmutableProto.Protoclass copyOf(Proto.Protoclass instance) {
&nbsp;      if (instance instanceof ImmutableProto.Protoclass) {
&nbsp;        return (ImmutableProto.Protoclass) instance;
&nbsp;      }
&nbsp;      return ImmutableProto.Protoclass.builder()
&nbsp;          .environment(instance.environment())
&nbsp;          .sourceElement(instance.sourceElement())
&nbsp;          .packageOf(instance.packageOf())
&nbsp;          .declaringType(instance.declaringType())
&nbsp;          .kind(instance.kind())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableProto.Protoclass Protoclass}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableProto.Protoclass.builder()
&nbsp;     *    .environment(org.immutables.value.processor.meta.Proto.Environment) // required {@link Proto.Protoclass#environment() environment}
&nbsp;     *    .sourceElement(javax.lang.model.element.Element) // required {@link Proto.Protoclass#sourceElement() sourceElement}
&nbsp;     *    .packageOf(org.immutables.value.processor.meta.Proto.DeclaringPackage) // required {@link Proto.Protoclass#packageOf() packageOf}
&nbsp;     *    .declaringType(org.immutables.value.processor.meta.Proto.DeclaringType) // optional {@link Proto.Protoclass#declaringType() declaringType}
&nbsp;     *    .kind(org.immutables.value.processor.meta.Proto.Protoclass.Kind) // required {@link Proto.Protoclass#kind() kind}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Protoclass builder
&nbsp;     */
&nbsp;    public static ImmutableProto.Protoclass.Builder builder() {
&nbsp;      return new ImmutableProto.Protoclass.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableProto.Protoclass Protoclass}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Proto.Protoclass&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_ENVIRONMENT = 0x1L;
&nbsp;      private static final long INIT_BIT_SOURCE_ELEMENT = 0x2L;
&nbsp;      private static final long INIT_BIT_PACKAGE_OF = 0x4L;
&nbsp;      private static final long INIT_BIT_KIND = 0x8L;
&nbsp;      private static final long OPT_BIT_DECLARING_TYPE = 0x1L;
&nbsp;      private long initBits = 0xfL;
&nbsp;      private long optBits;
&nbsp;
&nbsp;      private @Nullable Proto.Environment environment;
&nbsp;      private @Nullable Element sourceElement;
&nbsp;      private @Nullable Proto.DeclaringPackage packageOf;
&nbsp;      private Optional&lt;Proto.DeclaringType&gt; declaringType = Optional.absent();
&nbsp;      private @Nullable Proto.Protoclass.Kind kind;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Protoclass#environment() environment} attribute.
&nbsp;       * @param environment The value for environment 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder environment(Proto.Environment environment) {
&nbsp;        checkNotIsSet(environmentIsSet(), &quot;environment&quot;);
&nbsp;        this.environment = Objects.requireNonNull(environment, &quot;environment&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ENVIRONMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Protoclass#sourceElement() sourceElement} attribute.
&nbsp;       * @param sourceElement The value for sourceElement 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder sourceElement(Element sourceElement) {
&nbsp;        checkNotIsSet(sourceElementIsSet(), &quot;sourceElement&quot;);
&nbsp;        this.sourceElement = Objects.requireNonNull(sourceElement, &quot;sourceElement&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_SOURCE_ELEMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Protoclass#packageOf() packageOf} attribute.
&nbsp;       * @param packageOf The value for packageOf 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder packageOf(Proto.DeclaringPackage packageOf) {
&nbsp;        checkNotIsSet(packageOfIsSet(), &quot;packageOf&quot;);
&nbsp;        this.packageOf = Objects.requireNonNull(packageOf, &quot;packageOf&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_PACKAGE_OF;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Proto.Protoclass#declaringType() declaringType} to declaringType.
&nbsp;       * @param declaringType The value for declaringType
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaringType(Proto.DeclaringType declaringType) {
&nbsp;        checkNotIsSet(declaringTypeIsSet(), &quot;declaringType&quot;);
&nbsp;        this.declaringType = Optional.of(declaringType);
&nbsp;        optBits |= OPT_BIT_DECLARING_TYPE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Proto.Protoclass#declaringType() declaringType} to declaringType.
&nbsp;       * @param declaringType The value for declaringType
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaringType(Optional&lt;? extends Proto.DeclaringType&gt; declaringType) {
&nbsp;        checkNotIsSet(declaringTypeIsSet(), &quot;declaringType&quot;);
&nbsp;        this.declaringType = (Optional&lt;Proto.DeclaringType&gt;) declaringType;
&nbsp;        optBits |= OPT_BIT_DECLARING_TYPE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Proto.Protoclass#kind() kind} attribute.
&nbsp;       * @param kind The value for kind 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder kind(Proto.Protoclass.Kind kind) {
&nbsp;        checkNotIsSet(kindIsSet(), &quot;kind&quot;);
&nbsp;        this.kind = Objects.requireNonNull(kind, &quot;kind&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_KIND;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableProto.Protoclass Protoclass}.
&nbsp;       * @return An immutable instance of Protoclass
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableProto.Protoclass build() {
&nbsp;        checkRequiredAttributes();
&nbsp;        return new ImmutableProto.Protoclass(environment, sourceElement, packageOf, declaringType, kind);
&nbsp;      }
&nbsp;
&nbsp;      private boolean declaringTypeIsSet() {
&nbsp;        return (optBits &amp; OPT_BIT_DECLARING_TYPE) != 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean environmentIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_ENVIRONMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean sourceElementIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_SOURCE_ELEMENT) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean packageOfIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_PACKAGE_OF) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean kindIsSet() {
&nbsp;        return (initBits &amp; INIT_BIT_KIND) == 0;
&nbsp;      }
&nbsp;
&nbsp;      private static void checkNotIsSet(boolean isSet, String name) {
&nbsp;        if (isSet) throw new IllegalStateException(&quot;Builder of Protoclass is strict, attribute is already set: &quot;.concat(name));
&nbsp;      }
&nbsp;
&nbsp;      private void checkRequiredAttributes() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (!environmentIsSet()) attributes.add(&quot;environment&quot;);
&nbsp;        if (!sourceElementIsSet()) attributes.add(&quot;sourceElement&quot;);
&nbsp;        if (!packageOfIsSet()) attributes.add(&quot;packageOf&quot;);
&nbsp;        if (!kindIsSet()) attributes.add(&quot;kind&quot;);
&nbsp;        return &quot;Cannot build Protoclass, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
