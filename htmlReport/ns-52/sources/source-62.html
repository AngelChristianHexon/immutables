


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ValueType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: ValueType (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ValueType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/213)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/612)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/768)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ValueType$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$1Collector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$FuncData</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$FuncData$BoundElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$HasJdkKind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$NonAuxiliary</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$Serialization</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$ToConstructorArgumentOrder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$UnderrideMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueType$ValidationMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/238)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/673)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/858)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2013-2018 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Predicate;
&nbsp;import com.google.common.base.Predicates;
&nbsp;import com.google.common.base.Splitter;
&nbsp;import com.google.common.collect.FluentIterable;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableListMultimap;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Ordering;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.Parameterizable;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.element.VariableElement;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import org.immutables.generator.Output;
&nbsp;import org.immutables.generator.SourceExtraction;
&nbsp;import org.immutables.generator.TypeHierarchyCollector;
&nbsp;import org.immutables.value.processor.encode.SourceStructureGet;
&nbsp;import org.immutables.value.processor.encode.TypeExtractor;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.AnnotationInjection;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.InjectAnnotation.Where;
&nbsp;import org.immutables.value.processor.meta.Constitution.AppliedNameForms;
&nbsp;import org.immutables.value.processor.meta.Constitution.InnerBuilderDefinition;
&nbsp;import org.immutables.value.processor.meta.Constitution.InnerModifiableDefinition;
&nbsp;import org.immutables.value.processor.meta.Constitution.NameForms;
&nbsp;import org.immutables.value.processor.meta.Proto.DeclaringType;
&nbsp;import org.immutables.value.processor.meta.Proto.Environment;
&nbsp;import org.immutables.value.processor.meta.Proto.JacksonMode;
&nbsp;import org.immutables.value.processor.meta.Proto.Protoclass;
&nbsp;import org.immutables.value.processor.meta.Reporter.About;
&nbsp;import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;
&nbsp;import org.immutables.value.processor.meta.TypeStringProvider.SourceExtractionCache;
&nbsp;
<b class="nc">&nbsp;public final class ValueType extends TypeIntrospectionBase implements HasStyleInfo, SourceExtractionCache {</b>
&nbsp;  private static final String SERIAL_VERSION_FIELD_NAME = &quot;serialVersionUID&quot;;
&nbsp;  public Element element;
<b class="nc">&nbsp;  public List&lt;ValueAttribute&gt; attributes = Lists.newArrayList();</b>
&nbsp;  public boolean isHashCodeDefined;
&nbsp;  public boolean isEqualToDefined;
&nbsp;  public boolean isHashCodeFinal;
&nbsp;  public boolean isEqualToFinal;
&nbsp;  public boolean isToStringDefined;
&nbsp;  public Constitution constitution;
&nbsp;  public int defaultAttributesCount;
&nbsp;  public int derivedAttributesCount;
&nbsp;
&nbsp;  private RepositoryModel repositoryModel;
&nbsp;
&nbsp;  public Generics generics() {
<b class="nc">&nbsp;    return constitution.generics();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Should be called when it is known that there type adapters generation provided.
&nbsp;   * @return the type adapters annotation
&nbsp;   */
&nbsp;  public GsonMirrors.TypeAdapters gsonTypeAdapters() {
<b class="nc">&nbsp;    return constitution.protoclass().gsonTypeAdapters().get();</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable CharSequence sourceHeader;
&nbsp;
&nbsp;  public CharSequence sourceHeader() {
<b class="nc">&nbsp;    if (this.sourceHeader == null) {</b>
<b class="nc">&nbsp;      String noImportsPragma = ImportRewriteDisabler.shouldDisableFor(this)</b>
<b class="nc">&nbsp;          ? Output.NO_IMPORTS</b>
<b class="nc">&nbsp;          : &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;      if (style().headerComments()) {</b>
<b class="nc">&nbsp;        Optional&lt;DeclaringType&gt; declaringType = constitution.protoclass().declaringType();</b>
<b class="nc">&nbsp;        if (declaringType.isPresent()) {</b>
<b class="nc">&nbsp;          CharSequence headerComments = declaringType.get().associatedTopLevel().headerComments();</b>
<b class="nc">&nbsp;          return !noImportsPragma.isEmpty()</b>
<b class="nc">&nbsp;              ? new StringBuilder(noImportsPragma).append(&#39;\n&#39;).append(headerComments)</b>
<b class="nc">&nbsp;              : headerComments;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      this.sourceHeader = noImportsPragma;</b>
&nbsp;    }
<b class="nc">&nbsp;    return sourceHeader;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  public String typeMoreObjects() {
<b class="nc">&nbsp;    return constitution.protoclass().environment().typeMoreObjects();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasDefaultAttributes() {
<b class="nc">&nbsp;    return defaultAttributesCount &gt; 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasOptionalAttributes() {
<b class="nc">&nbsp;    for (ValueAttribute attribute : attributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isOptionalType()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasOptionalConstructorArguments() {
<b class="nc">&nbsp;    for (ValueAttribute attribute : getConstructorArguments()) {</b>
<b class="nc">&nbsp;      if (attribute.isOptionalType()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseOptionalAcceptNullableConstructor() {
<b class="nc">&nbsp;    return style().optionalAcceptNullable()</b>
<b class="nc">&nbsp;        &amp;&amp; hasOptionalConstructorArguments();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasEncodingAttributes() {
<b class="nc">&nbsp;    for (ValueAttribute a : attributes()) {</b>
<b class="nc">&nbsp;      if (a.isEncoding()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasEncodingValueOrVirtualFields() {
<b class="nc">&nbsp;    for (ValueAttribute a : attributes()) {</b>
<b class="nc">&nbsp;      if (a.isEncoding() &amp;&amp; a.instantiation.hasValueOrVirtualFields()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDeferCollectionAllocation() {
<b class="nc">&nbsp;    return style().deferCollectionAllocation() &amp;&amp; !isUseStrictBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean detectAttributeBuilders() {
<b class="nc">&nbsp;    return style().attributeBuilderDetection();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasDerivedAttributes() {
<b class="nc">&nbsp;    return derivedAttributesCount &gt; 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public TypeNames names() {
<b class="nc">&nbsp;    return constitution.names();</b>
&nbsp;  }
&nbsp;
&nbsp;  public AppliedNameForms factoryOf() {
<b class="nc">&nbsp;    return constitution.factoryOf();</b>
&nbsp;  }
&nbsp;
&nbsp;  public AppliedNameForms factoryCopyOf() {
<b class="nc">&nbsp;    return constitution.factoryCopyOf();</b>
&nbsp;  }
&nbsp;
&nbsp;  public AppliedNameForms factoryInstance() {
<b class="nc">&nbsp;    return constitution.factoryInstance();</b>
&nbsp;  }
&nbsp;
&nbsp;  public AppliedNameForms factoryBuilder() {
<b class="nc">&nbsp;    return constitution.factoryBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public Protoclass.Kind kind() {
<b class="nc">&nbsp;    return constitution.protoclass().kind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeBuilder() {
<b class="nc">&nbsp;    return constitution.typeBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeBuilderImpl() {
<b class="nc">&nbsp;    return constitution.typeImplementationBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeAbstract() {
<b class="nc">&nbsp;    return constitution.typeAbstract();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeValue() {
<b class="nc">&nbsp;    return constitution.typeValue();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeDocument() {
<b class="nc">&nbsp;    return constitution.typeDocument();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeImmutable() {
<b class="nc">&nbsp;    return constitution.typeImmutable();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeModifiable() {
<b class="nc">&nbsp;    return constitution.typeModifiable();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeEnclosing() {
<b class="nc">&nbsp;    return constitution.typeEnclosing();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typeWith() {
<b class="nc">&nbsp;    return constitution.typeWith();</b>
&nbsp;  }
&nbsp;
&nbsp;  public NameForms typePreferablyAbstract() {
<b class="nc">&nbsp;    return constitution.typePreferablyAbstract();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseBuilder() {
<b class="nc">&nbsp;    return immutableFeatures.builder() || constitution.innerBuilder().isExtending;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isImplementationHidden() {
<b class="nc">&nbsp;    return constitution.isImplementationHidden();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateTransformer() {
<b class="nc">&nbsp;    return constitution.protoclass().isTransformer();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateVisitor() {
<b class="nc">&nbsp;    return constitution.protoclass().isVisitor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateAst() {
<b class="nc">&nbsp;    return constitution.protoclass().isAst();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJdkOnly() {
<b class="nc">&nbsp;    return style().jdkOnly() || noGuavaInClasspath() || isGenerateJdk9();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJdk9() {
<b class="nc">&nbsp;    return style().jdk9Collections()</b>
<b class="nc">&nbsp;        &amp;&amp; constitution.protoclass().environment().hasJava9Collections();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateBuildOrThrow() {
<b class="nc">&nbsp;    return !style().buildOrThrow().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateCanBuild() {
<b class="nc">&nbsp;    return !style().canBuild().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateWithUnaryOperator() {
<b class="nc">&nbsp;    return !style().withUnaryOperator().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isBeanFriendlyModifiable() {
<b class="nc">&nbsp;    return style().beanFriendlyModifiables();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean noGuavaInClasspath() {
<b class="nc">&nbsp;    return !constitution.protoclass().environment().hasGuavaLib();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSimpleReadResolve() {
<b class="nc">&nbsp;    return serial.isSimple()</b>
<b class="nc">&nbsp;        &amp;&amp; (isUseValidation() || isUseSingletonOnly() || (isUsePrehashed() &amp;&amp; isUseCopyConstructor()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isOptionalAcceptNullable() {
<b class="nc">&nbsp;    return style().optionalAcceptNullable();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  public Long serialVersionUID() {
<b class="nc">&nbsp;    Protoclass p = constitution.protoclass();</b>
<b class="nc">&nbsp;    if (p.serialVersion().isPresent()) {</b>
<b class="nc">&nbsp;      return p.serialVersion().get();</b>
&nbsp;    }
<b class="nc">&nbsp;    return serial.isEnabled()</b>
<b class="nc">&nbsp;        ? findSerialVersionUID()</b>
<b class="nc">&nbsp;        : null;</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;CharSequence&gt; constructorAnnotations;
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getConstructorAnnotations() {
<b class="nc">&nbsp;    if (constructorAnnotations == null) {</b>
<b class="nc">&nbsp;      List&lt;ExecutableElement&gt; constructors = ElementFilter.constructorsIn(element.getEnclosedElements());</b>
<b class="nc">&nbsp;      for (ExecutableElement c : constructors) {</b>
<b class="nc">&nbsp;        if (c.getParameters().isEmpty()) {</b>
<b class="nc">&nbsp;          Set&lt;Modifier&gt; modifiers = c.getModifiers();</b>
<b class="nc">&nbsp;          if (modifiers.contains(Modifier.PRIVATE)) {</b>
<b class="nc">&nbsp;            report()</b>
<b class="nc">&nbsp;                .withElement(c)</b>
<b class="nc">&nbsp;                .error(&quot;Constructor in an abstract value type should not be private&quot;);</b>
&nbsp;          }
<b class="nc">&nbsp;          constructorAnnotations =</b>
<b class="nc">&nbsp;              Annotations.getAnnotationLines(</b>
&nbsp;                  c,
<b class="nc">&nbsp;                  Collections.&lt;String&gt;emptySet(),</b>
&nbsp;                  true,
&nbsp;                  false,
&nbsp;                  ElementType.CONSTRUCTOR,
<b class="nc">&nbsp;                  newTypeStringResolver(),</b>
&nbsp;                  null);
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      if (constructorAnnotations == null) {</b>
<b class="nc">&nbsp;        for (ExecutableElement c : constructors) {</b>
<b class="nc">&nbsp;          report()</b>
<b class="nc">&nbsp;              .withElement(c)</b>
<b class="nc">&nbsp;              .error(&quot;Constructor should not have parameters in an abstract value type to be extended&quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        constructorAnnotations = ImmutableList.of();</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return constructorAnnotations;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getBuilderAnnotations() {
<b class="nc">&nbsp;    Optional&lt;DeclaringType&gt; declaringType = constitution.protoclass().declaringType();</b>
<b class="nc">&nbsp;    if (declaringType.isPresent() &amp;&amp; declaringType.get().jacksonSerializeMode() == JacksonMode.BUILDER) {</b>
<b class="nc">&nbsp;      return Annotations.getAnnotationLines(</b>
&nbsp;          element,
<b class="nc">&nbsp;          Collections.&lt;String&gt;emptySet(),</b>
&nbsp;          true,
&nbsp;          ElementType.TYPE,
<b class="nc">&nbsp;          newTypeStringResolver(),</b>
&nbsp;          null);
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Long findSerialVersionUID() {
<b class="nc">&nbsp;    for (VariableElement field : ElementFilter.fieldsIn(element.getEnclosedElements())) {</b>
<b class="nc">&nbsp;      if (field.getSimpleName().contentEquals(SERIAL_VERSION_FIELD_NAME)</b>
<b class="nc">&nbsp;          &amp;&amp; field.asType().getKind() == TypeKind.LONG) {</b>
<b class="nc">&nbsp;        return (Long) field.getConstantValue();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseValidation() {
<b class="nc">&nbsp;    if (isGenerateOrdinalValue() || !validationMethods.isEmpty() || isUseJavaValidationApi()) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isUseSingletonOnly()) {</b>
&nbsp;      // We don&#39;t use validation method just to intern singleton-only.
&nbsp;      // but only if we are not validated by method or generating ordinal value.
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isUseSingleton()) {</b>
<b class="nc">&nbsp;      return serial.isEnabled()</b>
<b class="nc">&nbsp;          || !useAttributelessSingleton();</b>
&nbsp;    }
<b class="nc">&nbsp;    return isUseInterned();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJacksonMapped() {
<b class="nc">&nbsp;    return constitution.protoclass().isJacksonSerialized();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJacksonProperties() {
<b class="nc">&nbsp;    return constitution.protoclass().isJacksonProperties();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJacksonIngoreFields() {
<b class="nc">&nbsp;    return isGenerateJacksonProperties()</b>
<b class="nc">&nbsp;        &amp;&amp; style().forceJacksonIgnoreFields();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJacksonDeserialized() {
<b class="nc">&nbsp;    return constitution.protoclass().isJacksonDeserialized();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJacksonJsonTypeInfo() {
<b class="nc">&nbsp;    if (constitution.protoclass().isJacksonJsonTypeInfo()) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    for (TypeElement t : implementedInterfaces()) {</b>
<b class="nc">&nbsp;      if (Proto.isJacksonJsonTypeInfoAnnotated(t)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    for (TypeElement t : extendedClasses()) {</b>
<b class="nc">&nbsp;      if (Proto.isJacksonJsonTypeInfoAnnotated(t)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getTopSimple() {
<b class="nc">&nbsp;    if (enclosingValue != null) {</b>
<b class="nc">&nbsp;      return enclosingValue.typeEnclosing().simple();</b>
&nbsp;    }
<b class="nc">&nbsp;    if (constitution.isOutsideBuilder() || kind().isFactory()) {</b>
<b class="nc">&nbsp;      return typeBuilder().simple();</b>
&nbsp;    }
<b class="nc">&nbsp;    return typeImmutable().simple();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isTopLevel() {
<b class="nc">&nbsp;    return !kind().isNested();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateCriteria() {
<b class="nc">&nbsp;    return constitution.protoclass().criteria().isPresent();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Check if criteria repository should be generated. Usually means {@code @Criteria.Repository}
&nbsp;   * annotation is present.
&nbsp;   * This type of repository is different from (legacy) mongo repository identified by
&nbsp;   * {@code @Mongo.Repository}
&nbsp;   * (see {@link #isGenerateRepository()}.
&nbsp;   */
&nbsp;  public boolean isGenerateCriteriaRepository() {
<b class="nc">&nbsp;    return constitution.protoclass().criteriaRepository().isPresent();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Check if mongo repository should be generated (for annotation {@code @Mongo.Repository}).
&nbsp;   * For criteria repository see {@link #isGenerateCriteriaRepository()}
&nbsp;   */
&nbsp;  public boolean isGenerateRepository() {
<b class="nc">&nbsp;    return constitution.protoclass().repository().isPresent();</b>
&nbsp;  }
&nbsp;
&nbsp;  public MongoMirrors.Repository getRepository() {
<b class="nc">&nbsp;    return constitution.protoclass().repository().get();</b>
&nbsp;  }
&nbsp;
&nbsp;  public RepositoryModel getCriteriaRepository() {
<b class="nc">&nbsp;    if (repositoryModel == null) {</b>
<b class="nc">&nbsp;      repositoryModel = new RepositoryModel(this);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return repositoryModel;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAnnotationType() {
<b class="nc">&nbsp;    return element.getKind() == ElementKind.ANNOTATION_TYPE;</b>
&nbsp;  }
&nbsp;
&nbsp;  private CaseStructure caseStructure;
&nbsp;
&nbsp;  public CaseStructure getCases() {
<b class="nc">&nbsp;    if (caseStructure == null) {</b>
<b class="nc">&nbsp;      caseStructure = new CaseStructure(allKnownValuesInContext());</b>
&nbsp;    }
<b class="nc">&nbsp;    return caseStructure;</b>
&nbsp;  }
&nbsp;
&nbsp;  public CaseStructure getCasesContextual() {
<b class="nc">&nbsp;    if (enclosingValue != null) {</b>
<b class="nc">&nbsp;      return enclosingValue.getCases();</b>
&nbsp;    }
<b class="nc">&nbsp;    return getCases();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Iterable&lt;ValueType&gt; allKnownValuesInContext() {
<b class="nc">&nbsp;    List&lt;ValueType&gt; values = Lists.newArrayList(nested);</b>
&nbsp;
<b class="nc">&nbsp;    Environment environment = constitution.protoclass().environment();</b>
<b class="nc">&nbsp;    Optional&lt;TreesIncludeMirror&gt; include = constitution.protoclass().getTreesInclude();</b>
<b class="nc">&nbsp;    if (include.isPresent()) {</b>
<b class="nc">&nbsp;      for (Protoclass p : environment.protoclassesFrom(includedElements(include.get()))) {</b>
<b class="nc">&nbsp;        values.add(environment.composeValue(p));</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return values;</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;Element&gt; includedElements(TreesIncludeMirror include) {
<b class="nc">&nbsp;    List&lt;Element&gt; includedElements = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (TypeMirror mirror : include.valueMirror()) {</b>
<b class="nc">&nbsp;      if (mirror.getKind() == TypeKind.DECLARED) {</b>
<b class="nc">&nbsp;        includedElements.add(((DeclaredType) mirror).asElement());</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return includedElements;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; passedAnnotations() {
<b class="nc">&nbsp;    return Annotations.getAnnotationLines(</b>
&nbsp;        element,
<b class="nc">&nbsp;        Sets.union(</b>
<b class="nc">&nbsp;            style().passAnnotationsNames(),</b>
<b class="nc">&nbsp;            style().additionalJsonAnnotationsNames()),</b>
&nbsp;        false,
&nbsp;        ElementType.TYPE,
<b class="nc">&nbsp;        newTypeStringResolver(),</b>
&nbsp;        null);
&nbsp;  }
&nbsp;
&nbsp;  private ImportsTypeStringResolver newTypeStringResolver() {
<b class="nc">&nbsp;    @Nullable DeclaringType type = constitution.protoclass().declaringType().orNull();</b>
<b class="nc">&nbsp;    return new ImportsTypeStringResolver(type, type);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Iterable&lt;ValueType&gt; allValues() {
<b class="nc">&nbsp;    List&lt;ValueType&gt; values = Lists.newArrayList();</b>
<b class="nc">&nbsp;    if (kind().isValue()) {</b>
<b class="nc">&nbsp;      values.add(this);</b>
&nbsp;    }
<b class="nc">&nbsp;    values.addAll(nested);</b>
<b class="nc">&nbsp;    return values;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public List&lt;ValueType&gt; nested = Collections.emptyList();</b>
&nbsp;
&nbsp;  @Nullable
&nbsp;  ValueType enclosingValue;
&nbsp;
&nbsp;  public void addNested(ValueType nested) {
<b class="nc">&nbsp;    if (this.nested.isEmpty()) {</b>
<b class="nc">&nbsp;      this.nested = Lists.newArrayList();</b>
&nbsp;    }
<b class="nc">&nbsp;    this.nested.add(nested);</b>
<b class="nc">&nbsp;    nested.enclosingValue = this;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public ImmutableList&lt;ValidationMethod&gt; validationMethods = ImmutableList.of();</b>
&nbsp;
&nbsp;  public static class ValidationMethod {
&nbsp;    public final String name;
&nbsp;    public final boolean normalize;
&nbsp;
<b class="nc">&nbsp;    ValidationMethod(String name, boolean normalize) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.normalize = normalize;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void addNormalizeMethod(String name, boolean normalize) {
<b class="nc">&nbsp;    validationMethods = ImmutableList.&lt;ValidationMethod&gt;builder()</b>
<b class="nc">&nbsp;        .add(new ValidationMethod(name, normalize))</b>
<b class="nc">&nbsp;        .addAll(validationMethods)</b>
<b class="nc">&nbsp;        .build();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isImplementing() {
<b class="nc">&nbsp;    return element.getKind() == ElementKind.INTERFACE</b>
<b class="nc">&nbsp;        || element.getKind() == ElementKind.ANNOTATION_TYPE;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String $$package() {
<b class="nc">&nbsp;    return constitution.implementationPackage();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String name() {
<b class="nc">&nbsp;    return names().raw;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateOrdinalValue() {
<b class="nc">&nbsp;    return isOrdinalValue();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateSafeDerived() {
<b class="nc">&nbsp;    boolean moreThanOne = defaultAttributesCount + derivedAttributesCount &gt; 1;</b>
<b class="nc">&nbsp;    return !isAnnotationType()</b>
<b class="nc">&nbsp;        &amp;&amp; (hasEncodingAttributes() || (moreThanOne &amp;&amp; !style().unsafeDefaultAndDerived()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseConstructorOnly() {
<b class="nc">&nbsp;    return isUseConstructor() &amp;&amp; !isUseBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public ValueImmutableInfo immutableFeatures;
&nbsp;
&nbsp;  public boolean isGenerateWithInterface() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    return implementedInterfacesNames.contains(typeWith().relative());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseCopyMethods() {
<b class="nc">&nbsp;    return !getSettableAttributes().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; (isGenerateWithInterface()</b>
<b class="nc">&nbsp;        || (immutableFeatures.copy()</b>
<b class="nc">&nbsp;        &amp;&amp; !constitution.isImplementationHidden()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseCopyConstructor() {
<b class="nc">&nbsp;    return immutableFeatures.copy()</b>
<b class="nc">&nbsp;        &amp;&amp; (isUseConstructor() || isUseBuilder());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSingleton() {
<b class="nc">&nbsp;    return immutableFeatures.singleton()</b>
<b class="nc">&nbsp;        || useAttributelessSingleton()</b>
<b class="nc">&nbsp;        || useSingletonNoOtherWay();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseInterned() {
<b class="nc">&nbsp;    return generics().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; immutableFeatures.intern()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseSingletonOnly();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Means object hashcode is cached at some point. Either lazily (on first access)
&nbsp;   * or eagerly (during construction).
&nbsp;   * @see #isUseLazyhash()
&nbsp;   * @see #isUsePrehashed()
&nbsp;   */
&nbsp;  public boolean isCacheHash() {
<b class="nc">&nbsp;    return isUseLazyhash() || isUsePrehashed();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseLazyhash() {
&nbsp;    // lazyhash and prehash are mutually exclusive
<b class="nc">&nbsp;    return immutableFeatures.lazyhash() &amp;&amp; !isUsePrehashed();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUsePrehashed() {
<b class="nc">&nbsp;    return immutableFeatures.prehash()</b>
<b class="nc">&nbsp;        &amp;&amp; !isGenerateNoargConstructor()</b>
<b class="nc">&nbsp;        &amp;&amp; !getEquivalenceAttributes().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; !simpleSerializableWithoutCopy();</b>
&nbsp;  }
&nbsp;
&nbsp;  boolean simpleSerializableWithoutCopy() {
<b class="nc">&nbsp;    return serial.isSimple() &amp;&amp; !isUseCopyConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public InnerBuilderDefinition getInnerBuilder() {
<b class="nc">&nbsp;    return constitution.innerBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public InnerModifiableDefinition getInnerModifiable() {
<b class="nc">&nbsp;    return constitution.innerModifiable();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getDocumentName() {
<b class="nc">&nbsp;    Optional&lt;RepositoryMirror&gt; repositoryAnnotation = RepositoryMirror.find(element);</b>
<b class="nc">&nbsp;    if (repositoryAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;      RepositoryMirror mirror = repositoryAnnotation.get();</b>
<b class="nc">&nbsp;      if (!mirror.collection().isEmpty()) {</b>
<b class="nc">&nbsp;        return mirror.collection();</b>
<b class="nc">&nbsp;      } else if (!mirror.value().isEmpty()) {</b>
<b class="nc">&nbsp;        return mirror.value();</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  public ValueAttribute getIdAttribute() {
<b class="nc">&nbsp;    for (ValueAttribute attribute : getImplementedAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isIdAttribute()) {</b>
<b class="nc">&nbsp;        return attribute;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseReferenceEquality() {
<b class="nc">&nbsp;    if (isAnnotationType()) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    return isUseStrongInterned()</b>
<b class="nc">&nbsp;        || isUseSingletonOnly()</b>
<b class="nc">&nbsp;        || useAttributelessSingleton()</b>
<b class="nc">&nbsp;        || isGenerateOrdinalValue();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseStrongInterned() {
<b class="nc">&nbsp;    return isUseInterned() &amp;&amp; !style().weakInterning();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseWeakInterned() {
<b class="nc">&nbsp;    return isUseInterned() &amp;&amp; style().weakInterning();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseEqualTo() {
<b class="nc">&nbsp;    if (isGenerateOrdinalValue()) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isUseSingletonOnly()) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isUseInterned() || isUseSingleton()) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    return !isEqualToDefined;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSingletonOnly() {
<b class="nc">&nbsp;    return isUseSingleton()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseConstructor()</b>
<b class="nc">&nbsp;        &amp;&amp; getWithSettableAfterConstruction().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSingletonOnlyForConstruction() {
<b class="nc">&nbsp;    return isUseSingleton()</b>
<b class="nc">&nbsp;        &amp;&amp; !useAttributelessSingleton()</b>
<b class="nc">&nbsp;        &amp;&amp; useSingletonNoOtherWay();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean useAttributelessSingleton() {
<b class="nc">&nbsp;    return style().attributelessSingleton()</b>
<b class="nc">&nbsp;        &amp;&amp; getSettableAttributes().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean useSingletonNoOtherWay() {
<b class="nc">&nbsp;    return !isUseBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseConstructor()</b>
<b class="nc">&nbsp;        &amp;&amp; getMandatoryAttributes().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseConstructor() {
<b class="nc">&nbsp;    return !getConstructorArguments().isEmpty()</b>
<b class="nc">&nbsp;        || (getSettableAttributes().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !immutableFeatures.singleton()</b>
<b class="nc">&nbsp;        &amp;&amp; !style().attributelessSingleton());  // don&#39;t use !isUseSingleton() to avoid unresolvable recursion</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean requiresAlternativeStrictConstructor() {
<b class="nc">&nbsp;    for (ValueAttribute constructor : getConstructorArguments()) {</b>
<b class="nc">&nbsp;      if (constructor.requiresAlternativeStrictConstructor()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private Set&lt;ValueAttribute&gt; constructorArguments;
&nbsp;
&nbsp;  public Set&lt;ValueAttribute&gt; getConstructorArguments() {
<b class="nc">&nbsp;    if (constructorArguments == null) {</b>
<b class="nc">&nbsp;      constructorArguments = computeConstructorArguments();</b>
<b class="nc">&nbsp;      validateConstructorParameters(constructorArguments);</b>
&nbsp;    }
<b class="nc">&nbsp;    return constructorArguments;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getWithSettableAfterConstruction() {
<b class="nc">&nbsp;    if (isUseCopyMethods()) {</b>
<b class="nc">&nbsp;      return getConstructorExcluded();</b>
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private List&lt;ValueAttribute&gt; constructorExcluded;
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getConstructorExcluded() {
<b class="nc">&nbsp;    if (constructorExcluded == null) {</b>
<b class="nc">&nbsp;      constructorExcluded = FluentIterable.from(getSettableAttributes())</b>
<b class="nc">&nbsp;          .filter(Predicates.not(Predicates.in(getConstructorArguments())))</b>
<b class="nc">&nbsp;          .toList();</b>
&nbsp;    }
<b class="nc">&nbsp;    return constructorExcluded;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getConstructableAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; attributes = Lists.newArrayList(getConstructorArguments());</b>
<b class="nc">&nbsp;    attributes.addAll(getWithSettableAfterConstruction());</b>
<b class="nc">&nbsp;    return attributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean jacksonValueInitialized;
&nbsp;  private @Nullable ValueAttribute jacksonValue;
&nbsp;
&nbsp;  public @Nullable ValueAttribute getJacksonValue() {
<b class="nc">&nbsp;    if (!jacksonValueInitialized) {</b>
<b class="nc">&nbsp;      jacksonValueInitialized = true;</b>
<b class="nc">&nbsp;      if (!isGenerateJacksonMapped()) {</b>
<b class="nc">&nbsp;        return jacksonValue;</b>
&nbsp;      }
<b class="nc">&nbsp;      for (ValueAttribute v : getSettableAttributes()) {</b>
<b class="nc">&nbsp;        if (v.jacksonValue) {</b>
<b class="nc">&nbsp;          if (jacksonValue == null) {</b>
<b class="nc">&nbsp;            if (!v.thereAreNoOtherMandatoryAttributes()) {</b>
<b class="nc">&nbsp;              v.report()</b>
<b class="nc">&nbsp;                  .error(&quot;Cannot generate proper @JsonCreator for @JsonValue,&quot;</b>
&nbsp;                      + &quot; other mandatory attributes are present&quot;);
<b class="nc">&nbsp;              return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            jacksonValue = v;</b>
&nbsp;          } else {
<b class="nc">&nbsp;            v.report()</b>
<b class="nc">&nbsp;                .warning(About.INCOMPAT,</b>
&nbsp;                    &quot;Multiple attributes annotated with @JsonValue on the same type.&quot;
&nbsp;                        + &quot; There should be only one to consider for mapping.&quot;);
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    }
<b class="nc">&nbsp;    return jacksonValue;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void validateConstructorParameters(Set&lt;ValueAttribute&gt; parameters) {
<b class="nc">&nbsp;    if (kind().isValue() &amp;&amp; !parameters.isEmpty()) {</b>
<b class="nc">&nbsp;      Set&lt;Element&gt; definingElements = Sets.newHashSet();</b>
<b class="nc">&nbsp;      for (ValueAttribute attribute : parameters) {</b>
<b class="nc">&nbsp;        definingElements.add(attribute.element.getEnclosingElement());</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      if (definingElements.size() != 1) {</b>
<b class="nc">&nbsp;        report().warning(About.SUBTYPE,</b>
&nbsp;            &quot;Constructor parameters should be better defined on the same level of inheritance hierarchy, &quot;
&nbsp;                + &quot; otherwise generated constructor API would be unstable: &quot;
&nbsp;                + &quot; parameter list can change the order of arguments.&quot;
&nbsp;                + &quot; It is better redeclare (override) each inherited&quot;
&nbsp;                + &quot; attribute parameter in this abstract value type to avoid this warning.&quot;
&nbsp;                + &quot; Or better have constructor parameters defined by only single supertype.&quot;);
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;ValueAttribute&gt; computeConstructorArguments() {
<b class="nc">&nbsp;    return ImmutableSet.copyOf(</b>
<b class="nc">&nbsp;        FluentIterable.from(getSettableAttributes())</b>
<b class="nc">&nbsp;            .filter(Predicates.compose(Predicates.not(Predicates.equalTo(-1)), ToConstructorArgumentOrder.FUNCTION))</b>
<b class="nc">&nbsp;            .toSortedList(Ordering.natural().onResultOf(ToConstructorArgumentOrder.FUNCTION)));</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getConstructorOmited() {
<b class="nc">&nbsp;    return FluentIterable.from(getImplementedAttributes())</b>
<b class="nc">&nbsp;        .filter(Predicates.not(Predicates.in(getConstructorArguments())))</b>
<b class="nc">&nbsp;        .toList();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private enum NonAuxiliary implements Predicate&lt;ValueAttribute&gt; {</b>
<b class="nc">&nbsp;    PREDICATE;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean apply(ValueAttribute input) {
<b class="nc">&nbsp;      return !input.isAuxiliary();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private enum ToConstructorArgumentOrder implements Function&lt;ValueAttribute, Integer&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Integer apply(ValueAttribute input) {
<b class="nc">&nbsp;      return input.getConstructorParameterOrder();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private List&lt;ValueAttribute&gt; settableAttributes;
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getSettableAttributes() {
<b class="nc">&nbsp;    if (settableAttributes == null) {</b>
<b class="nc">&nbsp;      settableAttributes = attributes()</b>
<b class="nc">&nbsp;          .filter(Predicates.or(</b>
<b class="nc">&nbsp;              ValueAttributeFunctions.isGenerateAbstract(),</b>
<b class="nc">&nbsp;              ValueAttributeFunctions.isGenerateDefault()))</b>
<b class="nc">&nbsp;          .toList();</b>
&nbsp;    }
<b class="nc">&nbsp;    return settableAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private Set&lt;ValueAttribute&gt; uniqueAttributeBuilderListAttributes;
&nbsp;
&nbsp;  public Set&lt;ValueAttribute&gt; getUniqueAttributeBuilderListAttributes() {
<b class="nc">&nbsp;    if (uniqueAttributeBuilderListAttributes == null) {</b>
<b class="nc">&nbsp;      uniqueAttributeBuilderListAttributes = FluentIterable.from(getSettableAttributes())</b>
<b class="nc">&nbsp;          .filter(ValueAttributeFunctions.isListType())</b>
<b class="nc">&nbsp;          .filter(ValueAttributeFunctions.isAttributeBuilder())</b>
<b class="nc">&nbsp;          .filter(ValueAttributeFunctions.uniqueOnAttributeBuilderDescriptor())</b>
<b class="nc">&nbsp;          .toSet();</b>
&nbsp;    }
<b class="nc">&nbsp;    return uniqueAttributeBuilderListAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private Set&lt;ValueAttribute&gt; uniqueNestedBuilderAttributes;
&nbsp;
&nbsp;  public Set&lt;ValueAttribute&gt; getUniqueAttributeBuilderAttributes() {
<b class="nc">&nbsp;    if (uniqueNestedBuilderAttributes == null) {</b>
<b class="nc">&nbsp;      uniqueNestedBuilderAttributes = FluentIterable.from(getSettableAttributes())</b>
<b class="nc">&nbsp;          .filter(ValueAttributeFunctions.isAttributeBuilder())</b>
<b class="nc">&nbsp;          .filter(ValueAttributeFunctions.uniqueOnAttributeBuilderDescriptor())</b>
<b class="nc">&nbsp;          .toSet();</b>
&nbsp;    }
<b class="nc">&nbsp;    return uniqueNestedBuilderAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getExcludableAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; excludables = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : attributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isGenerateAbstract &amp;&amp; (attribute.isContainerType() &amp;&amp; !attribute.isArrayType())) {</b>
<b class="nc">&nbsp;        excludables.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return excludables;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getMandatoryAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; mandatory = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isMandatory()) {</b>
<b class="nc">&nbsp;        mandatory.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return mandatory;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getMandatoryOrEncodingAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; mandatory = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isMandatory() || attribute.isEncoding()) {</b>
<b class="nc">&nbsp;        mandatory.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return mandatory;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getLazyAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; lazyAttributes = Lists.newArrayList();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : attributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isGenerateLazy) {</b>
<b class="nc">&nbsp;        lazyAttributes.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return lazyAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getAllAccessibleAttributes() {
<b class="nc">&nbsp;    return ImmutableList.&lt;ValueAttribute&gt;builder()</b>
<b class="nc">&nbsp;        .addAll(getImplementedAttributes())</b>
<b class="nc">&nbsp;        .addAll(getLazyAttributes())</b>
<b class="nc">&nbsp;        .build();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private List&lt;ValueAttribute&gt; implementedAttributes;
&nbsp;
&nbsp;  private FluentIterable&lt;ValueAttribute&gt; attributes() {
<b class="nc">&nbsp;    return FluentIterable.from(attributes);</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getMarshaledAttributes() {
<b class="nc">&nbsp;    ImmutableList.Builder&lt;ValueAttribute&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (ValueAttribute a : getImplementedAttributes()) {</b>
<b class="nc">&nbsp;      if (!a.isJsonIgnore() &amp;&amp; !a.isGsonOther()) {</b>
<b class="nc">&nbsp;        builder.add(a);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return builder.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getUnmarshaledAttributes() {
<b class="nc">&nbsp;    ImmutableList.Builder&lt;ValueAttribute&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (!a.isJsonIgnore() &amp;&amp; !a.isGsonOther()) {</b>
<b class="nc">&nbsp;        builder.add(a);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return builder.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private ImmutableList&lt;ValueAttribute&gt; allMarshalingAttributes;
&nbsp;  private TypeHierarchyCollector hierarchiCollector;
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; allMarshalingAttributes() {
<b class="nc">&nbsp;    if (allMarshalingAttributes == null) {</b>
<b class="nc">&nbsp;      class Collector {</b>
<b class="nc">&nbsp;        Map&lt;String, ValueAttribute&gt; byNames = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        ImmutableList&lt;ValueAttribute&gt; collect() {
<b class="nc">&nbsp;          addUnique(getMarshaledAttributes());</b>
<b class="nc">&nbsp;          addUnique(getUnmarshaledAttributes());</b>
<b class="nc">&nbsp;          return ImmutableList.copyOf(byNames.values());</b>
&nbsp;        }
&nbsp;
&nbsp;        void addUnique(List&lt;ValueAttribute&gt; attributes) {
<b class="nc">&nbsp;          for (ValueAttribute attribute : attributes) {</b>
<b class="nc">&nbsp;            String name = attribute.getMarshaledName();</b>
<b class="nc">&nbsp;            ValueAttribute existing = byNames.get(name);</b>
<b class="nc">&nbsp;            if (existing == null) {</b>
<b class="nc">&nbsp;              byNames.put(name, attribute);</b>
<b class="nc">&nbsp;            } else if (existing != attribute) {</b>
<b class="nc">&nbsp;              attribute.report()</b>
<b class="nc">&nbsp;                  .error(&quot;Attribute has duplicate marshaled name, check @%s annotation&quot;, NamedMirror.simpleName());</b>
&nbsp;            }
<b class="nc">&nbsp;          }</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      allMarshalingAttributes = new Collector().collect();</b>
&nbsp;    }
<b class="nc">&nbsp;    return allMarshalingAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getDefaultAttributes() {
<b class="nc">&nbsp;    if (!hasDefaultAttributes()) {</b>
<b class="nc">&nbsp;      return ImmutableList.of();</b>
&nbsp;    }
<b class="nc">&nbsp;    ImmutableList.Builder&lt;ValueAttribute&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : getImplementedAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isGenerateDefault) {</b>
<b class="nc">&nbsp;        builder.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return builder.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getRequiresTrackedIsSetNonMandatoryAttributes() {
<b class="nc">&nbsp;    ImmutableList.Builder&lt;ValueAttribute&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (ValueAttribute attribute : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.requiresTrackIsSet()) {</b>
<b class="nc">&nbsp;        builder.add(attribute);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return builder.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseStrictBuilder() {
<b class="nc">&nbsp;    return style().strictBuilder()</b>
<b class="nc">&nbsp;        || style().stagedBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseStrictModifiable() {
<b class="nc">&nbsp;    return style().strictModifiable();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseJavaValidationApi() {
<b class="nc">&nbsp;    return style().validationMethod() == ValueMirrors.Style.ValidationMethod.VALIDATION_API;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable TelescopicBuild telescopicBuild;
&nbsp;
&nbsp;  public @Nullable TelescopicBuild getTelescopicBuild() {
<b class="nc">&nbsp;    if (telescopicBuild == null) {</b>
<b class="nc">&nbsp;      if (style().stagedBuilder()</b>
<b class="nc">&nbsp;          &amp;&amp; !getMandatoryAttributes().isEmpty()</b>
<b class="nc">&nbsp;          &amp;&amp; (constitution.isNestedFactoryOrConstructor() || !constitution.isOutsideBuilder())) {</b>
<b class="nc">&nbsp;        TelescopicBuild tb = TelescopicBuild.from(this, getSettableAttributes());</b>
<b class="nc">&nbsp;        if (!tb.stages.isEmpty()) {</b>
<b class="nc">&nbsp;          telescopicBuild = tb;</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return telescopicBuild;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateNoargConstructor() {
<b class="nc">&nbsp;    return style().privateNoargConstructor()</b>
<b class="nc">&nbsp;        || style().protectedNoargConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable ThrowForInvalidImmutableState throwForInvalidImmutableState;
&nbsp;
&nbsp;  public ThrowForInvalidImmutableState getThrowForInvalidImmutableState() {
<b class="nc">&nbsp;    if (throwForInvalidImmutableState == null) {</b>
<b class="nc">&nbsp;      throwForInvalidImmutableState = ThrowForInvalidImmutableState.from(</b>
<b class="nc">&nbsp;          constitution.protoclass().processing(),</b>
<b class="nc">&nbsp;          style());</b>
&nbsp;    }
<b class="nc">&nbsp;    return throwForInvalidImmutableState;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable String throwForNullPointer;
&nbsp;
&nbsp;  public String getThrowForNullPointer() {
<b class="nc">&nbsp;    if (throwForNullPointer == null) {</b>
<b class="nc">&nbsp;      if (!style().throwForNullPointerName().equals(NullPointerException.class.getName())) {</b>
<b class="nc">&nbsp;        throwForNullPointer = style().throwForNullPointerName();</b>
&nbsp;      } else {
&nbsp;        // falsy but non-null value
<b class="nc">&nbsp;        throwForNullPointer = &quot;&quot;;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return throwForNullPointer;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getImplementedAttributes() {
<b class="nc">&nbsp;    if (implementedAttributes == null) {</b>
<b class="nc">&nbsp;      implementedAttributes = attributes()</b>
<b class="nc">&nbsp;          .filter(Predicates.or(Arrays.asList(</b>
<b class="nc">&nbsp;              ValueAttributeFunctions.isGenerateAbstract(),</b>
<b class="nc">&nbsp;              ValueAttributeFunctions.isGenerateDefault(),</b>
<b class="nc">&nbsp;              ValueAttributeFunctions.isGenerateDerived())))</b>
<b class="nc">&nbsp;          .toList();</b>
&nbsp;    }
<b class="nc">&nbsp;    return implementedAttributes;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getEquivalenceAttributes() {
<b class="nc">&nbsp;    return FluentIterable.from(getImplementedAttributes())</b>
<b class="nc">&nbsp;        .filter(NonAuxiliary.PREDICATE)</b>
<b class="nc">&nbsp;        .toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasAuxiliaryAttributes() {
<b class="nc">&nbsp;    for (ValueAttribute a : getImplementedAttributes()) {</b>
<b class="nc">&nbsp;      if (a.isAuxiliary()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasSingleParameterConstructor() {
<b class="nc">&nbsp;    return isUseConstructor() &amp;&amp; getConstructorArguments().size() == 1;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected TypeMirror internalTypeMirror() {
<b class="nc">&nbsp;    return element.asType();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static class HasJdkKind implements Predicate&lt;ValueAttribute&gt; {
&nbsp;    private final AttributeTypeKind kind;
&nbsp;
<b class="nc">&nbsp;    HasJdkKind(AttributeTypeKind kind) {</b>
<b class="nc">&nbsp;      this.kind = kind;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean apply(ValueAttribute attribute) {
<b class="nc">&nbsp;      boolean def = attribute.typeKind() == kind</b>
<b class="nc">&nbsp;          &amp;&amp; !attribute.isGuavaImmutableDeclared();</b>
<b class="nc">&nbsp;      if (def) {</b>
<b class="nc">&nbsp;        switch (kind) {</b>
&nbsp;        case MAP:
&nbsp;        case LIST:
&nbsp;        case SET:
<b class="nc">&nbsp;          return !attribute.isGenerateJdk9();</b>
&nbsp;        default:
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseListUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.LIST));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSetUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.SET));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseEnumSetUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.ENUM_SET));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSortedSetUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.SORTED_SET));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseMapUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.MAP));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseEnumMapUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.ENUM_MAP));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseSortedMapUtility() {
<b class="nc">&nbsp;    return useCollectionUtility(new HasJdkKind(AttributeTypeKind.SORTED_MAP));</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean useCollectionUtility(Predicate&lt;ValueAttribute&gt; predicate) {
<b class="nc">&nbsp;    for (ValueType n : nested) {</b>
<b class="nc">&nbsp;      if (Iterables.any(n.getSettableAttributes(), predicate)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return Iterables.any(getSettableAttributes(), predicate);</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable Set&lt;String&gt; additionalImports;
&nbsp;
&nbsp;  public void additionalImports(Set&lt;String&gt; imports) {
<b class="nc">&nbsp;    if (!imports.isEmpty()) {</b>
<b class="nc">&nbsp;      this.additionalImports = imports;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;String&gt; getRequiredSourceStarImports() {
<b class="nc">&nbsp;    if (!hasSomeUnresolvedTypes()) {</b>
<b class="nc">&nbsp;      return additionalImports != null</b>
<b class="nc">&nbsp;          ? additionalImports</b>
<b class="nc">&nbsp;          : ImmutableSet.&lt;String&gt;of();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Set&lt;String&gt; starImports = Sets.newLinkedHashSet();</b>
&nbsp;
<b class="nc">&nbsp;    if (additionalImports != null) {</b>
<b class="nc">&nbsp;      starImports.addAll(additionalImports);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (ValueType n : FluentIterable.from(nested).append(this)) {</b>
<b class="nc">&nbsp;      for (ValueAttribute a : n.attributes) {</b>
<b class="nc">&nbsp;        if (a.hasSomeUnresolvedTypes) {</b>
<b class="nc">&nbsp;          DeclaringType topLevel = a.getDeclaringType().associatedTopLevel();</b>
&nbsp;
<b class="nc">&nbsp;          SourceExtraction.Imports sourceImports =</b>
<b class="nc">&nbsp;              topLevel.sourceImports();</b>
&nbsp;
<b class="nc">&nbsp;          for (String importStatement : sourceImports.all) {</b>
<b class="nc">&nbsp;            if (importStatement.indexOf(&#39;*&#39;) &gt; 0) {</b>
<b class="nc">&nbsp;              starImports.add(importStatement);</b>
&nbsp;            }
<b class="nc">&nbsp;          }</b>
&nbsp;
<b class="nc">&nbsp;          if (!topLevel.packageOf().equals(constitution.protoclass().packageOf())) {</b>
<b class="nc">&nbsp;            String prefix = topLevel.packageOf().asPrefix();</b>
&nbsp;            // guard against unnamed packages
<b class="nc">&nbsp;            if (!prefix.isEmpty()) {</b>
<b class="nc">&nbsp;              starImports.add(prefix + &#39;*&#39;);</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return starImports;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasSomeUnresolvedTypes() {
<b class="nc">&nbsp;    for (ValueType n : nested) {</b>
<b class="nc">&nbsp;      for (ValueAttribute a : n.attributes) {</b>
<b class="nc">&nbsp;        if (a.hasSomeUnresolvedTypes) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    for (ValueAttribute a : attributes) {</b>
<b class="nc">&nbsp;      if (a.hasSomeUnresolvedTypes) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasCollectionAttribute() {
<b class="nc">&nbsp;    for (ValueAttribute attribute : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (attribute.isCollectionType() || attribute.isMapType()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseNullSafeUtilities() {
<b class="nc">&nbsp;    for (ValueType n : nested) {</b>
<b class="nc">&nbsp;      for (ValueAttribute a : n.attributes) {</b>
<b class="nc">&nbsp;        if (a.isNullable() || a.isJdkOptional()) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    for (ValueAttribute a : attributes) {</b>
<b class="nc">&nbsp;      if (a.isNullable() || a.isJdkOptional()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseCollectionUtility() {
<b class="nc">&nbsp;    for (ValueType n : nested) {</b>
<b class="nc">&nbsp;      if (n.hasCollectionAttribute()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return hasCollectionAttribute();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateConstructorUseCopyConstructor() {
<b class="nc">&nbsp;    return isUseCopyMethods()</b>
<b class="nc">&nbsp;        &amp;&amp; !style().deepImmutablesDetection()</b>
<b class="nc">&nbsp;        &amp;&amp; hasNonNullCheckableParametersInDefaultOrder()</b>
<b class="nc">&nbsp;        &amp;&amp; getConstructorExcluded().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasNonNullCheckableParametersInDefaultOrder() {
<b class="nc">&nbsp;    for (ValueAttribute c : getConstructorArguments()) {</b>
<b class="nc">&nbsp;      if (c.hasConstructorParameterCustomOrder()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (!c.typeKind().isRegular() || !(c.isPrimitive() || c.isNullable())) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSynthCopyConstructor() {
<b class="nc">&nbsp;    return isUseConstructor()</b>
<b class="nc">&nbsp;        &amp;&amp; !isGenerateConstructorUseCopyConstructor()</b>
<b class="nc">&nbsp;        &amp;&amp; getConstructorExcluded().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateBuilderUseCopyConstructor() {
<b class="nc">&nbsp;    return isUseBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; isUseCopyMethods()</b>
<b class="nc">&nbsp;        &amp;&amp; allAttributesSupportsThis()</b>
<b class="nc">&nbsp;        &amp;&amp; !isOrdinalValue()</b>
<b class="nc">&nbsp;        &amp;&amp; getDefaultAttributes().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean allAttributesSupportsThis() {
<b class="nc">&nbsp;    for (ValueAttribute a : implementedAttributes) {</b>
<b class="nc">&nbsp;      if (!a.supportsInternalImplConstructor()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateBuilderConstructor() {
<b class="nc">&nbsp;    return isUseBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !(isUseSingleton() &amp;&amp; settableAttributes.isEmpty())</b>
<b class="nc">&nbsp;        &amp;&amp; !isGenerateBuilderUseCopyConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateClearBuilder() {
<b class="nc">&nbsp;    return style().clearBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected TypeHierarchyCollector collectTypeHierarchy(final TypeMirror typeMirror) {
<b class="nc">&nbsp;    this.hierarchiCollector = createTypeHierarchyCollector(report(), element);</b>
<b class="nc">&nbsp;    this.hierarchiCollector.collectFrom(typeMirror);</b>
<b class="nc">&nbsp;    return hierarchiCollector;</b>
&nbsp;  }
&nbsp;
&nbsp;  TypeHierarchyCollector createTypeHierarchyCollector(final Reporter reporter, final Element element) {
<b class="nc">&nbsp;    return new TypeHierarchyCollector() {</b>
&nbsp;      @Override
&nbsp;      protected String stringify(DeclaredType input, TypevarContext context) {
<b class="nc">&nbsp;        TypeStringProvider provider = new TypeStringProvider(</b>
&nbsp;            reporter,
&nbsp;            element,
&nbsp;            input,
<b class="nc">&nbsp;            newTypeStringResolver(),</b>
<b class="nc">&nbsp;            context.parameters.toArray(new String[0]),</b>
<b class="nc">&nbsp;            context.arguments.toArray(new String[0]));</b>
<b class="nc">&nbsp;        provider.collectUnresolvedYetArgumentsTo(this.unresolvedYetArguments);</b>
<b class="nc">&nbsp;        provider.process();</b>
<b class="nc">&nbsp;        return provider.returnTypeName();</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  ImmutableList&lt;TypeElement&gt; extendedClasses() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    return hierarchiCollector.extendedClasses();</b>
&nbsp;  }
&nbsp;
&nbsp;  ImmutableSet&lt;TypeElement&gt; implementedInterfaces() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    return hierarchiCollector.implementedInterfaces();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private Boolean generateBuilderFrom;
&nbsp;
&nbsp;  public boolean isGenerateBuilderFrom() {
<b class="nc">&nbsp;    if (generateBuilderFrom == null) {</b>
<b class="nc">&nbsp;      generateBuilderFrom = !style().from().isEmpty()</b>
<b class="nc">&nbsp;          &amp;&amp; !isUseStrictBuilder()</b>
<b class="nc">&nbsp;          &amp;&amp; noAttributeInitializerIsNamedAsFrom();</b>
&nbsp;    }
<b class="nc">&nbsp;    return generateBuilderFrom;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateToBuilder() {
<b class="nc">&nbsp;    return isUseBuilder() &amp;&amp; isGenerateBuilderFrom() &amp;&amp; !style().toBuilder().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateFilledFrom() {
<b class="nc">&nbsp;    return kind().isModifiable() &amp;&amp; noAttributeSetterIsNamedAsFrom();</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean noAttributeInitializerIsNamedAsFrom() {
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (a.names.init.equals(names().from)) {</b>
<b class="nc">&nbsp;        a.report()</b>
<b class="nc">&nbsp;            .warning(About.FROM,</b>
&nbsp;                &quot;Attribute initializer named &#39;%s&#39; clashes with special builder method, &quot;
&nbsp;                    + &quot;which will not be generated to not have ambiguous overload or conflict&quot;,
<b class="nc">&nbsp;                names().from);</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Used for modifiable
&nbsp;  private boolean noAttributeSetterIsNamedAsFrom() {
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (a.names.set().equals(names().from)) {</b>
<b class="nc">&nbsp;        a.report()</b>
<b class="nc">&nbsp;            .warning(</b>
&nbsp;                About.FROM,
&nbsp;                &quot;Attribute setter named &#39;%s&#39; clashes with special builder method, &quot;
&nbsp;                    + &quot;which will not be generated to not have ambiguous overload or conflict&quot;,
<b class="nc">&nbsp;                names().from);</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasDeprecatedAttributes() {
<b class="nc">&nbsp;    for (ValueAttribute a : getAllAccessibleAttributes()) {</b>
<b class="nc">&nbsp;      if (a.deprecated) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasSettableCollection() {
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (a.isCollectionType()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasSettableMapping() {
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (a.isMapType()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  ImmutableListMultimap&lt;String, TypeElement&gt; accessorMapping;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private FromSupertypesModel buildFromTypes;
&nbsp;
&nbsp;  public FromSupertypesModel getBuildFromTypes() {
<b class="nc">&nbsp;    if (buildFromTypes == null) {</b>
<b class="nc">&nbsp;      buildFromTypes = new FromSupertypesModel(</b>
<b class="nc">&nbsp;          report(),</b>
<b class="nc">&nbsp;          typeAbstract().toString(),</b>
<b class="nc">&nbsp;          getSettableAttributes(),</b>
&nbsp;          accessorMapping,
<b class="nc">&nbsp;          constitution.protoclass().processing(),</b>
<b class="nc">&nbsp;          extendedClasses(),</b>
<b class="nc">&nbsp;          implementedInterfaces());</b>
&nbsp;    }
<b class="nc">&nbsp;    return buildFromTypes;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public Serialization serial = Serialization.NONE;</b>
&nbsp;
<b class="nc">&nbsp;  public ImmutableList&lt;String&gt; throwing = ImmutableList.of();</b>
&nbsp;
<b class="nc">&nbsp;  public enum Serialization {</b>
<b class="nc">&nbsp;    NONE, STRUCTURAL, STRUCTURAL_IMPLEMENTS, IMPLEMENTS, SERIAL_VERSION;</b>
&nbsp;
&nbsp;    public boolean isEnabled() {
<b class="nc">&nbsp;      return this != NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isStructural() {
<b class="nc">&nbsp;      return this == STRUCTURAL</b>
&nbsp;          || this == STRUCTURAL_IMPLEMENTS;
&nbsp;    }
&nbsp;
&nbsp;    public boolean isSimple() {
<b class="nc">&nbsp;      return this == IMPLEMENTS</b>
&nbsp;          || this == SERIAL_VERSION;
&nbsp;    }
&nbsp;
&nbsp;    public boolean shouldImplement() {
<b class="nc">&nbsp;      return this == STRUCTURAL</b>
&nbsp;          || this == SERIAL_VERSION;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void detectSerialization() {
<b class="nc">&nbsp;    Protoclass p = constitution.protoclass();</b>
<b class="nc">&nbsp;    boolean isSerializable = isSerializable();</b>
<b class="nc">&nbsp;    if (p.isSerialStructural()) {</b>
<b class="nc">&nbsp;      serial = isSerializable</b>
<b class="nc">&nbsp;          ? Serialization.STRUCTURAL_IMPLEMENTS</b>
<b class="nc">&nbsp;          : Serialization.STRUCTURAL;</b>
<b class="nc">&nbsp;    } else if (isSerializable) {</b>
<b class="nc">&nbsp;      serial = Serialization.IMPLEMENTS;</b>
<b class="nc">&nbsp;    } else if (p.serialVersion().isPresent()) {</b>
<b class="nc">&nbsp;      serial = Serialization.SERIAL_VERSION;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasCreatorDefined;
&nbsp;
&nbsp;  void detectParcelableCreator() {
<b class="nc">&nbsp;    for (VariableElement v : ElementFilter.fieldsIn(element.getEnclosedElements())) {</b>
<b class="nc">&nbsp;      if (v.getSimpleName().contentEquals(Proto.PARCELABLE_CREATOR_FIELD)) {</b>
<b class="nc">&nbsp;        hasCreatorDefined = true;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateParcelable() {
<b class="nc">&nbsp;    return isParcelable() &amp;&amp; !hasCreatorDefined;</b>
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;String&gt; getImmutableCopyOfRoutines() {
<b class="nc">&nbsp;    Set&lt;String&gt; routines = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;    routines.addAll(style().immutableCopyOfRoutinesNames());</b>
<b class="nc">&nbsp;    for (ValueType v : nested) {</b>
<b class="nc">&nbsp;      routines.addAll(v.style().immutableCopyOfRoutinesNames());</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return routines;</b>
&nbsp;  }
&nbsp;
&nbsp;  private SuppressedWarnings suppressedWarnings;
&nbsp;
&nbsp;  public Set&lt;String&gt; generatedSuppressWarnings() {
<b class="nc">&nbsp;    return getSuppressedWarnings().generatedSuppressions;</b>
&nbsp;  }
&nbsp;
&nbsp;  private SuppressedWarnings getSuppressedWarnings() {
<b class="nc">&nbsp;    if (suppressedWarnings == null) {</b>
<b class="nc">&nbsp;      suppressedWarnings =</b>
<b class="nc">&nbsp;          SuppressedWarnings.forElement(</b>
&nbsp;              element,
<b class="nc">&nbsp;              style().generateSuppressAllWarnings(),</b>
<b class="nc">&nbsp;              hasDeprecatedAttributes());</b>
&nbsp;    }
<b class="nc">&nbsp;    return suppressedWarnings;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean suppressesUncheckedWarning() {
<b class="nc">&nbsp;    Set&lt;String&gt; typeSuppressions = generatedSuppressWarnings();</b>
<b class="nc">&nbsp;    return typeSuppressions.contains(&quot;unchecked&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateSuppressAllWarnings() {
<b class="nc">&nbsp;    return getSuppressedWarnings().generated;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUseCompactBuilder() {
<b class="nc">&nbsp;    return !kind().isFactory()</b>
<b class="nc">&nbsp;        &amp;&amp; !isUseStrictBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !isGenerateBuildOrThrow()</b>
<b class="nc">&nbsp;        &amp;&amp; !getThrowForInvalidImmutableState().isCustom;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDeprecated() {
<b class="nc">&nbsp;    return constitution</b>
<b class="nc">&nbsp;        .protoclass()</b>
<b class="nc">&nbsp;        .processing()</b>
<b class="nc">&nbsp;        .getElementUtils()</b>
<b class="nc">&nbsp;        .isDeprecated(CachingElements.getDelegate(element));</b>
&nbsp;  }
&nbsp;
&nbsp;  public ImmutableList&lt;String&gt; extractDocComment(Element element) {
&nbsp;    // Only extract for generated type which is public
<b class="nc">&nbsp;    if (constitution.implementationVisibility().isPublic()) {</b>
<b class="nc">&nbsp;      @Nullable String docComment = constitution</b>
<b class="nc">&nbsp;          .protoclass()</b>
<b class="nc">&nbsp;          .processing()</b>
<b class="nc">&nbsp;          .getElementUtils()</b>
<b class="nc">&nbsp;          .getDocComment(CachingElements.getDelegate(element));</b>
&nbsp;
<b class="nc">&nbsp;      if (docComment != null) {</b>
<b class="nc">&nbsp;        return ImmutableList.copyOf(DOC_COMMENT_LINE_SPLITTER.split(docComment));</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private ImmutableList&lt;String&gt; docComment;
&nbsp;
&nbsp;  public ImmutableList&lt;String&gt; getDocComment() {
<b class="nc">&nbsp;    if (docComment == null) {</b>
<b class="nc">&nbsp;      this.docComment = constitution.isImplementationPrimary()</b>
<b class="nc">&nbsp;          || style().getStyles().isImmutableIdentityNaming()</b>
<b class="nc">&nbsp;              ? extractDocComment(element)</b>
<b class="nc">&nbsp;              : ImmutableList.&lt;String&gt;of();</b>
&nbsp;    }
<b class="nc">&nbsp;    return docComment;</b>
&nbsp;  }
&nbsp;
&nbsp;  DeclaringType inferDeclaringType(Element element) {
<b class="nc">&nbsp;    return constitution.protoclass().environment().round().inferDeclaringTypeFor(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;String&gt; getNonAttributeAbstractMethodSignatures() {
<b class="nc">&nbsp;    if (element.getKind().isClass() || element.getKind().isInterface()) {</b>
<b class="nc">&nbsp;      Set&lt;String&gt; signatures = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;      List&lt;? extends Element&gt; members = constitution.protoclass()</b>
<b class="nc">&nbsp;          .environment()</b>
<b class="nc">&nbsp;          .processing()</b>
<b class="nc">&nbsp;          .getElementUtils()</b>
<b class="nc">&nbsp;          .getAllMembers(CachingElements.getDelegate((TypeElement) element));</b>
&nbsp;
<b class="nc">&nbsp;      for (ExecutableElement m : ElementFilter.methodsIn(members)) {</b>
<b class="nc">&nbsp;        if (!m.getParameters().isEmpty()</b>
<b class="nc">&nbsp;            || m.getSimpleName().contentEquals(AccessorAttributesCollector.HASH_CODE_METHOD)</b>
<b class="nc">&nbsp;            || m.getSimpleName().contentEquals(AccessorAttributesCollector.TO_STRING_METHOD)) {</b>
&nbsp;
<b class="nc">&nbsp;          if (m.getModifiers().contains(Modifier.ABSTRACT)) {</b>
<b class="nc">&nbsp;            TypeMirror returnType = m.getReturnType();</b>
<b class="nc">&nbsp;            if (!ProcessingEnvironments.isEclipseImplementation(constitution.protoclass().processing())) {</b>
<b class="nc">&nbsp;              returnType = AccessorAttributesCollector.asInheritedMemberReturnType(</b>
<b class="nc">&nbsp;                  constitution.protoclass().processing(),</b>
<b class="nc">&nbsp;                  CachingElements.getDelegate((TypeElement) element),</b>
&nbsp;                  m);
&nbsp;            }
<b class="nc">&nbsp;            signatures.add(toSignature(m, returnType));</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return signatures;</b>
&nbsp;    }
<b class="nc">&nbsp;    return Collections.emptySet();</b>
&nbsp;  }
&nbsp;
&nbsp;  public FuncData getFunctionalData() {
<b class="nc">&nbsp;    return new FuncData();</b>
&nbsp;  }
&nbsp;
&nbsp;  public final class FuncData {
<b class="nc">&nbsp;    public final List&lt;ValueAttribute&gt; functionalAttributes = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    public final List&lt;BoundElement&gt; boundElements = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    FuncData() {</b>
<b class="nc">&nbsp;      List&lt;ValueAttribute&gt; allAccessibleAttributes = getAllAccessibleAttributes();</b>
&nbsp;
<b class="nc">&nbsp;      if (constitution.protoclass().declaringType().isPresent()) {</b>
<b class="nc">&nbsp;        if (FunctionalMirror.isPresent(constitution.protoclass().declaringType().get().element())) {</b>
<b class="nc">&nbsp;          functionalAttributes.addAll(allAccessibleAttributes);</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      if (functionalAttributes.isEmpty() &amp;&amp; FunctionalMirror.isPresent(element)) {</b>
<b class="nc">&nbsp;        functionalAttributes.addAll(allAccessibleAttributes);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (functionalAttributes.isEmpty()) {</b>
<b class="nc">&nbsp;        for (ValueAttribute a : getAllAccessibleAttributes()) {</b>
<b class="nc">&nbsp;          if (FunctionalMirror.isPresent(a.element)) {</b>
<b class="nc">&nbsp;            functionalAttributes.add(a);</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (element.getKind().isClass() || element.getKind().isInterface()) {</b>
<b class="nc">&nbsp;        List&lt;ExecutableElement&gt; methods =</b>
<b class="nc">&nbsp;            ElementFilter.methodsIn(</b>
<b class="nc">&nbsp;                constitution.protoclass()</b>
<b class="nc">&nbsp;                    .environment()</b>
<b class="nc">&nbsp;                    .processing()</b>
<b class="nc">&nbsp;                    .getElementUtils()</b>
<b class="nc">&nbsp;                    .getAllMembers(CachingElements.getDelegate((TypeElement) element)));</b>
&nbsp;
<b class="nc">&nbsp;        for (ExecutableElement m : methods) {</b>
<b class="nc">&nbsp;          if (BindParamsMirror.isPresent(m)</b>
<b class="nc">&nbsp;              &amp;&amp; !m.getModifiers().contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;              &amp;&amp; !m.getModifiers().contains(Modifier.PRIVATE)</b>
<b class="nc">&nbsp;              &amp;&amp; !m.getParameters().isEmpty()) {</b>
<b class="nc">&nbsp;            this.boundElements.add(new FuncData.BoundElement(m));</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    public boolean is() {
<b class="nc">&nbsp;      return !functionalAttributes.isEmpty() || !boundElements.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    public final class BoundElement {
&nbsp;      public final CharSequence access;
&nbsp;      public final CharSequence name;
&nbsp;      public final CharSequence type;
&nbsp;      public final CharSequence parameters;
&nbsp;      public final CharSequence arguments;
&nbsp;
<b class="nc">&nbsp;      BoundElement(ExecutableElement method) {</b>
<b class="nc">&nbsp;        DeclaringType declaringType = inferDeclaringType(method);</b>
<b class="nc">&nbsp;        this.access = appendAccessModifier(method, new StringBuilder());</b>
<b class="nc">&nbsp;        this.name = method.getSimpleName();</b>
<b class="nc">&nbsp;        this.type = method.getReturnType().getKind().isPrimitive()</b>
<b class="nc">&nbsp;            ? wrapType(method.getReturnType().toString())</b>
<b class="nc">&nbsp;            : appendReturnType(method, new StringBuilder(), declaringType, method.getReturnType());</b>
<b class="nc">&nbsp;        this.parameters = appendParameters(method, new StringBuilder(), declaringType, true, true);</b>
<b class="nc">&nbsp;        this.arguments = appendParameters(method, new StringBuilder(), declaringType, false, false);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;ValueAttribute&gt; getBuilderParameters() {
<b class="nc">&nbsp;    if (!constitution.protoclass().environment().hasBuilderModule()) {</b>
<b class="nc">&nbsp;      return ImmutableList.of();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; params = Lists.newArrayList();</b>
&nbsp;
<b class="nc">&nbsp;    for (ValueAttribute a : getSettableAttributes()) {</b>
<b class="nc">&nbsp;      if (a.isBuilderParameter) {</b>
<b class="nc">&nbsp;        params.add(a);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return params;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String toSignature(ExecutableElement m, TypeMirror returnType) {
<b class="nc">&nbsp;    DeclaringType declaringType = inferDeclaringType(m);</b>
<b class="nc">&nbsp;    StringBuilder signature = new StringBuilder();</b>
<b class="nc">&nbsp;    appendAccessModifier(m, signature);</b>
<b class="nc">&nbsp;    appendReturnType(m, signature, declaringType, returnType);</b>
<b class="nc">&nbsp;    signature.append(&quot; &quot;).append(m.getSimpleName());</b>
<b class="nc">&nbsp;    appendParameters(m, signature, declaringType, true, false);</b>
<b class="nc">&nbsp;    return signature.toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  private CharSequence appendAccessModifier(ExecutableElement m, StringBuilder signature) {
<b class="nc">&nbsp;    if (m.getModifiers().contains(Modifier.PUBLIC)) {</b>
<b class="nc">&nbsp;      return signature.append(&quot;public &quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (m.getModifiers().contains(Modifier.PROTECTED)) {</b>
<b class="nc">&nbsp;      return signature.append(&quot;protected &quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    return signature;</b>
&nbsp;  }
&nbsp;
&nbsp;  private CharSequence appendReturnType(
&nbsp;      ExecutableElement m,
&nbsp;      StringBuilder signature,
&nbsp;      DeclaringType declaringType,
&nbsp;      TypeMirror returnType) {
<b class="nc">&nbsp;    return signature.append(printType(m, returnType, declaringType));</b>
&nbsp;  }
&nbsp;
&nbsp;  private CharSequence appendParameters(
&nbsp;      ExecutableElement m,
&nbsp;      StringBuilder signature,
&nbsp;      DeclaringType declaringType,
&nbsp;      boolean withTypes,
&nbsp;      boolean allFinal) {
<b class="nc">&nbsp;    signature.append(&quot;(&quot;);</b>
&nbsp;
<b class="nc">&nbsp;    boolean notFirst = false;</b>
<b class="nc">&nbsp;    for (VariableElement p : m.getParameters()) {</b>
<b class="nc">&nbsp;      if (notFirst) {</b>
<b class="nc">&nbsp;        signature.append(&quot;, &quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (allFinal) {</b>
<b class="nc">&nbsp;        signature.append(&quot;final &quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (withTypes) {</b>
<b class="nc">&nbsp;        signature.append(printType(p, p.asType(), declaringType));</b>
<b class="nc">&nbsp;        signature.append(&quot; &quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      signature.append(p.getSimpleName());</b>
<b class="nc">&nbsp;      notFirst = true;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return signature.append(&quot;)&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private String printType(Element element, TypeMirror type, DeclaringType declaringType) {
<b class="nc">&nbsp;    TypeStringProvider provider =</b>
&nbsp;        new TypeStringProvider(
<b class="nc">&nbsp;            report(),</b>
&nbsp;            element,
&nbsp;            type,
<b class="nc">&nbsp;            new ImportsTypeStringResolver(constitution.protoclass().declaringType().orNull(), declaringType),</b>
<b class="nc">&nbsp;            constitution.generics().vars(),</b>
&nbsp;            null);
<b class="nc">&nbsp;    provider.process();</b>
<b class="nc">&nbsp;    return provider.returnTypeName();</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable GsonTypeTokens gsonTypeTokens;
&nbsp;
&nbsp;  public GsonTypeTokens getGsonTypeTokens() {
<b class="nc">&nbsp;    if (gsonTypeTokens == null) {</b>
<b class="nc">&nbsp;      this.gsonTypeTokens = new GsonTypeTokens(</b>
<b class="nc">&nbsp;          generics(),</b>
<b class="nc">&nbsp;          getTypeExtractor());</b>
&nbsp;    }
<b class="nc">&nbsp;    return gsonTypeTokens;</b>
&nbsp;  }
&nbsp;
&nbsp;  public @Nullable ValueAttribute getGsonOther() {
<b class="nc">&nbsp;    for (ValueAttribute a : attributes) {</b>
<b class="nc">&nbsp;      if (a.isGsonOther()) {</b>
<b class="nc">&nbsp;        return a;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable TypeExtractor typeExtractor;
&nbsp;
&nbsp;  private TypeExtractor getTypeExtractor() {
<b class="nc">&nbsp;    if (typeExtractor == null) {</b>
<b class="nc">&nbsp;      this.typeExtractor = new TypeExtractor(Proto.typeFactory(), (Parameterizable) element);</b>
&nbsp;    }
<b class="nc">&nbsp;    return typeExtractor;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable SourceStructureGet cachedSourceGet;
&nbsp;
&nbsp;  @Override
&nbsp;  public @Nullable SourceStructureGet readCachedSourceGet() {
<b class="nc">&nbsp;    if (cachedSourceGet == null) {</b>
<b class="nc">&nbsp;      CharSequence source = inferDeclaringType(element).sourceCode();</b>
<b class="nc">&nbsp;      if (source.length() &gt; 0) {</b>
&nbsp;        // and all this needed only to defeat Javac problem, sigh
<b class="nc">&nbsp;        cachedSourceGet = new SourceStructureGet(source);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return cachedSourceGet;</b>
&nbsp;  }
&nbsp;
&nbsp;  public Reporter report() {
<b class="nc">&nbsp;    return constitution.protoclass().report();</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;String&gt; getDebugLines() {
<b class="nc">&nbsp;    return constitution.protoclass().getDebugLines();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDataInline() {
<b class="nc">&nbsp;    return DataInlineMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public StyleInfo style() {
<b class="nc">&nbsp;    return constitution.style();</b>
&nbsp;  }
&nbsp;
&nbsp;  public Element originalElement() {
<b class="nc">&nbsp;    return CachingElements.getDelegate(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  List&lt;AnnotationInjection&gt; getDeclaringPackageAnnotationInjections() {
<b class="nc">&nbsp;    return constitution.protoclass().packageOf().getAnnotationInjections();</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; syntheticFieldsInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.SYNTHETIC_FIELDS);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; constructorInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.CONSTRUCTOR);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; immutableTypeInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.IMMUTABLE_TYPE);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; builderTypeInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.BUILDER_TYPE);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; modifiableTypeInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.MODIFIABLE_TYPE);</b>
&nbsp;  }
&nbsp;
&nbsp;  List&lt;AnnotationInjection&gt; getDeclaringTypeAnnotationInjections() {
<b class="nc">&nbsp;    Optional&lt;DeclaringType&gt; declaringType = constitution.protoclass().declaringType();</b>
<b class="nc">&nbsp;    if (declaringType.isPresent()) {</b>
<b class="nc">&nbsp;      return declaringType.get().getAnnotationInjections();</b>
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  List&lt;AnnotationInjection&gt; getDeclaringTypeEnclosingAnnotationInjections() {
<b class="nc">&nbsp;    Optional&lt;DeclaringType&gt; declaringType = constitution.protoclass().declaringType();</b>
<b class="nc">&nbsp;    if (declaringType.isPresent()) {</b>
<b class="nc">&nbsp;      Optional&lt;DeclaringType&gt; enclosingTopLevel = declaringType.get().enclosingTopLevel();</b>
<b class="nc">&nbsp;      if (enclosingTopLevel.isPresent()) {</b>
<b class="nc">&nbsp;        return enclosingTopLevel.get().getAnnotationInjections();</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private Collection&lt;String&gt; collectInjections(Where target) {
<b class="nc">&nbsp;    return AnnotationInjections.collectInjections(element,</b>
&nbsp;        target,
<b class="nc">&nbsp;        Lists.transform(attributes, ValueAttribute.ToName.FUNCTION),</b>
<b class="nc">&nbsp;        getDeclaringTypeAnnotationInjections(),</b>
<b class="nc">&nbsp;        getDeclaringTypeEnclosingAnnotationInjections(),</b>
<b class="nc">&nbsp;        getDeclaringPackageAnnotationInjections());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean forceEqualsInWithers() {
<b class="nc">&nbsp;    return style().forceEqualsInWithers();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateIncludeHashCode() {
<b class="nc">&nbsp;    return !style().includeHashCode().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getIncludedHashCode() {
<b class="nc">&nbsp;    return style().includeHashCode().replace(&quot;[[type]]&quot;,</b>
<b class="nc">&nbsp;        constitution.typeAbstract().relativeRaw());</b>
&nbsp;  }
&nbsp;
&nbsp;  public @Nullable UnderrideMethod underrideToString;
&nbsp;  public @Nullable UnderrideMethod underrideHashCode;
&nbsp;  public @Nullable UnderrideMethod underrideEquals;
&nbsp;
&nbsp;  public static final class UnderrideMethod {
&nbsp;    public final String name;
&nbsp;    public final boolean isStatic;
&nbsp;    public final String definedIn;
&nbsp;
<b class="nc">&nbsp;    UnderrideMethod(String name, boolean isStatic, String definedIn) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.isStatic = isStatic;</b>
<b class="nc">&nbsp;      this.definedIn = definedIn;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Used for type snapshotting
&nbsp;   */
&nbsp;  @Override
&nbsp;  public int hashCode() {
<b class="nc">&nbsp;    return Objects.hash(constitution.protoclass().name());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return &quot;Type[&quot; + name() + &quot;]&quot;;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final Splitter DOC_COMMENT_LINE_SPLITTER = Splitter.on(&#39;\n&#39;).omitEmptyStrings();</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
