


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > RepositoryModel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: RepositoryModel (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RepositoryModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/37)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RepositoryModel$1</td>
  </tr>
  <tr>
    <td class="name">RepositoryModel$CodeBlock</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RepositoryModel$Consumer</td>
  </tr>
  <tr>
    <td class="name">RepositoryModel$DelegateMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RepositoryModel$Facet</td>
  </tr>
  <tr>
    <td class="name">RepositoryModel$FacetConsumer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/106)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2019 Immutables Authors and Contributors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import com.google.common.base.Joiner;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import org.immutables.value.Value;
&nbsp;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.element.VariableElement;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.ExecutableType;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import javax.lang.model.util.Elements;
&nbsp;import javax.lang.model.util.Types;
&nbsp;import javax.tools.Diagnostic;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;/**
&nbsp; * Repository model and builder. Traverses {@code javax.lang.model} API to generate
&nbsp; * repository interfaces and methods and expose them in template engine.
&nbsp; *
&nbsp; * TODO: This code is currently a mess and needs cleanup.
&nbsp; */
<b class="nc">&nbsp;public class RepositoryModel {</b>
&nbsp;
&nbsp;  private static final String BACKEND = &quot;org.immutables.criteria.backend.Backend&quot;;
&nbsp;  private static final String SESSION = &quot;org.immutables.criteria.backend.Backend.Session&quot;;
&nbsp;
&nbsp;  private final ValueType type;
&nbsp;  private final Element element;
&nbsp;
&nbsp;  // processor utils
&nbsp;  private final Types types;
&nbsp;  private final Elements elements;
&nbsp;  private final boolean isEclipseImplementation;
&nbsp;  private final ProcessingEnvironment environment;
&nbsp;
&nbsp;  private List&lt;Facet&gt; cachedFacets;
&nbsp;
<b class="nc">&nbsp;  RepositoryModel(ValueType type) {</b>
<b class="nc">&nbsp;    this.type = Objects.requireNonNull(type, &quot;type&quot;);</b>
<b class="nc">&nbsp;    this.element = type.element;</b>
<b class="nc">&nbsp;    final ProcessingEnvironment env = type.constitution.protoclass().environment().processing();</b>
<b class="nc">&nbsp;    this.types = env.getTypeUtils();</b>
<b class="nc">&nbsp;    this.elements = env.getElementUtils();</b>
<b class="nc">&nbsp;    this.isEclipseImplementation = ProcessingEnvironments.isEclipseImplementation(env);</b>
<b class="nc">&nbsp;    this.environment = env;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;Facet&gt; facets() {
<b class="nc">&nbsp;    if (cachedFacets != null) {</b>
<b class="nc">&nbsp;      return cachedFacets;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final CriteriaRepositoryMirror annotation = annotation();</b>
<b class="nc">&nbsp;    final List&lt;Facet&gt; facets = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    for (TypeMirror mirror: annotation.facetsMirror()) {</b>
<b class="nc">&nbsp;      final Element element = types.asElement(mirror);</b>
<b class="nc">&nbsp;      if (MoreElements.isType(element)) {</b>
<b class="nc">&nbsp;        final TypeElement type = isEclipseImplementation ? elements.getTypeElement(MoreElements.asType(element).getQualifiedName()) : MoreElements.asType(element);</b>
<b class="nc">&nbsp;        final FacetConsumer facetConsumer = new FacetConsumer(facets, type);</b>
<b class="nc">&nbsp;        for (TypeMirror iface: type.getInterfaces()) {</b>
<b class="nc">&nbsp;          facetConsumer.consume(iface);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    cachedFacets = ImmutableList.copyOf(facets);</b>
<b class="nc">&nbsp;    return cachedFacets;</b>
&nbsp;  }
&nbsp;
&nbsp;  private interface Consumer&lt;T&gt; {
&nbsp;    void consume(T value);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Traverses current type and build a facet definition
&nbsp;   */
<b class="nc">&nbsp;  private class FacetConsumer implements Consumer&lt;TypeMirror&gt; {</b>
&nbsp;    private final List&lt;Facet&gt; facets;
&nbsp;    private final TypeElement typed;
&nbsp;
<b class="nc">&nbsp;    private FacetConsumer(List&lt;Facet&gt; facets, TypeElement typed) {</b>
<b class="nc">&nbsp;      this.facets = facets;</b>
<b class="nc">&nbsp;      this.typed = typed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Variable name based on facet element
&nbsp;     */
&nbsp;    private String nextName(TypeElement element) {
<b class="nc">&nbsp;      final String ifaceName = element.getQualifiedName().toString();</b>
&nbsp;      String name;
<b class="nc">&nbsp;      if (ifaceName.contains(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;        name = ifaceName.substring(ifaceName.lastIndexOf(&#39;.&#39;) + 1);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        name = ifaceName;</b>
&nbsp;      }
<b class="nc">&nbsp;      name = CaseFormat.UPPER_CAMEL.converterTo(CaseFormat.LOWER_CAMEL).convert(name);</b>
&nbsp;
<b class="nc">&nbsp;      return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void consume(TypeMirror iface) {
<b class="nc">&nbsp;      if (!isFacet(iface)) {</b>
&nbsp;        return;
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final TypeElement ifaceElement = MoreElements.asType(types.asElement(iface));</b>
<b class="nc">&nbsp;      final String name = nextName(ifaceElement);</b>
&nbsp;      // convert Writable&lt;T&gt; into Writable&lt;Person&gt;
<b class="nc">&nbsp;      final DeclaredType fieldType = types.getDeclaredType(typed, RepositoryModel.this.element.asType());</b>
&nbsp;
<b class="nc">&nbsp;      final List&lt;ExecutableElement&gt; constructors = ElementFilter.constructorsIn(elements.getAllMembers(typed));</b>
&nbsp;      final CodeBlock block;
<b class="nc">&nbsp;      if (!constructors.isEmpty()) {</b>
<b class="nc">&nbsp;        final List&lt;String&gt; params = new ArrayList&lt;&gt;();</b>
&nbsp;        // only one constructor expected
<b class="nc">&nbsp;        ExecutableElement ctor = constructors.get(0);</b>
<b class="nc">&nbsp;        for(VariableElement variable:ctor.getParameters()) {</b>
<b class="nc">&nbsp;          TypeMirror varType = variable.asType();</b>
<b class="nc">&nbsp;          if (types.isSubtype(varType, types.erasure(elements.getTypeElement(Class.class.getCanonicalName()).asType()))) {</b>
&nbsp;            // inject entity class
<b class="nc">&nbsp;            params.add(RepositoryModel.this.type.typeDocument().toString() + &quot;.class&quot;);</b>
<b class="nc">&nbsp;          } else if (types.isSubtype(varType, elements.getTypeElement(BACKEND).asType())) {</b>
&nbsp;            // inject backend
<b class="nc">&nbsp;            params.add(&quot;backend&quot;);</b>
<b class="nc">&nbsp;          } else if (types.isSubtype(varType, elements.getTypeElement(SESSION).asType())) {</b>
<b class="nc">&nbsp;            params.add(&quot;session&quot;);</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        block = new CodeBlock(String.format(&quot;this.%s = new %s(%s)&quot;, name, fieldType, Joiner.on(&quot;, &quot;).join(params)));</b>
<b class="nc">&nbsp;      } else {</b>
<b class="nc">&nbsp;        block = new CodeBlock(&quot;&quot;);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      ImmutableFacet.Builder facet = ImmutableFacet.builder();</b>
&nbsp;      // figure out list of interface methods to implement from eg. Writable
<b class="nc">&nbsp;      final DeclaredType interfaceType = types.getDeclaredType(ifaceElement, RepositoryModel.this.element.asType());</b>
<b class="nc">&nbsp;      final List&lt;ExecutableElement&gt; ifaceMethods = ElementFilter.methodsIn(elements.getAllMembers(MoreElements.asType(interfaceType.asElement())));</b>
<b class="nc">&nbsp;      final List&lt;ExecutableElement&gt; objectMethods = ElementFilter.methodsIn(elements.getAllMembers(MoreElements.asType(elements.getTypeElement(Object.class.getCanonicalName()))));</b>
<b class="nc">&nbsp;      ifaceMethods.removeAll(objectMethods);</b>
&nbsp;
<b class="nc">&nbsp;      for (ExecutableElement exec : ifaceMethods) {</b>
<b class="nc">&nbsp;        if (isEclipseImplementation &amp;&amp; exec.isDefault()) {</b>
&nbsp;          // Eclipse ECJ doesn&#39;t resolve (as in Types.asMemberOf) correctly default methods.
&nbsp;          // Skip default methods in Eclipse compiler.
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="nc">&nbsp;        ExecutableType type1 = MoreTypes.asExecutable(types.asMemberOf(interfaceType, exec));</b>
<b class="nc">&nbsp;        facet.addMethods(new DelegateMethod(type1, exec, name));</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      facet.name(name)</b>
<b class="nc">&nbsp;              .interfaceType(interfaceType)</b>
<b class="nc">&nbsp;              .fieldType(fieldType)</b>
<b class="nc">&nbsp;              .constructor(block)</b>
<b class="nc">&nbsp;              .build();</b>
&nbsp;
<b class="nc">&nbsp;      facets.add(facet.build());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean isFacet(TypeMirror mirror) {
<b class="nc">&nbsp;    final Element element = types.asElement(mirror);</b>
<b class="nc">&nbsp;    if (element == null || !MoreElements.isType(element)) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final TypeElement typed = MoreElements.asType(element);</b>
<b class="nc">&nbsp;    final TypeMirror facet = elements.getTypeElement(&quot;org.immutables.criteria.repository.Facet&quot;).asType();</b>
<b class="nc">&nbsp;    if (types.isSubtype(mirror, facet)) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (TypeMirror iface: typed.getInterfaces()) {</b>
<b class="nc">&nbsp;      if (isFacet(iface)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private CriteriaRepositoryMirror annotation() {
<b class="nc">&nbsp;    return type.constitution.protoclass().criteriaRepository().get();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateRepository() {
<b class="nc">&nbsp;    return type.constitution.protoclass().criteriaRepository().isPresent();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Used in templates to generate repository source code
&nbsp;   */
&nbsp;  @Value.Immutable
&nbsp;  public interface Facet {
&nbsp;    String name();
&nbsp;    TypeMirror interfaceType();
&nbsp;    TypeMirror fieldType();
&nbsp;    CodeBlock constructor();
&nbsp;    List&lt;DelegateMethod&gt; methods();
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public static class CodeBlock {</b>
&nbsp;    public final String code;
&nbsp;
<b class="nc">&nbsp;    private CodeBlock(String code) {</b>
<b class="nc">&nbsp;      this.code = Objects.requireNonNull(code, &quot;code&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;      return code.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public static class DelegateMethod {</b>
&nbsp;    private final ExecutableType type;
&nbsp;    private final ExecutableElement element;
&nbsp;    private final String body;
&nbsp;
<b class="nc">&nbsp;    private DelegateMethod(ExecutableType type, ExecutableElement element, String delegateName) {</b>
<b class="nc">&nbsp;      this.type = Objects.requireNonNull(type, &quot;type&quot;);</b>
<b class="nc">&nbsp;      this.element = element;</b>
<b class="nc">&nbsp;      this.body = String.format(&quot;return %s.%s(%s);&quot;, delegateName, element.getSimpleName().toString(), Joiner.on(&quot;, &quot;).join(element.getParameters()));</b>
&nbsp;    }
&nbsp;
&nbsp;    public String name() {
<b class="nc">&nbsp;      return element.getSimpleName().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String parameters() {
<b class="nc">&nbsp;      List&lt;String&gt; params = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; type.getParameterTypes().size(); i++) {</b>
<b class="nc">&nbsp;        final TypeMirror paramType = type.getParameterTypes().get(i);</b>
<b class="nc">&nbsp;        final String name = element.getParameters().get(i).getSimpleName().toString();</b>
<b class="nc">&nbsp;        if (element.isVarArgs()) {</b>
&nbsp;          // special case for varargs
<b class="nc">&nbsp;          final TypeMirror component = MoreTypes.asArray(paramType).getComponentType();</b>
<b class="nc">&nbsp;          params.add(component + &quot; ... &quot; + name);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;          params.add(paramType + &quot; &quot; + name);</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return Joiner.on(&quot;, &quot;).join(params);</b>
&nbsp;    }
&nbsp;
&nbsp;    public TypeMirror returnType() {
<b class="nc">&nbsp;      return type.getReturnType();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String body() {
<b class="nc">&nbsp;      return body;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
