


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Styles</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: Styles (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Styles</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Styles$1</td>
  </tr>
  <tr>
    <td class="name">Styles$PackageNaming</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Styles$Scheme</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Styles$UsingName</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Styles$UsingName$AttributeNames</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Styles$UsingName$AttributeNames$ForCollections</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Styles$UsingName$TypeNames</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/171)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2014 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import org.immutables.generator.Naming;
&nbsp;
&nbsp;import javax.lang.model.SourceVersion;
&nbsp;import javax.lang.model.element.Name;
&nbsp;
<b class="nc">&nbsp;public final class Styles {</b>
&nbsp;  private final StyleInfo style;
&nbsp;  private final Scheme scheme;
&nbsp;  private final Depluralizer depluralizer;
&nbsp;
<b class="nc">&nbsp;  Styles(StyleInfo style) {</b>
<b class="nc">&nbsp;    this.style = style;</b>
<b class="nc">&nbsp;    this.depluralizer = depluralizerFor(style);</b>
<b class="nc">&nbsp;    this.scheme = new Scheme();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static Depluralizer depluralizerFor(StyleInfo style) {
<b class="nc">&nbsp;    return style.depluralize()</b>
<b class="nc">&nbsp;        ? new Depluralizer.DictionaryAidedDepluralizer(style.depluralizeDictionary())</b>
<b class="nc">&nbsp;        : Depluralizer.NONE;</b>
&nbsp;  }
&nbsp;
&nbsp;  Scheme scheme() {
<b class="nc">&nbsp;    return scheme;</b>
&nbsp;  }
&nbsp;
&nbsp;  public ValueImmutableInfo defaults() {
<b class="nc">&nbsp;    return style.defaults();</b>
&nbsp;  }
&nbsp;
&nbsp;  public StyleInfo style() {
<b class="nc">&nbsp;    return style;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isImmutableIdentityNaming() {
<b class="nc">&nbsp;    return scheme.typeImmutable.isIdentity();</b>
&nbsp;  }
&nbsp;
&nbsp;  PackageNaming packageGenerated() {
<b class="nc">&nbsp;    return scheme.packageGenerated;</b>
&nbsp;  }
&nbsp;
&nbsp;  public UsingName.TypeNames forType(String name) {
<b class="nc">&nbsp;    return new UsingName(name, scheme, depluralizer, &quot;&quot;).new TypeNames();</b>
&nbsp;  }
&nbsp;
&nbsp;  public UsingName.AttributeNames forAccessorWithRaw(String name, String raw) {
<b class="nc">&nbsp;    return new UsingName(name, scheme, depluralizer, raw).new AttributeNames();</b>
&nbsp;  }
&nbsp;
&nbsp;  public UsingName.AttributeNames forAccessor(String name) {
<b class="nc">&nbsp;    return forAccessorWithRaw(name, &quot;&quot;);</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  class Scheme {</b>
<b class="nc">&nbsp;    PackageNaming packageGenerated = PackageNaming.from(style().packageGenerated());</b>
<b class="nc">&nbsp;    Naming[] typeAbstract = Naming.fromAll(style.typeAbstract());</b>
<b class="nc">&nbsp;    Naming typeImmutable = Naming.from(style.typeImmutable());</b>
<b class="nc">&nbsp;    Naming typeImmutableNested = Naming.from(style.typeImmutableNested());</b>
<b class="nc">&nbsp;    Naming typeImmutableEnclosing = Naming.from(style.typeImmutableEnclosing());</b>
<b class="nc">&nbsp;    Naming of = Naming.from(style.of());</b>
<b class="nc">&nbsp;    Naming copyOf = Naming.from(style.copyOf());</b>
<b class="nc">&nbsp;    Naming instance = Naming.from(style.instance());</b>
&nbsp;
<b class="nc">&nbsp;    Naming typeWith = Naming.from(style.typeWith());</b>
<b class="nc">&nbsp;    Naming typeBuilder = Naming.from(style.typeBuilder());</b>
<b class="nc">&nbsp;    Naming typeInnerBuilder = Naming.from(style.typeInnerBuilder());</b>
<b class="nc">&nbsp;    Naming from = Naming.from(style.from());</b>
<b class="nc">&nbsp;    Naming build = Naming.from(style.build());</b>
<b class="nc">&nbsp;    Naming buildOrThrow = Naming.from(style.buildOrThrow());</b>
<b class="nc">&nbsp;    Naming canBuild = Naming.from(style.canBuild());</b>
<b class="nc">&nbsp;    Naming toBuilder = Naming.from(style.toBuilder());</b>
&nbsp;
<b class="nc">&nbsp;    Naming builder = Naming.from(style.builder());</b>
<b class="nc">&nbsp;    Naming newBuilder = Naming.from(style.newBuilder());</b>
&nbsp;
<b class="nc">&nbsp;    Naming[] get = Naming.fromAll(style.get());</b>
<b class="nc">&nbsp;    Naming init = Naming.from(style.init());</b>
<b class="nc">&nbsp;    Naming with = Naming.from(style.with());</b>
<b class="nc">&nbsp;    Naming withUnaryOperator = Naming.from(style.withUnaryOperator());</b>
&nbsp;
<b class="nc">&nbsp;    Naming add = Naming.from(style.add());</b>
<b class="nc">&nbsp;    Naming addAll = Naming.from(style.addAll());</b>
<b class="nc">&nbsp;    Naming put = Naming.from(style.put());</b>
<b class="nc">&nbsp;    Naming putAll = Naming.from(style.putAll());</b>
&nbsp;
<b class="nc">&nbsp;    Naming isInitialized = Naming.from(style.isInitialized());</b>
<b class="nc">&nbsp;    Naming isSet = Naming.from(style.isSet());</b>
<b class="nc">&nbsp;    Naming unset = Naming.from(style.unset());</b>
<b class="nc">&nbsp;    Naming set = Naming.from(style.set());</b>
<b class="nc">&nbsp;    Naming clear = Naming.from(style.clear());</b>
<b class="nc">&nbsp;    Naming create = Naming.from(style.create());</b>
<b class="nc">&nbsp;    Naming toImmutable = Naming.from(style.toImmutable());</b>
<b class="nc">&nbsp;    Naming typeModifiable = Naming.from(style.typeModifiable());</b>
<b class="nc">&nbsp;    Naming typeInnerModifiable = Naming.from(style.typeInnerModifiable());</b>
&nbsp;
<b class="nc">&nbsp;    Naming[] attributeBuilder = Naming.fromAll(style.attributeBuilder());</b>
<b class="nc">&nbsp;    Naming getBuilder = Naming.from(style.getBuilder());</b>
<b class="nc">&nbsp;    Naming setBuilder = Naming.from(style.setBuilder());</b>
&nbsp;
<b class="nc">&nbsp;    Naming addBuilder = Naming.from(style.addBuilder());</b>
<b class="nc">&nbsp;    Naming addAllBuilder = Naming.from(style.addAllBuilder());</b>
<b class="nc">&nbsp;    Naming getBuilders = Naming.from(style.getBuilders());</b>
&nbsp;
<b class="nc">&nbsp;    String nullableAnnotation = style.nullableAnnotation();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public static class UsingName {</b>
&nbsp;    private final String name;
&nbsp;    private final Scheme scheme;
&nbsp;    private final String forcedRaw;
&nbsp;    private final Depluralizer depluralizer;
&nbsp;
<b class="nc">&nbsp;    private UsingName(String name, Scheme scheme, Depluralizer depluralizer, String forcedRaw) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.scheme = scheme;</b>
<b class="nc">&nbsp;      this.depluralizer = depluralizer;</b>
<b class="nc">&nbsp;      this.forcedRaw = forcedRaw;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String detectRawFrom(String name) {
<b class="nc">&nbsp;      if (!forcedRaw.isEmpty()) {</b>
<b class="nc">&nbsp;        return forcedRaw;</b>
&nbsp;      }
<b class="nc">&nbsp;      for (Naming naming : scheme.get) {</b>
<b class="nc">&nbsp;        String raw = naming.detect(name);</b>
<b class="nc">&nbsp;        if (!raw.isEmpty()) {</b>
<b class="nc">&nbsp;          return raw;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String detectRawFromAbstract() {
<b class="nc">&nbsp;      if (!forcedRaw.isEmpty()) {</b>
<b class="nc">&nbsp;        return forcedRaw;</b>
&nbsp;      }
<b class="nc">&nbsp;      return detectRawFromAbstract(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Forced raw will not work if using this method */
&nbsp;    String detectRawFromAbstract(String abstractName) {
<b class="nc">&nbsp;      for (Naming naming : scheme.typeAbstract) {</b>
<b class="nc">&nbsp;        String raw = naming.detect(abstractName);</b>
<b class="nc">&nbsp;        if (!raw.isEmpty()) {</b>
&nbsp;          // TBD is there a way to raise abstraction
<b class="nc">&nbsp;          return CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, raw);</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return abstractName;</b>
&nbsp;    }
&nbsp;
&nbsp;    String detectRawFromAttributeBuilder(String attributeBuilderName) {
<b class="nc">&nbsp;      for (Naming naming : scheme.attributeBuilder) {</b>
<b class="nc">&nbsp;        String raw = naming.detect(attributeBuilderName);</b>
<b class="nc">&nbsp;        if (!raw.isEmpty()) {</b>
<b class="nc">&nbsp;          return raw;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public class TypeNames {</b>
<b class="nc">&nbsp;      public final Scheme namings = scheme;</b>
<b class="nc">&nbsp;      public final String raw = detectRawFromAbstract();</b>
<b class="nc">&nbsp;      public final String typeAbstract = name;</b>
<b class="nc">&nbsp;      public final String typeImmutable = scheme.typeImmutable.apply(raw);</b>
<b class="nc">&nbsp;      public final String of = scheme.of.apply(raw);</b>
<b class="nc">&nbsp;      public final String instance = scheme.instance.apply(raw);</b>
&nbsp;      // Builder template is being applied programatically in Constitution class
&nbsp;      // public final String typeBuilder = scheme.typeBuilder.apply(raw);
<b class="nc">&nbsp;      public final String copyOf = scheme.copyOf.apply(raw);</b>
<b class="nc">&nbsp;      public final String from = scheme.from.apply(raw);</b>
<b class="nc">&nbsp;      public final String build = scheme.build.apply(raw);</b>
<b class="nc">&nbsp;      public final String nullableAnnotation = scheme.nullableAnnotation;</b>
&nbsp;
&nbsp;      public final String typeWith() {
<b class="nc">&nbsp;        return scheme.typeWith.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String typeImmutableEnclosing() {
<b class="nc">&nbsp;        return scheme.typeImmutableEnclosing.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String typeImmutableNested() {
<b class="nc">&nbsp;        return scheme.typeImmutableNested.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String builder() {
<b class="nc">&nbsp;        return scheme.builder.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String buildOrThrow() {
<b class="nc">&nbsp;        return scheme.buildOrThrow.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String canBuild() {
<b class="nc">&nbsp;        return scheme.canBuild.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String toBuilder() {
<b class="nc">&nbsp;        return scheme.toBuilder.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String isInitialized() {
<b class="nc">&nbsp;        return scheme.isInitialized.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String create() {
<b class="nc">&nbsp;        return scheme.create.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String clear() {
<b class="nc">&nbsp;        return scheme.clear.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String toImmutable() {
<b class="nc">&nbsp;        return scheme.toImmutable.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final String typeModifiable() {
<b class="nc">&nbsp;        return scheme.typeModifiable.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      String rawFromAbstract(String abstractName) {
<b class="nc">&nbsp;        return detectRawFromAbstract(abstractName);</b>
&nbsp;      }
&nbsp;
&nbsp;      String rawFromAttributeBuilder(String attributeBuilderName) {
<b class="nc">&nbsp;        return detectRawFromAttributeBuilder(attributeBuilderName);</b>
&nbsp;      }
&nbsp;
&nbsp;      public final boolean newTokenInAttributeBuilder() {
<b class="nc">&nbsp;        for (Naming pattern : scheme.attributeBuilder) {</b>
<b class="nc">&nbsp;          if (pattern.toString().equals(&quot;new&quot;)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
&nbsp;      public final boolean possibleAttributeBuilder(Name name) {
<b class="nc">&nbsp;        for (Naming pattern : scheme.attributeBuilder) {</b>
<b class="nc">&nbsp;          String foundPattern = pattern.detect(name.toString());</b>
<b class="nc">&nbsp;          if (!foundPattern.isEmpty()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public final class AttributeNames {</b>
<b class="nc">&nbsp;      public final String raw = detectRawFrom(name);</b>
<b class="nc">&nbsp;      private final boolean rawIsKeyword = SourceVersion.isKeyword(raw);</b>
&nbsp;
<b class="nc">&nbsp;      public final String get = name;</b>
<b class="nc">&nbsp;      public final String var = apply(Naming.identity(), false);</b>
<b class="nc">&nbsp;      public final String init = apply(scheme.init, false);</b>
<b class="nc">&nbsp;      public final String with = apply(scheme.with, false);</b>
&nbsp;
&nbsp;      public String withUnaryOperator() {
<b class="nc">&nbsp;        return apply(scheme.withUnaryOperator, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String add() {
<b class="nc">&nbsp;        return forCollection().add;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String addv() {
<b class="nc">&nbsp;        return forCollection().addv;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String put() {
<b class="nc">&nbsp;        return forCollection().put;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String putv() {
<b class="nc">&nbsp;        return forCollection().putv;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String addAll() {
<b class="nc">&nbsp;        return forCollection().addAll;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String putAll() {
<b class="nc">&nbsp;        return forCollection().putAll;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String set() {
<b class="nc">&nbsp;        return apply(scheme.set, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String isSet() {
<b class="nc">&nbsp;        return apply(scheme.isSet, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String unset() {
<b class="nc">&nbsp;        return apply(scheme.unset, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String beanSet() {
<b class="nc">&nbsp;        return apply(BEAN_SET, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String getBuilder() {
<b class="nc">&nbsp;        return apply(scheme.getBuilder, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String setBuilder() {
<b class="nc">&nbsp;        return apply(scheme.setBuilder, false);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String addBuilder() {
<b class="nc">&nbsp;        return forCollection().addBuilder;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String addAllBuilder() {
<b class="nc">&nbsp;        return forCollection().addAllBuilder;</b>
&nbsp;      }
&nbsp;
&nbsp;      public String getBuilders() {
<b class="nc">&nbsp;        return forCollection().getBuilders;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      public final class ForCollections {</b>
<b class="nc">&nbsp;        private final String singular = depluralizer.depluralize(raw);</b>
<b class="nc">&nbsp;        private final boolean singularIsKeyword = SourceVersion.isKeyword(singular);</b>
&nbsp;
<b class="nc">&nbsp;        final String add = applySingular(scheme.add);</b>
<b class="nc">&nbsp;        final String addv = applyRegular(scheme.add); // vararg version</b>
<b class="nc">&nbsp;        final String put = applySingular(scheme.put);</b>
<b class="nc">&nbsp;        final String putv = applyRegular(scheme.put); // vararg version</b>
<b class="nc">&nbsp;        final String addAll = applyRegular(scheme.addAll);</b>
<b class="nc">&nbsp;        final String putAll = applyRegular(scheme.putAll);</b>
<b class="nc">&nbsp;        final String addBuilder = applySingular(scheme.addBuilder);</b>
<b class="nc">&nbsp;        final String addAllBuilder = applySingular(scheme.addAllBuilder);</b>
<b class="nc">&nbsp;        final String getBuilders = applySingular(scheme.getBuilders);</b>
&nbsp;
&nbsp;        String applySingular(Naming naming) {
<b class="nc">&nbsp;          if (singularIsKeyword &amp;&amp; naming.isIdentity()) {</b>
<b class="nc">&nbsp;            return applyRegular(naming);</b>
&nbsp;          }
<b class="nc">&nbsp;          return naming.apply(singular);</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      private String applyRegular(Naming naming) {
<b class="nc">&nbsp;        if (rawIsKeyword &amp;&amp; naming.isIdentity()) {</b>
<b class="nc">&nbsp;          return name;</b>
&nbsp;        }
<b class="nc">&nbsp;        return naming.apply(raw);</b>
&nbsp;      }
&nbsp;
&nbsp;      public String apply(Naming naming, boolean depluralize) {
<b class="nc">&nbsp;        return depluralize</b>
<b class="nc">&nbsp;            ? forCollection().applySingular(naming)</b>
<b class="nc">&nbsp;            : applyRegular(naming);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      private ForCollections coll = null;</b>
&nbsp;
&nbsp;      private ForCollections forCollection() {
<b class="nc">&nbsp;        return coll == null ? coll = new ForCollections() : coll;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Plain {@link Naming} does not fit package name patterns and pimping it will uselessly
&nbsp;   * compilcate things. So here we&#39;re creating separate ad-hoc dead-simple naming pattern formatter
&nbsp;   * for package name templates.
&nbsp;   */
&nbsp;  static final class PackageNaming {
&nbsp;    private final String template;
&nbsp;
<b class="nc">&nbsp;    PackageNaming(String template) {</b>
<b class="nc">&nbsp;      this.template = template;</b>
&nbsp;    }
&nbsp;
&nbsp;    String apply(String name) {
<b class="nc">&nbsp;      return template.replace(&quot;*&quot;, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    static PackageNaming from(String template) {
<b class="nc">&nbsp;      return new PackageNaming(template);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return template;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static final Naming BEAN_SET = Naming.from(&quot;set*&quot;);</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
