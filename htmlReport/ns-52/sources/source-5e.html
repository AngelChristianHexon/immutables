


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ValueAttribute</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: ValueAttribute (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ValueAttribute</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/209)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/789)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/773)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ValueAttribute$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueAttribute$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueAttribute$NullElements</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueAttribute$OrderKind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueAttribute$ToName</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ValueAttribute$WholeTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/224)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/799)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/796)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2013-2018 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.Ascii;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Joiner;
&nbsp;import com.google.common.base.MoreObjects;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import org.immutables.generator.AnnotationMirrors;
&nbsp;import org.immutables.generator.StringLiterals;
&nbsp;import org.immutables.generator.TypeHierarchyCollector;
&nbsp;import org.immutables.value.processor.encode.Instantiation;
&nbsp;import org.immutables.value.processor.encode.Instantiator.InstantiationCreator;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.AnnotationInjection;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.InjectAnnotation.Where;
&nbsp;import org.immutables.value.processor.meta.AnnotationInjections.InjectionInfo;
&nbsp;import org.immutables.value.processor.meta.Generics.Parameter;
&nbsp;import org.immutables.value.processor.meta.Proto.DeclaringType;
&nbsp;import org.immutables.value.processor.meta.Proto.Environment;
&nbsp;import org.immutables.value.processor.meta.Proto.MetaAnnotated;
&nbsp;import org.immutables.value.processor.meta.Proto.Protoclass;
&nbsp;import org.immutables.value.processor.meta.Reporter.About;
&nbsp;import org.immutables.value.processor.meta.Styles.UsingName.AttributeNames;
&nbsp;import org.immutables.value.processor.meta.ValueMirrors.Style.ImplementationVisibility;
&nbsp;import org.immutables.value.processor.meta.ValueMirrors.Style.ValidationMethod;
&nbsp;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.lang.model.element.AnnotationMirror;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.Name;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.type.ArrayType;
&nbsp;import javax.lang.model.type.DeclaredType;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.type.TypeMirror;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;/**
&nbsp; * It&#39;s pointless to refactor this mess until
&nbsp; * 1) Some sort of type calculus toolkit used/created
&nbsp; * 2) Facets/Implicits in Generator toolkit with auto-memoising implemented
&nbsp; */
<b class="nc">&nbsp;public final class ValueAttribute extends TypeIntrospectionBase implements HasStyleInfo {</b>
<b class="nc">&nbsp;  private static final WholeTypeVariable NON_WHOLE_TYPE_VARIABLE = new WholeTypeVariable(-1);</b>
&nbsp;  private static final int CONSTRUCTOR_PARAMETER_DEFAULT_ORDER = 0;
&nbsp;  private static final int CONSTRUCTOR_NOT_A_PARAMETER = -1;
<b class="nc">&nbsp;  private static final String GUAVA_IMMUTABLE_PREFIX = UnshadeGuava.typeString(&quot;collect.Immutable&quot;);</b>
&nbsp;  private static final String VALUE_ATTRIBUTE_NAME = &quot;value&quot;;
&nbsp;  private static final String ID_ATTRIBUTE_NAME = &quot;_id&quot;;
<b class="nc">&nbsp;  private static final String[] EMPTY_SERIALIZED_NAMES = {};</b>
&nbsp;
&nbsp;  public AttributeNames names;
&nbsp;  public boolean isGenerateDefault;
&nbsp;  public boolean isGenerateDerived;
&nbsp;  public boolean isGenerateAbstract;
&nbsp;  public boolean isGenerateLazy;
&nbsp;  public boolean isAttributeBuilder;
<b class="nc">&nbsp;  public ImmutableList&lt;String&gt; typeParameters = ImmutableList.of();</b>
<b class="nc">&nbsp;  public ImmutableList&lt;AnnotationInjection&gt; annotationInjections = ImmutableList.of();</b>
&nbsp;  // Replace with delegation?
&nbsp;  public Reporter reporter;
&nbsp;
&nbsp;  public ValueType containingType;
&nbsp;
&nbsp;  @Nullable
&nbsp;  public ValueType attributeValueType;
&nbsp;
&nbsp;  TypeMirror returnType;
&nbsp;  Element element;
&nbsp;  String returnTypeName;
&nbsp;  // Set only if isAttributeBuilder is true
&nbsp;  @Nullable
&nbsp;  private AttributeBuilderDescriptor attributeBuilderDescriptor;
&nbsp;
&nbsp;  public boolean hasEnumFirstTypeParameter;
&nbsp;
&nbsp;  @Nullable
&nbsp;  TypeElement containedTypeElement;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private TypeElement containedSecondaryTypeElement;
&nbsp;
&nbsp;  private boolean generateOrdinalValueSet;
&nbsp;  private TypeMirror arrayComponent;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private NullabilityAnnotationInfo nullability;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private NullabilityAnnotationInfo nullabilityInSupertype;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private String rawTypeName;
&nbsp;
&nbsp;  @Nullable
&nbsp;  private CriteriaModel criteriaModel;
&nbsp;
&nbsp;  public String name() {
<b class="nc">&nbsp;    return names.var;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Expose criteria metadata like list of matchers for current attribute.
&nbsp;   */
&nbsp;  public CriteriaModel criteria() {
<b class="nc">&nbsp;    CriteriaModel model = criteriaModel;</b>
<b class="nc">&nbsp;    if (model == null) {</b>
<b class="nc">&nbsp;      model = new CriteriaModel(this);</b>
<b class="nc">&nbsp;      criteriaModel = model;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return model;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isBoolean() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.BOOLEAN;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isInt() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.INT;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isShort() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.SHORT;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isChar() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.CHAR;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isByte() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.BYTE;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isLong() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.LONG;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isStringType() {
<b class="nc">&nbsp;    return String.class.getName().equals(rawTypeName);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean charType() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.CHAR;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String atNullability() {
<b class="nc">&nbsp;    return nullability != null ? nullability.asPrefix() : &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String atNullabilityOriginal() {
<b class="nc">&nbsp;    return nullability != null ? nullability.asPrefixOriginal() : &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String atNullabilityLocal() {
<b class="nc">&nbsp;    return nullability != null ? nullability.asLocalPrefix() : &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSimpleLiteralType() {
<b class="nc">&nbsp;    return isPrimitive()</b>
<b class="nc">&nbsp;        || isStringType()</b>
<b class="nc">&nbsp;        || isEnumType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasSimpleScalarElementType() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
&nbsp;
<b class="nc">&nbsp;    String type = getWrappedElementType();</b>
<b class="nc">&nbsp;    return isStringType()</b>
<b class="nc">&nbsp;        || String.class.getName().equals(type)</b>
<b class="nc">&nbsp;        || isPrimitiveWrappedType(type)</b>
<b class="nc">&nbsp;        || hasEnumContainedElementType()</b>
<b class="nc">&nbsp;        || isEnumType()</b>
<b class="nc">&nbsp;        || isJdkSpecializedOptional()</b>
<b class="nc">&nbsp;        || extendedClassesNames.contains(Number.class.getName());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean requiresAlternativeStrictConstructor() {
<b class="nc">&nbsp;    return typeKind.isCollectionKind()</b>
<b class="nc">&nbsp;        || (typeKind.isMappingKind()</b>
<b class="nc">&nbsp;            &amp;&amp; !typeKind.isPlainMapKind()</b>
<b class="nc">&nbsp;            &amp;&amp; !typeKind.isMultimap());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSettable() {
<b class="nc">&nbsp;    return isGenerateAbstract</b>
&nbsp;        || isGenerateDefault;
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGettable() {
<b class="nc">&nbsp;    return isGenerateAbstract</b>
&nbsp;        || isGenerateDefault
&nbsp;        || isGenerateDerived
&nbsp;        || isGenerateLazy;
&nbsp;  }
&nbsp;
&nbsp;  public boolean isIgnorable() {
<b class="nc">&nbsp;    return isGenerateLazy || isJsonIgnore() || isGsonOther() || isDataIgnore();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isOmittable() {
<b class="nc">&nbsp;    return !isMandatory() || isDataIgnore();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isMandatory() {
<b class="nc">&nbsp;    return isGenerateAbstract</b>
&nbsp;        &amp;&amp; !isGenerateDefault // is the case for defaulted abstract annotation attribute
<b class="nc">&nbsp;        &amp;&amp; !isContainerType()</b>
<b class="nc">&nbsp;        &amp;&amp; !(isPrimitive() &amp;&amp; (validation() == ValidationMethod.NONE</b>
<b class="nc">&nbsp;        || validation() == ValidationMethod.VALIDATION_API))</b>
<b class="nc">&nbsp;        &amp;&amp; !(isNullable() &amp;&amp; !isNullabilitySynthetic())</b>
<b class="nc">&nbsp;        &amp;&amp; !isEncoding()</b>
<b class="nc">&nbsp;        &amp;&amp; !hasBuilderSwitcherDefault();</b>
&nbsp;  }
&nbsp;
&nbsp;  private ValidationMethod validation() {
<b class="nc">&nbsp;    return protoclass().styles().style().validationMethod();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks if type defined by this attribute has associated criteria (see {@code @Criteria})
&nbsp;   */
&nbsp;  public boolean hasCriteria() {
<b class="nc">&nbsp;    return attributeValueType != null &amp;&amp; attributeValueType.isGenerateCriteria();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNullable() {
<b class="nc">&nbsp;    return nullability != null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNullabilitySynthetic() {
<b class="nc">&nbsp;    return nullability != null &amp;&amp; nullability.isSynthetic();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public ImmutableList&lt;String&gt; docComment = ImmutableList.of();</b>
&nbsp;
&nbsp;  public boolean deprecated;
&nbsp;
&nbsp;  public boolean isMaybeComparableKey() {
<b class="nc">&nbsp;    return isContainerType()</b>
<b class="nc">&nbsp;        &amp;&amp; (super.isComparable() || this.containedTypeElement == null);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public boolean isComparable() {
<b class="nc">&nbsp;    return isNumberType()</b>
<b class="nc">&nbsp;        || isStringType()</b>
<b class="nc">&nbsp;        || (!(isCollectionType() || isMapType()) &amp;&amp; super.isComparable());</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;CharSequence&gt; jsonQualifierAnnotations;
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getJsonQualiferAnnotations() {
<b class="nc">&nbsp;    if (jsonQualifierAnnotations == null) {</b>
<b class="nc">&nbsp;      List&lt;CharSequence&gt; annotationStrings = Collections.emptyList();</b>
<b class="nc">&nbsp;      for (AnnotationMirror m : element.getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;        if (MetaAnnotated.from(m, protoclass().environment()).isJsonQualifier()) {</b>
<b class="nc">&nbsp;          if (annotationStrings.isEmpty()) {</b>
<b class="nc">&nbsp;            annotationStrings = Lists.newArrayList();</b>
&nbsp;          }
<b class="nc">&nbsp;          annotationStrings.add(AnnotationMirrors.toCharSequence(m));</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      jsonQualifierAnnotations = annotationStrings;</b>
&nbsp;    }
<b class="nc">&nbsp;    return jsonQualifierAnnotations;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private String serializedName;
&nbsp;
<b class="nc">&nbsp;  private String[] alternateSerializedNames = EMPTY_SERIALIZED_NAMES;</b>
&nbsp;
&nbsp;  public String[] getAlternateSerializedNames() {
<b class="nc">&nbsp;    getSerializedName();// trigger lazy init</b>
<b class="nc">&nbsp;    return alternateSerializedNames;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Serialized name, actully specified via annotation
&nbsp;   * @return name for JSON as overriden.
&nbsp;   */
&nbsp;  public String getSerializedName() {
<b class="nc">&nbsp;    if (serializedName == null) {</b>
<b class="nc">&nbsp;      Optional&lt;SerializedNameMirror&gt; serializedNameAnnotation = SerializedNameMirror.find(element);</b>
<b class="nc">&nbsp;      if (serializedNameAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;        SerializedNameMirror m = serializedNameAnnotation.get();</b>
<b class="nc">&nbsp;        serializedName = m.value();</b>
<b class="nc">&nbsp;        alternateSerializedNames = m.alternate();</b>
<b class="nc">&nbsp;        return serializedName;</b>
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;NamedMirror&gt; namedAnnotation = NamedMirror.find(element);</b>
<b class="nc">&nbsp;      if (namedAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;        String value = namedAnnotation.get().value();</b>
<b class="nc">&nbsp;        if (!value.isEmpty()) {</b>
<b class="nc">&nbsp;          serializedName = value;</b>
<b class="nc">&nbsp;          return serializedName;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      Optional&lt;OkNamedMirror&gt; okNamedAnnotation = OkNamedMirror.find(element);</b>
<b class="nc">&nbsp;      if (okNamedAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;        String value = okNamedAnnotation.get().name();</b>
<b class="nc">&nbsp;        if (!value.isEmpty()) {</b>
<b class="nc">&nbsp;          serializedName = value;</b>
<b class="nc">&nbsp;          return serializedName;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      if (isMarkedAsMongoId()) {</b>
<b class="nc">&nbsp;        serializedName = ID_ATTRIBUTE_NAME;</b>
<b class="nc">&nbsp;        return serializedName;</b>
&nbsp;      }
<b class="nc">&nbsp;      serializedName = &quot;&quot;;</b>
<b class="nc">&nbsp;      return serializedName;</b>
&nbsp;    }
<b class="nc">&nbsp;    return serializedName;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Marshaled name for compatibility with repository.
&nbsp;   * @return get JSON name either specified or default.
&nbsp;   */
&nbsp;  public String getMarshaledName() {
<b class="nc">&nbsp;    String serializedName = getSerializedName();</b>
<b class="nc">&nbsp;    if (!serializedName.isEmpty()) {</b>
<b class="nc">&nbsp;      return serializedName;</b>
&nbsp;    }
<b class="nc">&nbsp;    return names.raw;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private @Nullable Boolean isGsonOther = null;</b>
&nbsp;
&nbsp;  public boolean isGsonOther() {
<b class="nc">&nbsp;    if (isGsonOther == null) {</b>
<b class="nc">&nbsp;      if (GsonOtherMirror.isPresent(element)) {</b>
<b class="nc">&nbsp;        if (!isGenerateAbstract || !rawTypeName.equals(GsonMirrors.JSON_OBJECT_TYPE)) {</b>
<b class="nc">&nbsp;          report().error(</b>
&nbsp;              &quot;@Gson.Other attribute must be abstract accessor of type %s&quot;,
&nbsp;              GsonMirrors.JSON_OBJECT_TYPE);
<b class="nc">&nbsp;          isGsonOther = false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;          isGsonOther = true;</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        isGsonOther = false;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return isGsonOther;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isForcedEmpty() {
<b class="nc">&nbsp;    return !containingType.gsonTypeAdapters().emptyAsNulls();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected TypeMirror internalTypeMirror() {
<b class="nc">&nbsp;    return returnType;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getType() {
<b class="nc">&nbsp;    return returnTypeName;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getAnnotations() {
<b class="nc">&nbsp;    if (containingType.isGenerateJacksonProperties()) {</b>
<b class="nc">&nbsp;      return extractAnnotationsForElement(</b>
&nbsp;          ElementType.METHOD,
<b class="nc">&nbsp;          protoclass().styles().style().passAnnotationsNames());</b>
&nbsp;
&nbsp;    }
<b class="nc">&nbsp;    return Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;        protoclass().styles().style().passAnnotationsNames(),</b>
&nbsp;        false,
&nbsp;        ElementType.METHOD,
&nbsp;        importsResolver,
&nbsp;        nullability);
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getFieldAnnotations() {
<b class="nc">&nbsp;    return Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;        protoclass().styles().style().passAnnotationsNames(),</b>
&nbsp;        false,
&nbsp;        ElementType.FIELD,
&nbsp;        importsResolver,
&nbsp;        null/* do not propagate nullable here */);
&nbsp;  }
&nbsp;
&nbsp;  public CharSequence getConstructorParameterAnnotations() {
<b class="nc">&nbsp;    List&lt;CharSequence&gt; annotations =</b>
<b class="nc">&nbsp;        Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;            protoclass().styles().style().passAnnotationsNames(),</b>
&nbsp;            false,
&nbsp;            ElementType.PARAMETER,
&nbsp;            importsResolver,
&nbsp;            nullability);
&nbsp;
<b class="nc">&nbsp;    if (!annotations.isEmpty()) {</b>
<b class="nc">&nbsp;      return Joiner.on(&#39; &#39;).join(annotations).concat(&quot; &quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getJacksonFieldsAnnotations() {
<b class="nc">&nbsp;    return extractAnnotationsForElement(ElementType.FIELD, Collections.&lt;String&gt;emptySet());</b>
&nbsp;  }
&nbsp;
&nbsp;  private CharSequence jacksonPropertyAnnotation() {
<b class="nc">&nbsp;    StringBuilder propertyAnnotation = new StringBuilder(&quot;@&quot;).append(Annotations.JACKSON_PROPERTY);</b>
<b class="nc">&nbsp;    if (protoclass().styles().style().forceJacksonPropertyNames()) {</b>
<b class="nc">&nbsp;      propertyAnnotation.append(&#39;(&#39;).append(StringLiterals.toLiteral(names.raw)).append(&#39;)&#39;);</b>
&nbsp;    }
<b class="nc">&nbsp;    return propertyAnnotation;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;CharSequence&gt; getBuilderAttributeAnnotation() {
<b class="nc">&nbsp;    if (containingType.isGenerateJacksonProperties()</b>
<b class="nc">&nbsp;        &amp;&amp; protoclass().isJacksonDeserialized()) {</b>
<b class="nc">&nbsp;      List&lt;CharSequence&gt; jacksonPropertyAnnotation = Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;          Collections.singleton(Annotations.JACKSON_PROPERTY),</b>
&nbsp;          false,
&nbsp;          ElementType.METHOD,
&nbsp;          importsResolver,
&nbsp;          nullability);
<b class="nc">&nbsp;      List&lt;CharSequence&gt; annotations = Lists.newArrayList();</b>
<b class="nc">&nbsp;      if (jacksonPropertyAnnotation.isEmpty()) {</b>
<b class="nc">&nbsp;        annotations.add(jacksonPropertyAnnotation());</b>
&nbsp;      }
<b class="nc">&nbsp;      annotations.addAll(Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;          Collections.&lt;String&gt;emptySet(),</b>
<b class="nc">&nbsp;          protoclass().environment().hasJacksonLib(),</b>
&nbsp;          ElementType.METHOD,
&nbsp;          importsResolver,
&nbsp;          nullability));
<b class="nc">&nbsp;      return annotations;</b>
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;CharSequence&gt; extractAnnotationsForElement(ElementType elementType, Set&lt;String&gt; additionalAnnotations) {
<b class="nc">&nbsp;    List&lt;CharSequence&gt; allAnnotations = Lists.newArrayListWithCapacity(1);</b>
&nbsp;
<b class="nc">&nbsp;    boolean dontHaveJsonPropetyAnnotationAlready = Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;        Collections.singleton(Annotations.JACKSON_PROPERTY),</b>
&nbsp;        false,
&nbsp;        elementType,
&nbsp;        importsResolver,
<b class="nc">&nbsp;        nullability).isEmpty();</b>
&nbsp;
<b class="nc">&nbsp;    if (dontHaveJsonPropetyAnnotationAlready) {</b>
<b class="nc">&nbsp;      allAnnotations.add(jacksonPropertyAnnotation());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    allAnnotations.addAll(</b>
<b class="nc">&nbsp;        Annotations.getAnnotationLines(element,</b>
<b class="nc">&nbsp;            Sets.union(additionalAnnotations,</b>
<b class="nc">&nbsp;                protoclass().styles().style().additionalJsonAnnotationsNames()),</b>
<b class="nc">&nbsp;            protoclass().environment().hasJacksonLib(),</b>
&nbsp;            elementType,
&nbsp;            importsResolver,
&nbsp;            nullability));
&nbsp;
<b class="nc">&nbsp;    return allAnnotations;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJsonIgnore() {
<b class="nc">&nbsp;    return IgnoreMirror.isPresent(element)</b>
<b class="nc">&nbsp;        || OkIgnoreMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDataIgnore() {
<b class="nc">&nbsp;    return DataIgnoreMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;String&gt; typeParameters() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    if (arrayComponent != null) {</b>
<b class="nc">&nbsp;      return typeParameters.subList(0, 1);</b>
&nbsp;    }
<b class="nc">&nbsp;    return typeParameters;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isMapType() {
<b class="nc">&nbsp;    return typeKind.isMappingKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isMultimapType() {
<b class="nc">&nbsp;    return typeKind.isMultimapKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isListType() {
<b class="nc">&nbsp;    return typeKind.isList();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private OrderKind orderKind = OrderKind.NONE;</b>
&nbsp;
<b class="nc">&nbsp;  private enum OrderKind {</b>
<b class="nc">&nbsp;    NONE, NATURAL, REVERSE</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSetType() {
<b class="nc">&nbsp;    return typeKind.isSet();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasNaturalOrder() {
<b class="nc">&nbsp;    return orderKind == OrderKind.NATURAL;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasReverseOrder() {
<b class="nc">&nbsp;    return orderKind == OrderKind.REVERSE;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSortedSetType() {
<b class="nc">&nbsp;    return typeKind.isSortedSet();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSortedMapType() {
<b class="nc">&nbsp;    return typeKind.isSortedMap();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateSortedSet() {
<b class="nc">&nbsp;    return typeKind.isSortedSet();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateSortedMap() {
<b class="nc">&nbsp;    return typeKind.isSortedMap();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateSortedMultiset() {
<b class="nc">&nbsp;    return typeKind.isSortedMultiset();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void checkOrderAnnotations() {
<b class="nc">&nbsp;    Optional&lt;NaturalOrderMirror&gt; naturalOrderAnnotation = NaturalOrderMirror.find(element);</b>
<b class="nc">&nbsp;    Optional&lt;ReverseOrderMirror&gt; reverseOrderAnnotation = ReverseOrderMirror.find(element);</b>
&nbsp;
<b class="nc">&nbsp;    if (naturalOrderAnnotation.isPresent() &amp;&amp; reverseOrderAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;      report()</b>
<b class="nc">&nbsp;          .error(&quot;@Value.Natural and @Value.Reverse annotations cannot be used on the same attribute&quot;);</b>
<b class="nc">&nbsp;    } else if (naturalOrderAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;      configureOrdering(OrderKind.NATURAL, NaturalOrderMirror.simpleName());</b>
<b class="nc">&nbsp;    } else if (reverseOrderAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;      configureOrdering(OrderKind.REVERSE, ReverseOrderMirror.simpleName());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void configureOrdering(OrderKind orderKind, String annotationName) {
<b class="nc">&nbsp;    if (typeKind.isSortedKind()) {</b>
<b class="nc">&nbsp;      if (isMaybeComparableKey()) {</b>
<b class="nc">&nbsp;        this.orderKind = orderKind;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        reportOrderingError(annotationName, &quot;requires that a (multi)set&#39;s elements or a map&#39;s keys are Comparable&quot;);</b>
&nbsp;      }
&nbsp;    } else {
<b class="nc">&nbsp;      reportOrderingError(annotationName, &quot;can be applied only to SortedSet, SortedMap and SortedMultiset attributes&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void reportOrderingError(String annotationName, String msg) {
<b class="nc">&nbsp;    report().annotationNamed(annotationName).error(String.format(&quot;@Value.%s %s&quot;, annotationName, msg));</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJdkOptional() {
<b class="nc">&nbsp;    return typeKind.isOptionalKind() &amp;&amp; typeKind.isJdkOnlyContainerKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isFugueOptional() {
<b class="nc">&nbsp;    return typeKind.isOptionFugue();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGuavaOptional() {
<b class="nc">&nbsp;    return typeKind.isOptionalGuava();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJavaslangOptional() {
<b class="nc">&nbsp;    return typeKind.isOptionJavaslang();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isJdkSpecializedOptional() {
<b class="nc">&nbsp;    return typeKind.isOptionalSpecializedJdk();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isOptionalType() {
<b class="nc">&nbsp;    return typeKind.isOptionalKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isCollectionType() {
<b class="nc">&nbsp;    return typeKind.isCollectionKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateEnumSet() {
<b class="nc">&nbsp;    return typeKind.isEnumSet();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGuavaImmutableDeclared() {
<b class="nc">&nbsp;    return typeKind.isContainerKind() &amp;&amp; rawTypeName.startsWith(GUAVA_IMMUTABLE_PREFIX);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private String defaultInterface;
&nbsp;
&nbsp;  public String defaultInterface() {
<b class="nc">&nbsp;    if (defaultInterface == null) {</b>
<b class="nc">&nbsp;      defaultInterface = inferDefaultInterface();</b>
&nbsp;    }
<b class="nc">&nbsp;    return defaultInterface;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String inferDefaultInterface() {
<b class="nc">&nbsp;    if (isInterfaceDefaultMethod()) {</b>
<b class="nc">&nbsp;      if (containingType.element.getKind() == ElementKind.INTERFACE) {</b>
<b class="nc">&nbsp;        return containingType.typeAbstract().relativeRaw();</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isInterfaceDefaultMethod() {
<b class="nc">&nbsp;    return element.getEnclosingElement().getKind() == ElementKind.INTERFACE</b>
<b class="nc">&nbsp;        &amp;&amp; !element.getModifiers().contains(Modifier.ABSTRACT);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateTransientDerived() {
<b class="nc">&nbsp;    return isGenerateDerived</b>
<b class="nc">&nbsp;        &amp;&amp; style().transientDerivedFields()</b>
<b class="nc">&nbsp;        &amp;&amp; !containingType.serial.isSimple();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateEnumMap() {
<b class="nc">&nbsp;    return typeKind.isEnumMap();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasVirtualImpl() {
<b class="nc">&nbsp;    return isEncoding() &amp;&amp; instantiation.hasVirtualImpl();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getUnwrappedElementType() {
<b class="nc">&nbsp;    return isContainerType() &amp;&amp; nullElements.ban()</b>
<b class="nc">&nbsp;        ? unwrapType(firstTypeParameter())</b>
<b class="nc">&nbsp;        : getElementType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getUnwrappedValueElementType() {
<b class="nc">&nbsp;    return isMapType()</b>
<b class="nc">&nbsp;        ? getUnwrappedSecondaryElementType()</b>
<b class="nc">&nbsp;        : getUnwrappedElementType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getWrappedElementType() {
<b class="nc">&nbsp;    if (returnType.getKind().isPrimitive()) {</b>
<b class="nc">&nbsp;      return wrapType(Ascii.toLowerCase(returnType.getKind().name()));</b>
&nbsp;    }
<b class="nc">&nbsp;    return wrapType(hasContainedElementType()</b>
<b class="nc">&nbsp;        ? firstTypeParameter()</b>
<b class="nc">&nbsp;        : returnTypeName);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasContainedElementType() {
<b class="nc">&nbsp;    return isArrayType() || isContainerType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getRawType() {
<b class="nc">&nbsp;    return rawTypeName;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getConsumedElementType() {
<b class="nc">&nbsp;    return (isUnwrappedElementPrimitiveType()</b>
<b class="nc">&nbsp;        || isStringType()</b>
<b class="nc">&nbsp;        || (hasContainedElementType() &amp;&amp; firstTypeParameter().equals(String.class.getName()))</b>
<b class="nc">&nbsp;        || hasEnumFirstTypeParameter())</b>
<b class="nc">&nbsp;            ? getWrappedElementType()</b>
<b class="nc">&nbsp;            : &quot;? extends &quot; + getWrappedElementType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasEnumFirstTypeParameter() {
<b class="nc">&nbsp;    return typeKind().isEnumKeyed()</b>
<b class="nc">&nbsp;        &amp;&amp; containedTypeElement.getKind() == ElementKind.ENUM;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String extractRawType(String className) {
<b class="nc">&nbsp;    String rawType = className;</b>
<b class="nc">&nbsp;    int indexOfGenerics = rawType.indexOf(&#39;&lt;&#39;);</b>
<b class="nc">&nbsp;    if (indexOfGenerics &gt; 0) {</b>
<b class="nc">&nbsp;      rawType = rawType.substring(0, indexOfGenerics);</b>
&nbsp;    }
<b class="nc">&nbsp;    int endOfTypeAnnotations = rawType.lastIndexOf(&#39; &#39;);</b>
<b class="nc">&nbsp;    if (endOfTypeAnnotations &gt; 0) {</b>
<b class="nc">&nbsp;      rawType = rawType.substring(endOfTypeAnnotations + 1);</b>
&nbsp;    }
<b class="nc">&nbsp;    return rawType;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUnwrappedElementPrimitiveType() {
<b class="nc">&nbsp;    return isPrimitiveType(getUnwrappedElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isUnwrappedSecondaryElementPrimitiveType() {
<b class="nc">&nbsp;    return isPrimitiveType(getUnwrappedSecondaryElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public String firstTypeParameter() {
<b class="nc">&nbsp;    return Iterables.getFirst(typeParameters(), &quot;&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  public String secondTypeParameter() {
<b class="nc">&nbsp;    return Iterables.get(typeParameters(), 1);</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getElementType() {
<b class="nc">&nbsp;    return hasContainedElementType() ? firstTypeParameter() : returnTypeName;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  private List&lt;String&gt; expectedSubtypes;
&nbsp;
&nbsp;  public List&lt;String&gt; getExpectedSubtypes() {
<b class="nc">&nbsp;    if (expectedSubtypes == null) {</b>
<b class="nc">&nbsp;      ensureTypeIntrospected();</b>
<b class="nc">&nbsp;      if (containedTypeElement != null || containedSecondaryTypeElement != null) {</b>
<b class="nc">&nbsp;        TypeElement supertypeElement = MoreObjects.firstNonNull(containedSecondaryTypeElement, containedTypeElement);</b>
<b class="nc">&nbsp;        Optional&lt;ExpectedSubtypesMirror&gt; annotationOnAttribute = ExpectedSubtypesMirror.find(element);</b>
<b class="nc">&nbsp;        if (annotationOnAttribute.isPresent()) {</b>
<b class="nc">&nbsp;          expectedSubtypes = ImmutableList.copyOf(annotationOnAttribute.get().valueName());</b>
<b class="nc">&nbsp;          if (expectedSubtypes.isEmpty()) {</b>
<b class="nc">&nbsp;            expectedSubtypes = tryFindSubtypes(supertypeElement);</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          Optional&lt;ExpectedSubtypesMirror&gt; annotationOnType = ExpectedSubtypesMirror.find(supertypeElement);</b>
<b class="nc">&nbsp;          if (annotationOnType.isPresent()) {</b>
<b class="nc">&nbsp;            expectedSubtypes = ImmutableList.copyOf(annotationOnType.get().valueName());</b>
<b class="nc">&nbsp;            if (expectedSubtypes.isEmpty()) {</b>
<b class="nc">&nbsp;              expectedSubtypes = tryFindSubtypes(supertypeElement);</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      if (expectedSubtypes == null) {</b>
<b class="nc">&nbsp;        expectedSubtypes = ImmutableList.of();</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return expectedSubtypes;</b>
&nbsp;  }
&nbsp;
&nbsp;  private ImmutableList&lt;String&gt; tryFindSubtypes(TypeElement supertypeElement) {
<b class="nc">&nbsp;    ValueType surroundingType =</b>
<b class="nc">&nbsp;        MoreObjects.firstNonNull(containingType.enclosingValue, containingType);</b>
<b class="nc">&nbsp;    Set&lt;ValueType&gt; subtypes =</b>
<b class="nc">&nbsp;        surroundingType.getCases().knownSubtypesOf(supertypeElement.getQualifiedName().toString());</b>
<b class="nc">&nbsp;    ImmutableList.Builder&lt;String&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;    for (ValueType valueType : subtypes) {</b>
<b class="nc">&nbsp;      builder.add(valueType.typeAbstract().toString());</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return builder.build();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJdkOnly() {
<b class="nc">&nbsp;    return containingType.isGenerateJdkOnly()</b>
<b class="nc">&nbsp;        &amp;&amp; !typeKind.isGuavaContainerKind()</b>
<b class="nc">&nbsp;        &amp;&amp; !isGuavaImmutableDeclared()</b>
<b class="nc">&nbsp;        &amp;&amp; !isCustomCollectionType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateJdk9() {
<b class="nc">&nbsp;    return containingType.isGenerateJdk9()</b>
<b class="nc">&nbsp;        &amp;&amp; (typeKind.isList() || typeKind.isMap() || typeKind.isSet())</b>
<b class="nc">&nbsp;        &amp;&amp; !isGuavaImmutableDeclared()</b>
<b class="nc">&nbsp;        &amp;&amp; nullElements.ban();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateOrdinalValueSet() {
<b class="nc">&nbsp;    if (!isSetType()) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    return generateOrdinalValueSet;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isArrayType() {
<b class="nc">&nbsp;    return typeKind.isArray();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isReferenceArrayType() {
<b class="nc">&nbsp;    return isArrayType() &amp;&amp; !isPrimitiveType(firstTypeParameter());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isPrimitiveArrayType() {
<b class="nc">&nbsp;    return isArrayType() &amp;&amp; isPrimitiveType(firstTypeParameter());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isOptionalAcceptNullable() {
<b class="nc">&nbsp;    return isOptionalType()</b>
<b class="nc">&nbsp;        &amp;&amp; !typeKind.isOptionalSpecializedJdk()</b>
<b class="nc">&nbsp;        &amp;&amp; containingType.isOptionalAcceptNullable();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  protected void introspectType() {
<b class="nc">&nbsp;    TypeMirror typeMirror = returnType;</b>
&nbsp;
&nbsp;    // Special case for primitive Optional, may become a pattern for specialized types
<b class="nc">&nbsp;    if (typeKind.isOptionalSpecializedJdk()) {</b>
<b class="nc">&nbsp;      typeParameters = ImmutableList.of(optionalSpecializedType());</b>
&nbsp;      // no delegation to introspect further
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isContainerType()) {</b>
<b class="nc">&nbsp;      if (typeMirror.getKind() == TypeKind.DECLARED</b>
<b class="nc">&nbsp;          || typeMirror.getKind() == TypeKind.ERROR) {</b>
&nbsp;
<b class="nc">&nbsp;        DeclaredType declaredType = (DeclaredType) typeMirror;</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments();</b>
&nbsp;
<b class="nc">&nbsp;        if (!typeArguments.isEmpty()) {</b>
<b class="nc">&nbsp;          final TypeMirror typeArgument = typeArguments.get(0);</b>
&nbsp;
<b class="nc">&nbsp;          if (isSetType() &amp;&amp; protoclass().environment().hasOrdinalModule()) {</b>
<b class="nc">&nbsp;            this.generateOrdinalValueSet = new TypeIntrospectionBase() {</b>
&nbsp;              @Override
&nbsp;              protected TypeMirror internalTypeMirror() {
<b class="nc">&nbsp;                return typeArgument;</b>
&nbsp;              }
&nbsp;
&nbsp;              @Override
&nbsp;              protected TypeHierarchyCollector collectTypeHierarchy(TypeMirror typeMirror) {
<b class="nc">&nbsp;                TypeHierarchyCollector collector = containingType.createTypeHierarchyCollector(reporter, element);</b>
<b class="nc">&nbsp;                collector.collectFrom(typeMirror);</b>
<b class="nc">&nbsp;                return collector;</b>
&nbsp;              }
<b class="nc">&nbsp;            }.isOrdinalValue();</b>
&nbsp;          }
<b class="nc">&nbsp;          if (isMapType()) {</b>
<b class="nc">&nbsp;            TypeMirror typeSecondArgument = typeArguments.get(1);</b>
<b class="nc">&nbsp;            if (typeSecondArgument.getKind() == TypeKind.DECLARED) {</b>
<b class="nc">&nbsp;              TypeElement typeElement = (TypeElement) ((DeclaredType) typeSecondArgument).asElement();</b>
<b class="nc">&nbsp;              this.containedSecondaryTypeElement = typeElement;</b>
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          typeMirror = typeArgument;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;    } else if (isArrayType()) {</b>
<b class="nc">&nbsp;      arrayComponent = ((ArrayType) typeMirror).getComponentType();</b>
<b class="nc">&nbsp;      typeMirror = arrayComponent;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (typeMirror.getKind() == TypeKind.DECLARED) {</b>
<b class="nc">&nbsp;      TypeElement typeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();</b>
<b class="nc">&nbsp;      this.containedTypeElement = typeElement;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    introspectTypeMirror(typeMirror);</b>
<b class="nc">&nbsp;    introspectSupertypes();</b>
&nbsp;  }
&nbsp;
&nbsp;  private String optionalSpecializedType() {
<b class="nc">&nbsp;    switch (typeKind) {</b>
&nbsp;    case OPTIONAL_INT_JDK:
<b class="nc">&nbsp;      return int.class.getName();</b>
&nbsp;    case OPTIONAL_LONG_JDK:
<b class="nc">&nbsp;      return long.class.getName();</b>
&nbsp;    case OPTIONAL_DOUBLE_JDK:
<b class="nc">&nbsp;      return double.class.getName();</b>
&nbsp;    default:
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public AttributeTypeKind typeKind() {
<b class="nc">&nbsp;    return typeKind;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isPrimitiveWrapperType() {
<b class="nc">&nbsp;    return isPrimitiveWrappedType(returnTypeName);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isRegularMarshalableType(String name) {
<b class="nc">&nbsp;    return String.class.getName().equals(name)</b>
<b class="nc">&nbsp;        || isPrimitiveType(name);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isRequiresMarshalingAdapter() {
<b class="nc">&nbsp;    return !isRegularMarshalableType(getElementType())</b>
<b class="nc">&nbsp;        || isPrimitiveArrayType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isRequiresMarshalingSecondaryAdapter() {
<b class="nc">&nbsp;    return isMapType() &amp;&amp; !isRegularMarshalableType(getSecondaryElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean wrapArrayToIterable() {
<b class="nc">&nbsp;    return containingType.isGenerateJdkOnly()</b>
<b class="nc">&nbsp;        || isUnwrappedElementPrimitiveType()</b>
<b class="nc">&nbsp;        || !(typeKind.isList() || typeKind.isSet() || typeKind.isMultiset());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Suitable for JavaDocs, intemediate name mangling and for Guava intergration.
&nbsp;   * @return the raw collection type
&nbsp;   */
&nbsp;  public String getRawCollectionType() {
<b class="nc">&nbsp;    return typeKind.rawSimpleName(rawTypeName);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isMultisetType() {
<b class="nc">&nbsp;    return typeKind.isMultisetKind();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isCustomCollectionType() {
<b class="nc">&nbsp;    return typeKind.isCustomCollection();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getRawMapType() {
<b class="nc">&nbsp;    return typeKind.rawSimpleName(rawTypeName);</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getSecondaryElementType() {
<b class="nc">&nbsp;    return secondTypeParameter();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getUnwrappedSecondaryElementType() {
<b class="nc">&nbsp;    return nullElements.ban()</b>
<b class="nc">&nbsp;        ? unwrapType(secondTypeParameter())</b>
<b class="nc">&nbsp;        : getSecondaryElementType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getWrappedFirstElementType() {
<b class="nc">&nbsp;    return wrapType(firstTypeParameter());</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getWrappedSecondaryElementType() {
<b class="nc">&nbsp;    return wrapType(secondTypeParameter());</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getUnwrapperOrRawSecondaryElementType() {
<b class="nc">&nbsp;    return extractRawType(getWrappedSecondaryElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getUnwrapperOrRawElementType() {
<b class="nc">&nbsp;    return extractRawType(getWrappedElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNumberType() {
<b class="nc">&nbsp;    TypeKind kind = returnType.getKind();</b>
<b class="nc">&nbsp;    return kind.isPrimitive()</b>
&nbsp;        &amp;&amp; kind != TypeKind.CHAR
&nbsp;        &amp;&amp; kind != TypeKind.BOOLEAN;
&nbsp;  }
&nbsp;
&nbsp;  public boolean isFloatType() {
<b class="nc">&nbsp;    return isFloat() || isDouble();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isFloat() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.FLOAT;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDouble() {
<b class="nc">&nbsp;    return returnType.getKind() == TypeKind.DOUBLE;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasTypeAnnotations() {
<b class="nc">&nbsp;    return returnTypeName.indexOf(&#39;@&#39;) &gt;= 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNonRawElementType() {
<b class="nc">&nbsp;    List&lt;String&gt; args = typeParameters();</b>
<b class="nc">&nbsp;    return !args.isEmpty() &amp;&amp; args.get(args.size() - 1).indexOf(&#39;&lt;&#39;) &gt; 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNonRawSecondaryElementType() {
<b class="nc">&nbsp;    return getSecondaryElementType().indexOf(&#39;&lt;&#39;) &gt; 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isContainerType() {
&nbsp;    // TBD replace with typeKind.isContainerKind() ?
<b class="nc">&nbsp;    return isCollectionType()</b>
<b class="nc">&nbsp;        || isOptionalType()</b>
<b class="nc">&nbsp;        || isMapType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getWrapperType() {
<b class="nc">&nbsp;    return isPrimitive()</b>
<b class="nc">&nbsp;        ? wrapType(rawTypeName)</b>
<b class="nc">&nbsp;        : returnTypeName;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isPrimitive() {
<b class="nc">&nbsp;    return returnType.getKind().isPrimitive();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAttributeBuilder() {
<b class="nc">&nbsp;    return isAttributeBuilder;</b>
&nbsp;  }
&nbsp;
&nbsp;  // undefined value is any less than CONSTRUCTOR_NOT_A_PARAMETER
<b class="nc">&nbsp;  private int parameterOrder = Integer.MIN_VALUE;</b>
&nbsp;
&nbsp;  private AttributeTypeKind typeKind;
&nbsp;  public boolean jacksonAnyGetter;
&nbsp;  public boolean jacksonValue;
&nbsp;  public boolean hasTypeVariables;
&nbsp;  private ImportsTypeStringResolver importsResolver;
&nbsp;
&nbsp;  public @Nullable Instantiation instantiation;
&nbsp;
&nbsp;  int getConstructorParameterOrder() {
<b class="nc">&nbsp;    boolean parameterOrderIsUndefined = parameterOrder &lt; CONSTRUCTOR_NOT_A_PARAMETER;</b>
&nbsp;
<b class="nc">&nbsp;    if (parameterOrderIsUndefined) {</b>
<b class="nc">&nbsp;      parameterOrder = computeConstructorParameterOrder();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return parameterOrder;</b>
&nbsp;  }
&nbsp;
&nbsp;  private int computeConstructorParameterOrder() {
<b class="nc">&nbsp;    boolean enabledAsAllParameters =</b>
<b class="nc">&nbsp;        style().allParameters();</b>
&nbsp;
<b class="nc">&nbsp;    boolean enabledAsAllMandatoryParameters =</b>
<b class="nc">&nbsp;        style().allMandatoryParameters() &amp;&amp; isMandatory();</b>
&nbsp;
<b class="nc">&nbsp;    Optional&lt;ParameterMirror&gt; parameterAnnotation = ParameterMirror.find(element);</b>
<b class="nc">&nbsp;    if (parameterAnnotation.isPresent()) {</b>
<b class="nc">&nbsp;      if (!parameterAnnotation.get().value()) {</b>
&nbsp;        // Cancelled out parameter identified, can return immediately
<b class="nc">&nbsp;        return CONSTRUCTOR_NOT_A_PARAMETER;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      int order = parameterAnnotation.get().order();</b>
<b class="nc">&nbsp;      boolean orderActuallySpecified = order &gt;= CONSTRUCTOR_PARAMETER_DEFAULT_ORDER;</b>
&nbsp;      // when order is unspecified it would be -1, but we should not treat is as
&nbsp;      // CONSTRUCTOR_NOT_A_PARAMETER, so we assign CONSTRUCTOR_PARAMETER_DEFAULT_ORDER
&nbsp;      // in this case
<b class="nc">&nbsp;      if (orderActuallySpecified) {</b>
<b class="nc">&nbsp;        return order;</b>
&nbsp;      }
&nbsp;      // We issue this warning only when order is not specified explicitly
&nbsp;      // and it is not a cancelling-out annotation thus the annoation
&nbsp;      // is truly superfluos when allParameters enabled
<b class="nc">&nbsp;      if (enabledAsAllParameters) {</b>
<b class="nc">&nbsp;        report().annotationNamed(ParameterMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.INCOMPAT,</b>
&nbsp;                &quot;Annotation @Value.Parameter is superfluous when Style(allParameters = true)&quot;);
&nbsp;      }
<b class="nc">&nbsp;      if (enabledAsAllMandatoryParameters) {</b>
<b class="nc">&nbsp;        report().annotationNamed(ParameterMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.INCOMPAT,</b>
&nbsp;                &quot;Annotation @Value.Parameter is superfluous when Style(allMandatoryParameters = true)&quot;
&nbsp;                    + &quot; and it is mandatory&quot;);
&nbsp;      }
<b class="nc">&nbsp;      return CONSTRUCTOR_PARAMETER_DEFAULT_ORDER;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (enabledAsAllParameters || enabledAsAllMandatoryParameters) {</b>
<b class="nc">&nbsp;      return CONSTRUCTOR_PARAMETER_DEFAULT_ORDER;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isAnnotationValueAttribute() &amp;&amp; thereAreNoOtherMandatoryAttributes()) {</b>
&nbsp;      // for annotation type, if annotation only contain single mandatory
&nbsp;      // attribute which is called &#39;value&#39; it will be automatically turned
&nbsp;      // into constructor parameter
<b class="nc">&nbsp;      return CONSTRUCTOR_PARAMETER_DEFAULT_ORDER;</b>
&nbsp;    }
<b class="nc">&nbsp;    return CONSTRUCTOR_NOT_A_PARAMETER;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isAnnotationValueAttribute() {
<b class="nc">&nbsp;    return containingType.isAnnotationType()</b>
<b class="nc">&nbsp;        &amp;&amp; names.get.equals(VALUE_ATTRIBUTE_NAME);</b>
&nbsp;  }
&nbsp;
&nbsp;  boolean thereAreNoOtherMandatoryAttributes() {
<b class="nc">&nbsp;    List&lt;ValueAttribute&gt; mandatories = containingType.getMandatoryAttributes();</b>
<b class="nc">&nbsp;    for (ValueAttribute m : mandatories) {</b>
<b class="nc">&nbsp;      if (m != this) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String toSignature() {
<b class="nc">&nbsp;    StringBuilder signature = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;    signature.append(getAccess());</b>
&nbsp;
<b class="nc">&nbsp;    return signature.append(returnTypeName)</b>
<b class="nc">&nbsp;        .append(&quot; &quot;)</b>
<b class="nc">&nbsp;        .append(names.get)</b>
<b class="nc">&nbsp;        .append(&quot;()&quot;)</b>
<b class="nc">&nbsp;        .toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getAccess() {
<b class="nc">&nbsp;    if (element.getModifiers().contains(Modifier.PUBLIC)</b>
<b class="nc">&nbsp;        || style().visibility() == ImplementationVisibility.PUBLIC) {</b>
<b class="nc">&nbsp;      return &quot;public &quot;;</b>
<b class="nc">&nbsp;    } else if (element.getModifiers().contains(Modifier.PROTECTED)) {</b>
<b class="nc">&nbsp;      return &quot;protected &quot;;</b>
&nbsp;    }
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getIntializerAccess() {
<b class="nc">&nbsp;    if (style().stagedBuilder()</b>
<b class="nc">&nbsp;        || style().alwaysPublicInitializers()</b>
<b class="nc">&nbsp;        || element.getModifiers().contains(Modifier.PUBLIC)) {</b>
<b class="nc">&nbsp;      return &quot;public &quot;;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (element.getModifiers().contains(Modifier.PROTECTED)) {</b>
<b class="nc">&nbsp;      return &quot;protected &quot;;</b>
&nbsp;    }
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isPrimitiveElement() {
<b class="nc">&nbsp;    return isPrimitiveType(getUnwrappedElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isSafeUncheckedCovariantCast() {
<b class="nc">&nbsp;    return isOptionalType()</b>
<b class="nc">&nbsp;        &amp;&amp; !getConsumedElementType().equals(getWrappedElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAuxiliary() {
<b class="nc">&nbsp;    return AuxiliaryMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isEncoding() {
<b class="nc">&nbsp;    return typeKind == AttributeTypeKind.ENCODING;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isMarkedAsMongoId() {
<b class="nc">&nbsp;    return IdMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Is it marked as {@code Criteria.Id} ?
&nbsp;   */
&nbsp;  private boolean isMarkedAsCriteriaId() {
<b class="nc">&nbsp;    return CriteriaIdMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  boolean isIdAttribute() {
<b class="nc">&nbsp;    return isMarkedAsMongoId()</b>
<b class="nc">&nbsp;        || isMarkedAsCriteriaId()</b>
<b class="nc">&nbsp;        || ID_ATTRIBUTE_NAME.equals(getSerializedName());</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isRedacted() {
<b class="nc">&nbsp;    return RedactedMirror.isPresent(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isRedactedCompletely() {
<b class="nc">&nbsp;    return isRedacted()</b>
<b class="nc">&nbsp;        &amp;&amp; getRedactedMask().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getRedactedMask() {
<b class="nc">&nbsp;    return isRedacted()</b>
<b class="nc">&nbsp;        ? protoclass().styles().style().redactedMask()</b>
<b class="nc">&nbsp;        : &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Initialized Validates things that were not validated otherwise
&nbsp;   * @param instantiationCreator can instantiate encodings
&nbsp;   */
&nbsp;  void initAndValidate(@Nullable InstantiationCreator instantiationCreator) {
<b class="nc">&nbsp;    initTypeName();</b>
&nbsp;
<b class="nc">&nbsp;    if (instantiationCreator != null</b>
&nbsp;        &amp;&amp; !isGenerateLazy) {
<b class="nc">&nbsp;      this.instantiation = instantiationCreator.tryInstantiateFor(</b>
&nbsp;          reporter,
&nbsp;          returnTypeName,
&nbsp;          names,
&nbsp;          containingType,
&nbsp;          isGenerateDefault || isGenerateDerived);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    initTypeKind();</b>
<b class="nc">&nbsp;    initOrderKind();</b>
<b class="nc">&nbsp;    initBuilderParamsIfApplicable();</b>
<b class="nc">&nbsp;    initMiscellaneous();</b>
&nbsp;
<b class="nc">&nbsp;    initSpecialAnnotations();</b>
<b class="nc">&nbsp;    validateThrowsClause();</b>
<b class="nc">&nbsp;    validateTypeAndAnnotations();</b>
&nbsp;
<b class="nc">&nbsp;    initAttributeValueType();</b>
<b class="nc">&nbsp;    if (supportBuiltinContainerTypes()) {</b>
<b class="nc">&nbsp;      initImmutableCopyOf();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    initAttributeBuilder();</b>
<b class="nc">&nbsp;    maybeInitJavaBean();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private Set&lt;String&gt; thrownCheckedExceptions = ImmutableSet.of();</b>
&nbsp;
&nbsp;  private void validateThrowsClause() {
<b class="nc">&nbsp;    if (element.getKind() != ElementKind.METHOD) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    ImmutableSet&lt;String&gt; checkedExceptions = collectThrownCheckedExceptions();</b>
<b class="nc">&nbsp;    if (!checkedExceptions.isEmpty()) {</b>
<b class="nc">&nbsp;      if (isGenerateLazy) {</b>
<b class="nc">&nbsp;        this.thrownCheckedExceptions = checkedExceptions;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        report().warning(About.INCOMPAT,</b>
&nbsp;            &quot;Checked exceptions in &#39;throws&#39; clause are not supported for regular abstract,&quot;
&nbsp;                + &quot; @Value.Derived, and @Value.Default attributes due to implementation difficulties&quot;
&nbsp;                + &quot; and unclear semantics. This message reported as a warning to preserve compatibility,&quot;
&nbsp;                + &quot; but there are high chances you&#39;ll see compile error in generated classed caused by this.&quot;
&nbsp;                + &quot; NOTE: for @Value.Lazy attributes, checked exceptions are supported by simple propagation:&quot;
&nbsp;                + &quot; neither runtime nor checked exceptions will not be memoised for lazy attributes,&quot;
&nbsp;                + &quot; leading to lazy computation to be re-evaluated again and again until regular value&quot;
&nbsp;                + &quot; returned and memoised.&quot;);
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private ImmutableSet&lt;String&gt; collectThrownCheckedExceptions() {
<b class="nc">&nbsp;    Set&lt;String&gt; exceptions = new HashSet&lt;&gt;(2);</b>
<b class="nc">&nbsp;    Environment env = protoclass().environment();</b>
<b class="nc">&nbsp;    for (TypeMirror thrown : ((ExecutableElement) element).getThrownTypes()) {</b>
<b class="nc">&nbsp;      if (env.isCheckedException(thrown)) {</b>
<b class="nc">&nbsp;        exceptions.add(thrown.toString());</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return ImmutableSet.copyOf(exceptions);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;String&gt; getThrownCheckedExceptions() {
<b class="nc">&nbsp;    return thrownCheckedExceptions;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void initAttributeBuilder() {
<b class="nc">&nbsp;    AttributeBuilderReflection attributeBuilderReflection =</b>
<b class="nc">&nbsp;        AttributeBuilderReflection.forValueType(this);</b>
<b class="nc">&nbsp;    isAttributeBuilder = attributeBuilderReflection.isAttributeBuilder();</b>
&nbsp;
<b class="nc">&nbsp;    if (isAttributeBuilder) {</b>
<b class="nc">&nbsp;      attributeBuilderDescriptor = attributeBuilderReflection.getAttributeBuilderDescriptor();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void initImmutableCopyOf() {
<b class="nc">&nbsp;    ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    this.isGenerateImmutableCopyOf = containingType.kind().isValue()</b>
<b class="nc">&nbsp;        &amp;&amp; !style().immutableCopyOfRoutinesNames().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; (typeKind.isRegular() || typeKind.isOptionalKind())</b>
<b class="nc">&nbsp;        &amp;&amp; !isPrimitiveOrWrapped(rawTypeName)</b>
<b class="nc">&nbsp;        &amp;&amp; !isUnwrappedElementPrimitiveType()</b>
<b class="nc">&nbsp;        &amp;&amp; !isStringType()</b>
<b class="nc">&nbsp;        &amp;&amp; !isEnumType()</b>
&nbsp;        &amp;&amp; attributeValueType == null;
&nbsp;  }
&nbsp;
&nbsp;  private void initOrderKind() {
<b class="nc">&nbsp;    if (typeKind.isSortedKind()) {</b>
<b class="nc">&nbsp;      checkOrderAnnotations();</b>
<b class="nc">&nbsp;      if (orderKind == OrderKind.NONE) {</b>
<b class="nc">&nbsp;        this.typeKind = AttributeTypeKind.REGULAR;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void initTypeName() {
<b class="nc">&nbsp;    this.importsResolver = new ImportsTypeStringResolver(protoclass().declaringType().orNull(), getDeclaringType());</b>
<b class="nc">&nbsp;    this.importsResolver.hierarchyTraversalForUnresolvedTypes(</b>
<b class="nc">&nbsp;        protoclass().environment().round(),</b>
<b class="nc">&nbsp;        this.containingType.extendedClasses(),</b>
<b class="nc">&nbsp;        this.containingType.implementedInterfaces(),</b>
&nbsp;        this.containingType.unresolvedYetArguments);
&nbsp;
<b class="nc">&nbsp;    TypeStringProvider provider = new TypeStringProvider(</b>
&nbsp;        reporter,
&nbsp;        element,
&nbsp;        returnType,
&nbsp;        importsResolver,
<b class="nc">&nbsp;        protoclass().constitution().generics().vars(),</b>
&nbsp;        null);
&nbsp;
<b class="nc">&nbsp;    provider.sourceExtractionCache = containingType;</b>
<b class="nc">&nbsp;    provider.forAttribute = true;</b>
<b class="nc">&nbsp;    provider.processNestedTypeUseAnnotations = true;</b>
<b class="nc">&nbsp;    provider.process();</b>
&nbsp;
<b class="nc">&nbsp;    this.hasSomeUnresolvedTypes = provider.hasSomeUnresovedTypes();</b>
<b class="nc">&nbsp;    this.rawTypeName = provider.rawTypeName();</b>
<b class="nc">&nbsp;    this.returnTypeName = provider.returnTypeName();</b>
<b class="nc">&nbsp;    this.typeParameters = provider.typeParameters();</b>
<b class="nc">&nbsp;    this.hasTypeVariables = provider.hasTypeVariables;</b>
<b class="nc">&nbsp;    this.nullElements = provider.nullElements;</b>
<b class="nc">&nbsp;    if (provider.nullableTypeAnnotation) {</b>
<b class="nc">&nbsp;      this.nullability = NullabilityAnnotationInfo.forTypeUse();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public NullElements nullElements = NullElements.BAN;</b>
&nbsp;  public boolean isSuppressedOptional;
&nbsp;
<b class="nc">&nbsp;  public enum NullElements {</b>
<b class="nc">&nbsp;    BAN,</b>
<b class="nc">&nbsp;    ALLOW,</b>
<b class="nc">&nbsp;    SKIP,</b>
<b class="nc">&nbsp;    NOP;</b>
&nbsp;
&nbsp;    public boolean ban() {
<b class="nc">&nbsp;      return this == BAN;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean allow() {
<b class="nc">&nbsp;      return this == ALLOW || this == NOP;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean skip() {
<b class="nc">&nbsp;      return this == SKIP;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void initAttributeValueType() {
&nbsp;
<b class="nc">&nbsp;    if ((style().deepImmutablesDetection()</b>
<b class="nc">&nbsp;        || style().attributeBuilderDetection()</b>
<b class="nc">&nbsp;        || containingType.isGenerateCriteria())</b>
&nbsp;        &amp;&amp; containedTypeElement != null) {
&nbsp;      // prevent recursion in case we have the same type
<b class="nc">&nbsp;      if (CachingElements.equals(containedTypeElement, containingType.element)) {</b>
&nbsp;        // We don&#39;t propagate type arguments so we don&#39;t support it, sorry
<b class="nc">&nbsp;        if (containingType.generics().isEmpty()) {</b>
<b class="nc">&nbsp;          this.attributeValueType = containingType;</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        Environment environment = protoclass().environment();</b>
<b class="nc">&nbsp;        for (Protoclass p : environment.protoclassesFrom(Collections.singleton(containedTypeElement))) {</b>
<b class="nc">&nbsp;          if ((p.kind().isDefinedValue() || p.kind().isModifiable() || p.kind().isJavaBean())</b>
<b class="nc">&nbsp;              &amp;&amp; canAccessImplementation(p)</b>
<b class="nc">&nbsp;              &amp;&amp; p.constitution().generics().isEmpty()) {</b>
<b class="nc">&nbsp;            this.attributeValueType = environment.composeValue(p);</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean canAccessImplementation(Protoclass p) {
<b class="nc">&nbsp;    return p.constitution().implementationVisibility().isPublic()</b>
<b class="nc">&nbsp;        || (!p.constitution().implementationVisibility().isPrivate()</b>
<b class="nc">&nbsp;            &amp;&amp; p.constitution().implementationPackage().equals(p.constitution().definingPackage()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public String implementationModifiableType() {
<b class="nc">&nbsp;    if (isAttributeValueKindModifyFrom() &amp;&amp; !isBeanFriendlyModifiable()) {</b>
<b class="nc">&nbsp;      return attributeValueType.constitution.typeModifiable().toString();</b>
&nbsp;    }
<b class="nc">&nbsp;    return getType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String implementationType() {
<b class="nc">&nbsp;    if (isAttributeValueKindCopy()) {</b>
<b class="nc">&nbsp;      return attributeValueType.typeValue().toString();</b>
&nbsp;    }
<b class="nc">&nbsp;    return getType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasAttributeValue() {
<b class="nc">&nbsp;    return attributeValueType != null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean attributeValueKindIsCollectionOfModifiable() {
<b class="nc">&nbsp;    return attributeValueType != null</b>
<b class="nc">&nbsp;        &amp;&amp; typeKind.isCollectionKind()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.kind().isModifiable()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.isGenerateFilledFrom();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAttributeValueKindCopy() {
<b class="nc">&nbsp;    return attributeValueType != null</b>
<b class="nc">&nbsp;        &amp;&amp; typeKind.isRegular()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.kind().isValue()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.isUseCopyConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isAttributeValueKindModifyFrom() {
<b class="nc">&nbsp;    return attributeValueType != null</b>
<b class="nc">&nbsp;        &amp;&amp; typeKind.isRegular()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.kind().isModifiable()</b>
<b class="nc">&nbsp;        &amp;&amp; attributeValueType.isGenerateFilledFrom();</b>
&nbsp;  }
&nbsp;
&nbsp;  public Set&lt;ValueAttribute&gt; getConstructorParameters() {
<b class="nc">&nbsp;    if (attributeValueType != null &amp;&amp; attributeValueType.isUseConstructor()) {</b>
<b class="nc">&nbsp;      return attributeValueType.getConstructorArguments();</b>
&nbsp;    }
<b class="nc">&nbsp;    return Collections.emptySet();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void initTypeKind() {
<b class="nc">&nbsp;    if (instantiation != null) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.ENCODING;</b>
<b class="nc">&nbsp;    } else if (isGenerateDerived) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;      ensureTypeIntrospected();</b>
<b class="nc">&nbsp;    } else if (returnType.getKind() == TypeKind.ARRAY) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.ARRAY;</b>
<b class="nc">&nbsp;      ensureTypeIntrospected();</b>
&nbsp;    } else {
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.forRawType(rawTypeName);</b>
<b class="nc">&nbsp;      ensureTypeIntrospected();</b>
<b class="nc">&nbsp;      typeKind = typeKind.havingEnumFirstTypeParameter(hasEnumContainedElementType());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean supportBuiltinContainerTypes() {
<b class="nc">&nbsp;    return protoclass().styles().style().builtinContainerAttributes();</b>
&nbsp;  }
&nbsp;
&nbsp;  public static class WholeTypeVariable {
&nbsp;    public final boolean is;
&nbsp;    public final boolean not;
&nbsp;    public final int index;
&nbsp;
<b class="nc">&nbsp;    WholeTypeVariable(int index) {</b>
<b class="nc">&nbsp;      this.index = index;</b>
<b class="nc">&nbsp;      this.is = index &gt;= 0;</b>
<b class="nc">&nbsp;      this.not = !is;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public WholeTypeVariable getWholeTypeVariable() {
<b class="nc">&nbsp;    return getWholeTypeVariable(false);</b>
&nbsp;  }
&nbsp;
&nbsp;  public WholeTypeVariable getSecondaryWholeTypeVariable() {
<b class="nc">&nbsp;    return getWholeTypeVariable(true);</b>
&nbsp;  }
&nbsp;
&nbsp;  private WholeTypeVariable getWholeTypeVariable(boolean secondary) {
<b class="nc">&nbsp;    if (!hasTypeVariables) {</b>
<b class="nc">&nbsp;      return NON_WHOLE_TYPE_VARIABLE;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (secondary &amp;&amp; !isMapType()) {</b>
<b class="nc">&nbsp;      return NON_WHOLE_TYPE_VARIABLE;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    String typeString = secondary</b>
<b class="nc">&nbsp;        ? getSecondaryElementType()</b>
<b class="nc">&nbsp;        : getElementType();</b>
&nbsp;
<b class="nc">&nbsp;    if (!containingType.generics().isEmpty()) {</b>
<b class="nc">&nbsp;      for (Parameter p : containingType.generics().parameters) {</b>
<b class="nc">&nbsp;        if (p.var.equals(typeString)) {</b>
<b class="nc">&nbsp;          return new WholeTypeVariable(p.index);</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return NON_WHOLE_TYPE_VARIABLE;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasEnumContainedElementType() {
<b class="nc">&nbsp;    return containedTypeElement != null</b>
<b class="nc">&nbsp;        &amp;&amp; containedTypeElement.getKind() == ElementKind.ENUM;</b>
&nbsp;  }
&nbsp;
&nbsp;  DeclaringType getDeclaringType() {
<b class="nc">&nbsp;    return containingType.inferDeclaringType(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void validateTypeAndAnnotations() {
<b class="nc">&nbsp;    boolean wasOptional = isOptionalType();</b>
&nbsp;
<b class="nc">&nbsp;    if (!typeKind.isRegular() &amp;&amp; !supportBuiltinContainerTypes()) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.REGULAR;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (typeKind.isContainerKind() &amp;&amp; typeParameters.isEmpty()) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;      if (!SuppressedWarnings.forElement(element, false, false).rawtypes) {</b>
<b class="nc">&nbsp;        report().warning(About.UNTYPE,</b>
&nbsp;            &quot;Raw container types treated as regular attributes, nothing special generated.&quot;
&nbsp;                + &quot; It is better to avoid raw types at all times&quot;);
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (typeKind.isContainerKind()) {</b>
<b class="nc">&nbsp;      boolean hasWildcardInType = returnTypeName.indexOf(&#39;?&#39;) &gt;= 0;</b>
<b class="nc">&nbsp;      if (hasWildcardInType) {</b>
<b class="nc">&nbsp;        if (hasNakedWildcardArguments()) {</b>
<b class="nc">&nbsp;          typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;          report()</b>
<b class="nc">&nbsp;              .annotationNamed(DefaultMirror.simpleName())</b>
<b class="nc">&nbsp;              .warning(About.UNTYPE,</b>
&nbsp;                  &quot;Wildcards are not supported as elements or key/values. Make it lose its special treatment&quot;);
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isNullable()) {</b>
<b class="nc">&nbsp;      if (isOptionalType()) {</b>
<b class="nc">&nbsp;        typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(DefaultMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.UNTYPE, &quot;@Nullable on a Optional attribute make it lose its special treatment&quot;);</b>
<b class="nc">&nbsp;      } else if (isPrimitive()) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(nullability.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s could not be used with primitive type attibutes&quot;, nullability.simpleName());</b>
<b class="nc">&nbsp;      } else if (containingType.isAnnotationType()) {</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(nullability.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s could not be used with annotation attribute, use default value&quot;, nullability.simpleName());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isGenerateDefault &amp;&amp; isOptionalType()) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;      report()</b>
<b class="nc">&nbsp;          .annotationNamed(DefaultMirror.simpleName())</b>
<b class="nc">&nbsp;          .warning(About.UNTYPE, &quot;@Value.Default on a optional attribute make it lose its special treatment&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isContainerType() &amp;&amp; containingType.isUseStrictBuilder()) {</b>
<b class="nc">&nbsp;      if (isGenerateDefault) {</b>
<b class="nc">&nbsp;        typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(DefaultMirror.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.UNTYPE,</b>
&nbsp;                &quot;@Value.Default on a container attribute make it lose its special treatment (when strictBuilder = true)&quot;);
<b class="nc">&nbsp;      } else if (isNullable()) {</b>
<b class="nc">&nbsp;        typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;        report()</b>
<b class="nc">&nbsp;            .annotationNamed(nullability.simpleName())</b>
<b class="nc">&nbsp;            .warning(About.UNTYPE,</b>
&nbsp;                &quot;@%s on a container attribute make it lose its special treatment (when strictBuilder = true)&quot;,
<b class="nc">&nbsp;                nullability.simpleName());</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (containingType.isAnnotationType() &amp;&amp; isAuxiliary()) {</b>
<b class="nc">&nbsp;      report()</b>
<b class="nc">&nbsp;          .annotationNamed(AuxiliaryMirror.simpleName())</b>
<b class="nc">&nbsp;          .error(&quot;@Value.Auxiliary cannot be used on annotation attribute to not violate annotation spec&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (!isGenerateJdkOnly()</b>
&nbsp;        &amp;&amp; (nullElements == NullElements.ALLOW || nullElements == NullElements.SKIP)) {
<b class="nc">&nbsp;      report().warning(About.INCOMPAT,</b>
&nbsp;          &quot;Guava collection implementation does not allow null elements,&quot;
&nbsp;              + &quot; @AllowNulls/@SkipNulls annotation will be ignored.&quot;
&nbsp;              + &quot; Switch Style.jdkOnly=true to use collections that permit nulls as values&quot;);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isOptionalType()</b>
&nbsp;        &amp;&amp; containedTypeElement != null // for specialized optional types it can be null
<b class="nc">&nbsp;        &amp;&amp; AttributeTypeKind.forRawType(containedTypeElement.getQualifiedName().toString()).isOptionalKind()) {</b>
<b class="nc">&nbsp;      typeKind = AttributeTypeKind.REGULAR;</b>
<b class="nc">&nbsp;      report().warning(About.UNTYPE,</b>
&nbsp;          &quot;Optional&lt;Optional&lt;*&gt;&gt; is turned into regular attribute to avoid ambiguity problems&quot;);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (wasOptional &amp;&amp; !isOptionalType()) {</b>
<b class="nc">&nbsp;      isSuppressedOptional = true;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean hasNakedWildcardArguments() {
<b class="nc">&nbsp;    for (String t : typeParameters()) {</b>
<b class="nc">&nbsp;      if (t.startsWith(&quot;?&quot;)) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private @Nullable NullabilityAnnotationInfo isAccessorNullableAccessor(Element element) {
<b class="nc">&nbsp;    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;      TypeElement annotationElement = (TypeElement) annotation.getAnnotationType().asElement();</b>
<b class="nc">&nbsp;      Name simpleName = annotationElement.getSimpleName();</b>
<b class="nc">&nbsp;      Name qualifiedName = annotationElement.getQualifiedName();</b>
<b class="nc">&nbsp;      if (isNullableAnnotation(simpleName, qualifiedName)) {</b>
<b class="nc">&nbsp;        return ImmutableNullabilityAnnotationInfo.of(annotationElement);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void initSpecialAnnotations() {
<b class="nc">&nbsp;    Environment environment = containingType.constitution.protoclass().environment();</b>
<b class="nc">&nbsp;    ImmutableList.Builder&lt;AnnotationInjection&gt; annotationInjections = null;</b>
&nbsp;
<b class="nc">&nbsp;    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {</b>
<b class="nc">&nbsp;      MetaAnnotated metaAnnotated = MetaAnnotated.from(annotation, environment);</b>
&nbsp;
<b class="nc">&nbsp;      for (InjectionInfo info : metaAnnotated.injectAnnotation()) {</b>
<b class="nc">&nbsp;        if (annotationInjections == null) {</b>
<b class="nc">&nbsp;          annotationInjections = ImmutableList.builder();</b>
&nbsp;        }
<b class="nc">&nbsp;        annotationInjections.add(info.injectionFor(annotation, environment));</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      TypeElement annotationElement = (TypeElement) annotation.getAnnotationType().asElement();</b>
<b class="nc">&nbsp;      Name simpleName = annotationElement.getSimpleName();</b>
<b class="nc">&nbsp;      Name qualifiedName = annotationElement.getQualifiedName();</b>
<b class="nc">&nbsp;      if (isNullableAnnotation(simpleName, qualifiedName)) {</b>
<b class="nc">&nbsp;        nullability = ImmutableNullabilityAnnotationInfo.of(annotationElement);</b>
<b class="nc">&nbsp;      } else if (simpleName.contentEquals(TypeStringProvider.EPHEMERAL_ANNOTATION_ALLOW_NULLS)) {</b>
<b class="nc">&nbsp;        nullElements = NullElements.ALLOW;</b>
<b class="nc">&nbsp;      } else if (simpleName.contentEquals(TypeStringProvider.EPHEMERAL_ANNOTATION_SKIP_NULLS)) {</b>
<b class="nc">&nbsp;        nullElements = NullElements.SKIP;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    if (containingType.isGenerateJacksonProperties()</b>
<b class="nc">&nbsp;        &amp;&amp; typeKind.isMap()</b>
<b class="nc">&nbsp;        &amp;&amp; Proto.isAnnotatedWith(element, Annotations.JACKSON_ANY_GETTER)) {</b>
<b class="nc">&nbsp;      jacksonAnyGetter = true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (containingType.isGenerateJacksonMapped()</b>
&nbsp;        &amp;&amp; (isGenerateAbstract || isGenerateDefault)
<b class="nc">&nbsp;        &amp;&amp; Proto.isAnnotatedWith(element, Annotations.JACKSON_VALUE)) {</b>
<b class="nc">&nbsp;      jacksonValue = true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if ((isCollectionType() || isMapType())</b>
&nbsp;        &amp;&amp; nullElements == NullElements.BAN
<b class="nc">&nbsp;        &amp;&amp; (validation() == ValidationMethod.NONE</b>
<b class="nc">&nbsp;        || validation() == ValidationMethod.MANDATORY_ONLY)) {</b>
<b class="nc">&nbsp;      nullElements = NullElements.NOP;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (annotationInjections != null) {</b>
<b class="nc">&nbsp;      this.annotationInjections = annotationInjections.build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean isNullableAnnotation(Name simpleName, Name qualifiedName) {
<b class="nc">&nbsp;    return qualifiedName.contentEquals(Annotations.JAVAX_CHECK_FOR_NULL)</b>
<b class="nc">&nbsp;        || qualifiedName.contentEquals(Annotations.JAVAX_NULLABLE)</b>
<b class="nc">&nbsp;        || qualifiedName.contentEquals(Annotations.JAKARTA_CHECK_FOR_NULL)</b>
<b class="nc">&nbsp;        || qualifiedName.contentEquals(Annotations.JAKARTA_NULLABLE)</b>
<b class="nc">&nbsp;        || simpleName.contentEquals(containingType.names().nullableAnnotation);</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNullableCollector() {
<b class="nc">&nbsp;    return typeKind.isCollectionOrMapping()</b>
<b class="nc">&nbsp;        &amp;&amp; (isNullable() || containingType.isDeferCollectionAllocation());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isDeferCollectionAllocation() {
<b class="nc">&nbsp;    return typeKind.isCollectionOrMapping()</b>
<b class="nc">&nbsp;        &amp;&amp; containingType.isDeferCollectionAllocation();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void initMiscellaneous() {
<b class="nc">&nbsp;    this.deprecated = protoclass()</b>
<b class="nc">&nbsp;        .processing()</b>
<b class="nc">&nbsp;        .getElementUtils()</b>
<b class="nc">&nbsp;        .isDeprecated(CachingElements.getDelegate(element));</b>
&nbsp;
<b class="nc">&nbsp;    this.docComment = containingType.extractDocComment(element);</b>
<b class="nc">&nbsp;    if (!isPrimitive()</b>
<b class="nc">&nbsp;        &amp;&amp; isMandatory()</b>
<b class="nc">&nbsp;        &amp;&amp; validation() != ValidationMethod.SIMPLE) {</b>
<b class="nc">&nbsp;      boolean synthetic = validation() == ValidationMethod.MANDATORY_ONLY;</b>
<b class="nc">&nbsp;      this.nullability = NullabilityAnnotationInfo.forTypeUse(synthetic);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public boolean isValidationCustomized() {
<b class="nc">&nbsp;    return validation() != ValidationMethod.SIMPLE;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void initBuilderParamsIfApplicable() {
<b class="nc">&nbsp;    if (!protoclass().environment().hasBuilderModule()) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    isBuilderParameter = FParameterMirror.isPresent(element);</b>
<b class="nc">&nbsp;    Optional&lt;SwitchMirror&gt; switcher = SwitchMirror.find(element);</b>
<b class="nc">&nbsp;    if (switcher.isPresent()) {</b>
<b class="nc">&nbsp;      if (isBuilderParameter) {</b>
<b class="nc">&nbsp;        report().annotationNamed(FParameterMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s and @%s annotations cannot be used on a same factory parameter&quot;,</b>
<b class="nc">&nbsp;                FParameterMirror.simpleName(),</b>
<b class="nc">&nbsp;                SwitchMirror.simpleName());</b>
<b class="nc">&nbsp;        isBuilderParameter = false;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (!isEnumType()) {</b>
<b class="nc">&nbsp;        report().annotationNamed(SwitchMirror.simpleName())</b>
<b class="nc">&nbsp;            .error(&quot;@%s annotation applicable only to enum parameters&quot;, SwitchMirror.simpleName());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        builderSwitcherModel = new SwitcherModel(switcher.get(), names, containedTypeElement);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Init (or override) internal attributes specific to JavaBeans
&nbsp;   */
&nbsp;  private void maybeInitJavaBean() {
<b class="nc">&nbsp;    if (!containingType.kind().isJavaBean()) {</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
&nbsp;    // JavaBeans have nullable attributes by default (except for primitives / optionals /
&nbsp;    // collections / criteria)
&nbsp;    // allow only scalar types to be nullable (by default) for JavaBeans
&nbsp;    // override nullability if not set
<b class="nc">&nbsp;    if (this.nullability == null</b>
<b class="nc">&nbsp;        &amp;&amp; !isPrimitive()</b>
<b class="nc">&nbsp;        &amp;&amp; !isOptionalType()</b>
<b class="nc">&nbsp;        &amp;&amp; !isCollectionType()) {</b>
<b class="nc">&nbsp;      this.nullability = NullabilityAnnotationInfo.forTypeUse();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Nullable
&nbsp;  public SwitcherModel builderSwitcherModel;
&nbsp;  public boolean isBuilderParameter;
&nbsp;  boolean hasSomeUnresolvedTypes;
&nbsp;
&nbsp;  public boolean hasBuilderSwitcherDefault() {
<b class="nc">&nbsp;    return isBuilderSwitcher() &amp;&amp; builderSwitcherModel.hasDefault();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isBuilderSwitcher() {
<b class="nc">&nbsp;    return builderSwitcherModel != null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean canUseNullAsUndefined() {
<b class="nc">&nbsp;    return !isPrimitive()</b>
<b class="nc">&nbsp;        &amp;&amp; !isNullable()</b>
<b class="nc">&nbsp;        &amp;&amp; !typeKind.isCollectionOrMapping()</b>
<b class="nc">&nbsp;        &amp;&amp; !containingType.isUseStrictBuilder();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean requiresTrackIsSet() {
<b class="nc">&nbsp;    if (isGenerateDefault &amp;&amp; isPrimitive()) {</b>
&nbsp;      // because primitive cannot be null
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (isGenerateDefault &amp;&amp; (isNullable() || isValidationCustomized())) {</b>
&nbsp;      // nullable arrays should be able to distinguish null from default
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (typeKind.isCollectionOrMapping() &amp;&amp; isGenerateDefault) {</b>
&nbsp;      // becase builder/collector is used and have to distinguish non-default value is set
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (containingType.isUseStrictBuilder()</b>
<b class="nc">&nbsp;        &amp;&amp; !isMandatory()</b>
<b class="nc">&nbsp;        &amp;&amp; !typeKind.isCollectionOrMapping()) {</b>
&nbsp;      // non-mandatory attributes without add/put methods
&nbsp;      // should be checked if it was already initialized
&nbsp;      // for a strict builder
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isGenerateImmutableCopyOf;
&nbsp;
&nbsp;  public Collection&lt;TypeElement&gt; getEnumElements() {
<b class="nc">&nbsp;    if (isEnumType()) {</b>
<b class="nc">&nbsp;      return Collections.singletonList(containedTypeElement);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!isContainerType()) {</b>
<b class="nc">&nbsp;      List&lt;TypeElement&gt; elements = Lists.newArrayListWithCapacity(2);</b>
<b class="nc">&nbsp;      if (hasEnumContainedElementType()) {</b>
<b class="nc">&nbsp;        elements.add(containedTypeElement);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (isMapType() &amp;&amp; containedSecondaryTypeElement.getKind() == ElementKind.ENUM) {</b>
<b class="nc">&nbsp;        elements.add(containedSecondaryTypeElement);</b>
&nbsp;      }
<b class="nc">&nbsp;      return elements;</b>
&nbsp;    }
<b class="nc">&nbsp;    return Collections.emptyList();</b>
&nbsp;  }
&nbsp;
&nbsp;  boolean hasConstructorParameterCustomOrder() {
<b class="nc">&nbsp;    return getConstructorParameterOrder() &gt; ValueAttribute.CONSTRUCTOR_PARAMETER_DEFAULT_ORDER;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Protoclass protoclass() {
<b class="nc">&nbsp;    return containingType.constitution.protoclass();</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getGenericArgs() {
<b class="nc">&nbsp;    String type = getType();</b>
<b class="nc">&nbsp;    int indexOfGenerics = type.indexOf(&#39;&lt;&#39;);</b>
<b class="nc">&nbsp;    if (indexOfGenerics &gt; 0) {</b>
<b class="nc">&nbsp;      return type.substring(indexOfGenerics);</b>
&nbsp;    }
<b class="nc">&nbsp;    return &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public AttributeBuilderDescriptor getAttributeBuilderDescriptor() {
<b class="nc">&nbsp;    return attributeBuilderDescriptor;</b>
&nbsp;  }
&nbsp;
&nbsp;  Reporter report() {
<b class="nc">&nbsp;    return reporter.withElement(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public CharSequence getTypeTokenOfElement() {
<b class="nc">&nbsp;    return containingType.getGsonTypeTokens().sourceFor(getElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public CharSequence getTypeTokenOfSecondaryElement() {
<b class="nc">&nbsp;    return containingType.getGsonTypeTokens().sourceFor(getSecondaryElementType());</b>
&nbsp;  }
&nbsp;
&nbsp;  public Element originalElement() {
<b class="nc">&nbsp;    return CachingElements.getDelegate(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Element originalTypeElement() {
<b class="nc">&nbsp;    return containingType.originalElement();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public StyleInfo style() {
<b class="nc">&nbsp;    return containingType.constitution.style();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean supportsInternalImplConstructor() {
<b class="nc">&nbsp;    return !isEncoding() || instantiation.supportsInternalImplConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; fieldInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.FIELD);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; accessorInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.ACCESSOR);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; syntheticFieldsInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.SYNTHETIC_FIELDS);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; initializerInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.INITIALIZER);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; constructorParameterInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.CONSTRUCTOR_PARAMETER);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Collection&lt;String&gt; elementInitializerInjectedAnnotations() {
<b class="nc">&nbsp;    return collectInjections(Where.ELEMENT_INITIALIZER);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Collection&lt;String&gt; collectInjections(Where target) {
<b class="nc">&nbsp;    return AnnotationInjections.collectInjections(element,</b>
&nbsp;        target,
<b class="nc">&nbsp;        Collections.singleton(name()),</b>
&nbsp;        annotationInjections,
<b class="nc">&nbsp;        containingType.getDeclaringTypeAnnotationInjections(),</b>
<b class="nc">&nbsp;        containingType.getDeclaringTypeEnclosingAnnotationInjections(),</b>
<b class="nc">&nbsp;        containingType.getDeclaringPackageAnnotationInjections());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return &quot;Attribute[&quot; + name() + &quot;]&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  void initNullabilitySupertype(ExecutableElement accessor) {
<b class="nc">&nbsp;    if (nullabilityInSupertype == null &amp;&amp; !isPrimitive() &amp;&amp; !isNullable()) {</b>
<b class="nc">&nbsp;      nullabilityInSupertype = isAccessorNullableAccessor(accessor);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public boolean isNullableInSupertype() {
<b class="nc">&nbsp;    return nullabilityInSupertype != null;</b>
&nbsp;  }
&nbsp;
&nbsp;  public String atNullableInSupertypeLocal() {
<b class="nc">&nbsp;    return nullabilityInSupertype != null ? nullabilityInSupertype.asLocalPrefix() : &quot;&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public int limitLengthInToString() {
<b class="nc">&nbsp;    return protoclass().styles().style().limitStringLengthInToString();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean shouldLimitLengthInToString() {
<b class="nc">&nbsp;    return !isPrimitive() &amp;&amp; protoclass().styles().style().limitStringLengthInToString() &gt; 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean isBeanFriendlyModifiable() {
<b class="nc">&nbsp;    return containingType.isBeanFriendlyModifiable();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum ToName implements Function&lt;ValueAttribute, String&gt; {</b>
<b class="nc">&nbsp;    FUNCTION;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public String apply(ValueAttribute input) {
<b class="nc">&nbsp;      return input.name();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
