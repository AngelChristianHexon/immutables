


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Constitution</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: Constitution (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Constitution</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/142)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/264)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Constitution$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$AbstractNameForms</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$AppliedNameForms</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$InnerBaseClassDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/104)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$InnerBuilderDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$InnerModifiableDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Constitution$NameForms</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/222)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/439)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2014-2018 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import com.google.common.base.Joiner;
&nbsp;import com.google.common.base.Strings;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.PackageElement;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import org.immutables.generator.Naming;
&nbsp;import org.immutables.generator.Naming.Preference;
&nbsp;import org.immutables.generator.SourceExtraction;
&nbsp;import org.immutables.generator.SourceTypes;
&nbsp;import org.immutables.value.Value;
&nbsp;import org.immutables.value.processor.meta.Proto.DeclaringType;
&nbsp;import org.immutables.value.processor.meta.Proto.Protoclass;
&nbsp;import org.immutables.value.processor.meta.Reporter.About;
&nbsp;import org.immutables.value.processor.meta.Styles.PackageNaming;
&nbsp;import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;
&nbsp;import org.immutables.value.processor.meta.ValueMirrors.Style.BuilderVisibility;
&nbsp;import org.immutables.value.processor.meta.ValueMirrors.Style.ImplementationVisibility;
&nbsp;import static com.google.common.base.Preconditions.checkState;
&nbsp;import static com.google.common.base.Verify.verify;
&nbsp;
&nbsp;@Value.Enclosing
&nbsp;@Value.Immutable
<b class="nc">&nbsp;public abstract class Constitution {</b>
&nbsp;	private static final String NA_ERROR = &quot;!should_not_be_used_in_generated_code!&quot;;
&nbsp;	private static final String NEW_KEYWORD = &quot;new&quot;;
<b class="nc">&nbsp;	private static final Joiner DOT_JOINER = Joiner.on(&#39;.&#39;).skipNulls();</b>
&nbsp;
&nbsp;	public abstract Protoclass protoclass();
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public Generics generics() {
<b class="nc">&nbsp;		return new Generics(protoclass(),</b>
<b class="nc">&nbsp;				protoclass().kind().isConstructor()</b>
<b class="nc">&nbsp;						? protoclass().sourceElement().getEnclosingElement()</b>
<b class="nc">&nbsp;						: protoclass().sourceElement());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Derived
&nbsp;	public Visibility implementationVisibility() {
&nbsp;    ImplementationVisibility visibility;
<b class="nc">&nbsp;    if (!style().visibilityString().isEmpty()) {</b>
<b class="nc">&nbsp;      visibility = ImplementationVisibility.valueOf(style().visibilityString());</b>
&nbsp;    } else {
<b class="nc">&nbsp;      visibility = style().visibility();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;		if (visibility == ImplementationVisibility.PRIVATE</b>
<b class="nc">&nbsp;				&amp;&amp; !protoclass().features().builder()</b>
<b class="nc">&nbsp;				&amp;&amp; !protoclass().kind().isNested()) {</b>
<b class="nc">&nbsp;			protoclass()</b>
<b class="nc">&nbsp;					.report()</b>
<b class="nc">&nbsp;					.warning(About.INCOMPAT,</b>
&nbsp;							&quot;effective Style.visibility cannot be PRIVATE when builder is disabled and is not nested,&quot;
&nbsp;									+ &quot; automatically switching visibility to PACKAGE because top level implementation class is &quot; +
&nbsp;									&quot;required&quot;);
<b class="nc">&nbsp;			return Visibility.PACKAGE;</b>
&nbsp;		}
<b class="nc">&nbsp;		return protoclass().visibility().forImplementation(visibility);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Derived
&nbsp;	public Visibility builderVisibility() {
&nbsp;    Visibility visibility;
<b class="nc">&nbsp;    if (!style().builderVisibilityString().isEmpty()) {</b>
<b class="nc">&nbsp;      visibility = protoclass().visibility().forBuilder(BuilderVisibility.valueOf(style().builderVisibilityString()));</b>
&nbsp;    } else {
<b class="nc">&nbsp;      visibility = protoclass().visibility().forBuilder(style().builderVisibility());</b>
&nbsp;    }
<b class="nc">&nbsp;		if (visibility == Visibility.PUBLIC &amp;&amp; protoclass().styles().style().stagedBuilder()</b>
<b class="nc">&nbsp;				&amp;&amp; isNestedFactoryOrConstructor()) {</b>
<b class="nc">&nbsp;			return Visibility.PRIVATE;</b>
&nbsp;		}
<b class="nc">&nbsp;		return visibility;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isImplementationHidden() {
<b class="nc">&nbsp;		return implementationVisibility().isPrivate();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean returnsAbstractValueType() {
<b class="nc">&nbsp;		return isImplementationHidden()</b>
<b class="nc">&nbsp;				|| style().visibility() == ValueMirrors.Style.ImplementationVisibility.SAME_NON_RETURNED</b>
<b class="nc">&nbsp;				|| style().overshadowImplementation()</b>
<b class="nc">&nbsp;				|| (style().implementationNestedInBuilder()</b>
<b class="nc">&nbsp;				&amp;&amp; implementationVisibility().isMoreRestrictiveThan(builderVisibility()));</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isImplementationPrimary() {
<b class="nc">&nbsp;		return protoclass().visibility().isMoreRestrictiveThan(implementationVisibility());</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Derived
&nbsp;	public String implementationPackage() {
<b class="nc">&nbsp;		PackageNaming naming = protoclass().styles().packageGenerated();</b>
<b class="nc">&nbsp;		return naming.apply(definingPackage());</b>
&nbsp;	}
&nbsp;
&nbsp;	public String definingPackage() {
<b class="nc">&nbsp;		return protoclass().packageOf().name();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Derived
&nbsp;	public TypeNames names() {
<b class="nc">&nbsp;		return protoclass().createTypeNames();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typePreferablyAbstract() {
<b class="nc">&nbsp;		if (protoclass().kind().isValue()) {</b>
<b class="nc">&nbsp;			return isImplementationPrimary()</b>
<b class="nc">&nbsp;					? typeImmutable()</b>
<b class="nc">&nbsp;					: typeAbstract();</b>
&nbsp;		}
<b class="nc">&nbsp;		return typeValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeDocument() {
<b class="nc">&nbsp;		if (protoclass().kind().isValue()) {</b>
<b class="nc">&nbsp;			return isAbstractPrimary()</b>
<b class="nc">&nbsp;					? typeAbstract()</b>
<b class="nc">&nbsp;					: typeImmutable();</b>
&nbsp;		}
<b class="nc">&nbsp;		return typeValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeModifiable() {
<b class="nc">&nbsp;		checkState(protoclass().kind().isModifiable());</b>
<b class="nc">&nbsp;		String simple = names().typeModifiable();</b>
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(simple)</b>
<b class="nc">&nbsp;				.relativeRaw(inPackage(simple))</b>
<b class="nc">&nbsp;				.genericArgs(generics().args())</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(implementationVisibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public AppliedNameForms factoryCreate() {
<b class="nc">&nbsp;		return typeModifiable().applied(names().create());</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isAbstractPrimary() {
<b class="nc">&nbsp;		return returnsAbstractValueType()</b>
<b class="nc">&nbsp;				|| !isImplementationPrimary();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isSimple() {
<b class="nc">&nbsp;		return protoclass().kind().isValue()</b>
<b class="nc">&nbsp;				&amp;&amp; !protoclass().kind().isNested()</b>
<b class="nc">&nbsp;				&amp;&amp; implementationVisibility().isPublic()</b>
<b class="nc">&nbsp;				&amp;&amp; !returnsAbstractValueType();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Value is the canonical outside look of the value type. It should be either
&nbsp;	 * {@link #typeAbstract()} or {@link #typeImmutable()}.
&nbsp;	 * For factory it is a special surrogate.
&nbsp;	 * @return canonical value type name forms
&nbsp;	 */
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeValue() {
<b class="nc">&nbsp;		if (protoclass().kind().isValue()) {</b>
<b class="nc">&nbsp;			return returnsAbstractValueType()</b>
<b class="nc">&nbsp;					? typeAbstract()</b>
<b class="nc">&nbsp;					: typeImmutable();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (protoclass().kind().isJavaBean()) {</b>
<b class="nc">&nbsp;			return typeAbstract();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		if (isFactory()) {</b>
&nbsp;
<b class="nc">&nbsp;			if (protoclass().kind().isConstructor()) {</b>
<b class="nc">&nbsp;				TypeElement enclosingType = (TypeElement) protoclass().sourceElement().getEnclosingElement();</b>
&nbsp;
<b class="nc">&nbsp;				return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;						.simple(enclosingType.getSimpleName().toString())</b>
<b class="nc">&nbsp;						.relativeRaw(enclosingType.getQualifiedName().toString())</b>
<b class="nc">&nbsp;						.genericArgs(generics().args())</b>
<b class="nc">&nbsp;						.relativeAlreadyQualified(true)</b>
<b class="nc">&nbsp;						.packageOf(NA_ERROR)</b>
<b class="nc">&nbsp;						.visibility(protoclass().visibility())</b>
<b class="nc">&nbsp;						.build();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			ExecutableElement method = (ExecutableElement) protoclass().sourceElement();</b>
<b class="nc">&nbsp;			String type = method.getReturnType().toString();</b>
&nbsp;
<b class="nc">&nbsp;			return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;					.simple(NA_ERROR)</b>
<b class="nc">&nbsp;					.relativeRaw(type)</b>
<b class="nc">&nbsp;					.packageOf(NA_ERROR)</b>
<b class="nc">&nbsp;					.relativeAlreadyQualified(true)</b>
<b class="nc">&nbsp;					.visibility(protoclass().visibility())</b>
<b class="nc">&nbsp;					.build();</b>
&nbsp;		}
<b class="nc">&nbsp;		return typeEnclosing();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Derived
&nbsp;	public boolean hasImmutableInBuilder() {
<b class="nc">&nbsp;		return isOutsideBuilder() &amp;&amp; isTopLevelValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean hasTopLevelBuilder() {
<b class="nc">&nbsp;		return (isFactory() &amp;&amp; !isNestedFactoryOrConstructor())</b>
<b class="nc">&nbsp;				|| (isTopLevelValue() &amp;&amp; isOutsideBuilder());</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isFactory() {
<b class="nc">&nbsp;		return protoclass().kind().isFactory();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isNestedFactoryOrConstructor() {
<b class="nc">&nbsp;		return protoclass().kind().isNestedFactoryOrConstructor();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isNested() {
<b class="nc">&nbsp;		return protoclass().kind().isNested();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean hasTopLevelImmutable() {
<b class="nc">&nbsp;		return isTopLevelValue()</b>
<b class="nc">&nbsp;				&amp;&amp; !hasImmutableInBuilder();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isOutsideBuilder() {
<b class="nc">&nbsp;		return isFactory()</b>
<b class="nc">&nbsp;				|| (protoclass().features().builder()</b>
<b class="nc">&nbsp;				&amp;&amp; (isImplementationHidden()</b>
<b class="nc">&nbsp;				|| style().implementationNestedInBuilder()));</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isTopLevelValue() {
<b class="nc">&nbsp;		return protoclass().kind().isValue()</b>
<b class="nc">&nbsp;				&amp;&amp; !protoclass().kind().isNested();</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean hasEnclosingNonvalue() {
<b class="nc">&nbsp;		return protoclass().kind().isEnclosing()</b>
<b class="nc">&nbsp;				&amp;&amp; !protoclass().kind().isValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Actual abstract value type that is definitive model for the value type.
&nbsp;	 * @return abstract value type name forms
&nbsp;	 */
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeAbstract() {
<b class="nc">&nbsp;		if (protoclass().kind().isConstructor()) {</b>
<b class="nc">&nbsp;			return typeValue();</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		List&lt;String&gt; classSegments = Lists.newArrayListWithExpectedSize(2);</b>
<b class="nc">&nbsp;		Element e = SourceNames.collectClassSegments(protoclass().sourceElement(), classSegments);</b>
<b class="nc">&nbsp;		verify(e instanceof PackageElement);</b>
&nbsp;
<b class="nc">&nbsp;		String packageOf = ((PackageElement) e).getQualifiedName().toString();</b>
<b class="nc">&nbsp;		String relative = DOT_JOINER.join(classSegments);</b>
<b class="nc">&nbsp;		boolean relativeAlreadyQualified = false;</b>
&nbsp;
<b class="nc">&nbsp;		if (!implementationPackage().equals(packageOf)) {</b>
<b class="nc">&nbsp;			relative = DOT_JOINER.join(packageOf, relative);</b>
<b class="nc">&nbsp;			relativeAlreadyQualified = true;</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(names().typeAbstract)</b>
<b class="nc">&nbsp;				.relativeRaw(relative)</b>
<b class="nc">&nbsp;				.packageOf(packageOf)</b>
<b class="nc">&nbsp;				.genericArgs(generics().args())</b>
<b class="nc">&nbsp;				.relativeAlreadyQualified(relativeAlreadyQualified)</b>
<b class="nc">&nbsp;				.visibility(protoclass().visibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	public StyleInfo style() {
<b class="nc">&nbsp;		return protoclass().styles().style();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Package relative path
&nbsp;	 */
&nbsp;	private String inPackage(String topLevel, String... nested) {
<b class="nc">&nbsp;		return DOT_JOINER.join(null, topLevel, (Object[]) nested);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Actual immutable value type generated implementation.
&nbsp;	 * @return immutable implementation type name forms
&nbsp;	 */
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeImmutable() {
&nbsp;		String simple, relative;
&nbsp;
<b class="nc">&nbsp;		if (protoclass().kind().isNested()) {</b>
<b class="nc">&nbsp;			String enclosingSimpleName = typeImmutableEnclosingSimpleName();</b>
<b class="nc">&nbsp;			simple = names().typeImmutableNested();</b>
<b class="nc">&nbsp;			relative = inPackage(enclosingSimpleName, simple);</b>
<b class="nc">&nbsp;		} else if (hasImmutableInBuilder()) {</b>
<b class="nc">&nbsp;			simple = names().typeImmutable;</b>
<b class="nc">&nbsp;			relative = inPackage(typeBuilderSimpleName(), simple);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			simple = names().typeImmutable;</b>
<b class="nc">&nbsp;			relative = inPackage(simple);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(simple)</b>
<b class="nc">&nbsp;				.relativeRaw(relative)</b>
<b class="nc">&nbsp;				.genericArgs(generics().args())</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(implementationVisibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Walks to the enclosing type&#39;s simple names and applies naming convention.
&nbsp;	 * This shortcut/fix shows deficiency of model (it&#39;s probably more complicated than needed).
&nbsp;	 * @return enclosing immutable name
&nbsp;	 */
&nbsp;	@Value.Lazy
&nbsp;	String typeImmutableEnclosingSimpleName() {
<b class="nc">&nbsp;		DeclaringType declaringType = protoclass().enclosingOf().get();</b>
<b class="nc">&nbsp;		String enclosingSimpleName = declaringType.element().getSimpleName().toString();</b>
<b class="nc">&nbsp;		String enclosingRawName = names().rawFromAbstract(enclosingSimpleName);</b>
&nbsp;		// Here we check for having both enclosing and value
&nbsp;		// if we had protoclass it would be kind().isEnclosing() &amp;&amp; kind().isValue()
<b class="nc">&nbsp;		Naming naming = declaringType.isImmutable()</b>
<b class="nc">&nbsp;				? names().namings.typeImmutable</b>
<b class="nc">&nbsp;				: names().namings.typeImmutableEnclosing;</b>
&nbsp;
<b class="nc">&nbsp;		return naming.apply(enclosingRawName);</b>
&nbsp;	}
&nbsp;
&nbsp;	private String typeBuilderSimpleName() {
<b class="nc">&nbsp;		boolean isOutside = isOutsideBuilder();</b>
<b class="nc">&nbsp;		Naming typeBuilderNaming = names().namings.typeBuilder;</b>
<b class="nc">&nbsp;		if (isOutside) {</b>
&nbsp;			// For outer builder we can override with constant builder naming, but not the default.
<b class="nc">&nbsp;			boolean isPlainDefault =</b>
<b class="nc">&nbsp;					isConstantNamingEquals(typeBuilderNaming, protoclass().environment().defaultStyles().typeBuilder());</b>
&nbsp;
<b class="nc">&nbsp;			if (isPlainDefault) {</b>
<b class="nc">&nbsp;				typeBuilderNaming = typeBuilderNaming.requireNonConstant(Preference.SUFFIX);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return Naming.Usage.CAPITALIZED.apply(typeBuilderNaming.apply(names().raw));</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public AppliedNameForms factoryBuilder() {
<b class="nc">&nbsp;		InnerBuilderDefinition innerBuilder = innerBuilder();</b>
<b class="nc">&nbsp;		if (innerBuilder.isExtending) {</b>
<b class="nc">&nbsp;			return typeBuilder().applied(NEW_KEYWORD);</b>
&nbsp;		}
<b class="nc">&nbsp;		return factoryImplementationBuilder();</b>
&nbsp;	}
&nbsp;
&nbsp;	private AppliedNameForms factoryImplementationBuilder() {
<b class="nc">&nbsp;		boolean isOutsideNotNested = isOutsideBuilderNotNested();</b>
<b class="nc">&nbsp;		Naming methodBuilderNaming = isOutsideNotNested</b>
<b class="nc">&nbsp;				? names().namings.newBuilder</b>
<b class="nc">&nbsp;				: names().namings.builder;</b>
&nbsp;
<b class="nc">&nbsp;		boolean haveConstructorOnBuilder = isOutsideNotNested</b>
<b class="nc">&nbsp;				|| isConstantNamingEquals(methodBuilderNaming, NEW_KEYWORD);</b>
&nbsp;
<b class="nc">&nbsp;		NameForms typeNameForms = haveConstructorOnBuilder</b>
<b class="nc">&nbsp;				? typeBuilder()</b>
<b class="nc">&nbsp;				: typeImmutable();</b>
&nbsp;
<b class="nc">&nbsp;		String applied = methodBuilderNaming.apply(names().raw);</b>
<b class="nc">&nbsp;		if (isNestedFactoryOrConstructor()) {</b>
<b class="nc">&nbsp;			applied = names().raw + CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, applied);</b>
&nbsp;		}
<b class="nc">&nbsp;		return typeNameForms.applied(applied);</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isOutsideBuilderNotNested() {
<b class="nc">&nbsp;		return isOutsideBuilder() &amp;&amp; !isNestedFactoryOrConstructor();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean isConstantNamingEquals(Naming naming, String name) {
<b class="nc">&nbsp;		return naming.isConstant()</b>
<b class="nc">&nbsp;				&amp;&amp; naming.apply(&quot;&quot;).equals(name);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public AppliedNameForms factoryOf() {
<b class="nc">&nbsp;		if (isFactory()) {</b>
<b class="nc">&nbsp;			TypeElement enclosingType = (TypeElement) protoclass().sourceElement().getEnclosingElement();</b>
&nbsp;
<b class="nc">&nbsp;			String invoke = protoclass().kind().isConstructor()</b>
<b class="nc">&nbsp;					? &quot;new&quot;</b>
<b class="nc">&nbsp;					: protoclass().sourceElement().getSimpleName().toString();</b>
&nbsp;
<b class="nc">&nbsp;			return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;					.simple(enclosingType.getSimpleName().toString())</b>
<b class="nc">&nbsp;					.relativeRaw(enclosingType.getQualifiedName().toString())</b>
<b class="nc">&nbsp;					.genericArgs(generics().args())</b>
<b class="nc">&nbsp;					.relativeAlreadyQualified(true)</b>
<b class="nc">&nbsp;					.packageOf(NA_ERROR)</b>
<b class="nc">&nbsp;					.visibility(protoclass().visibility())</b>
<b class="nc">&nbsp;					.build()</b>
<b class="nc">&nbsp;					.applied(invoke);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return applyFactoryNaming(names().namings.of);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public AppliedNameForms factoryInstance() {
<b class="nc">&nbsp;		return applyFactoryNaming(names().namings.instance);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public AppliedNameForms factoryCopyOf() {
<b class="nc">&nbsp;		return applyFactoryNaming(names().namings.copyOf);</b>
&nbsp;	}
&nbsp;
&nbsp;	private AppliedNameForms applyFactoryNaming(Naming naming) {
<b class="nc">&nbsp;		String raw = names().raw;</b>
&nbsp;
<b class="nc">&nbsp;		boolean hasForwardingFactoryMethods = isImplementationHidden()</b>
<b class="nc">&nbsp;				&amp;&amp; protoclass().kind().isNested();</b>
&nbsp;
<b class="nc">&nbsp;		NameForms nameForms = hasForwardingFactoryMethods</b>
<b class="nc">&nbsp;				? typeEnclosingFactory()</b>
<b class="nc">&nbsp;				: typeImmutable();</b>
&nbsp;
<b class="nc">&nbsp;		if (hasForwardingFactoryMethods) {</b>
<b class="nc">&nbsp;			naming = naming.requireNonConstant(Preference.PREFIX);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		String applyName = Naming.Usage.LOWERIZED.apply(naming.apply(raw));</b>
&nbsp;
<b class="nc">&nbsp;		return nameForms.applied(applyName);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeEnclosingFactory() {
<b class="nc">&nbsp;		String enclosingSimpleName = typeImmutableEnclosingSimpleName();</b>
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(enclosingSimpleName)</b>
<b class="nc">&nbsp;				.relativeRaw(enclosingSimpleName)</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(protoclass().declaringVisibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeEnclosing() {
<b class="nc">&nbsp;		String name = protoclass().kind().isDefinedValue()</b>
<b class="nc">&nbsp;				? names().typeImmutable</b>
<b class="nc">&nbsp;				: names().typeImmutableEnclosing();</b>
&nbsp;
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(name)</b>
<b class="nc">&nbsp;				.relativeRaw(name)</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(implementationEnclosingVisibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	private Visibility implementationEnclosingVisibility() {
<b class="nc">&nbsp;		return implementationVisibility().max(Visibility.PACKAGE);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeWith() {
&nbsp;		String simple, relative;
&nbsp;
<b class="nc">&nbsp;		if (protoclass().kind().isNested()) {</b>
<b class="nc">&nbsp;			String enclosingSimpleName = typeImmutableEnclosingSimpleName();</b>
<b class="nc">&nbsp;			simple = names().typeWith();</b>
<b class="nc">&nbsp;			relative = inPackage(enclosingSimpleName, simple);</b>
<b class="nc">&nbsp;		} else if (hasImmutableInBuilder()) {</b>
<b class="nc">&nbsp;			simple = names().typeWith();</b>
<b class="nc">&nbsp;			relative = inPackage(typeBuilderSimpleName(), simple);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			simple = names().typeWith();</b>
<b class="nc">&nbsp;			relative = inPackage(simple);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(simple)</b>
<b class="nc">&nbsp;				.relativeRaw(relative)</b>
<b class="nc">&nbsp;				.genericArgs(generics().args())</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(implementationVisibility())</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeBuilder() {
<b class="nc">&nbsp;		InnerBuilderDefinition innerBuilder = innerBuilder();</b>
<b class="nc">&nbsp;		if (innerBuilder.isExtending) {</b>
<b class="nc">&nbsp;			NameForms typeAbstract = typeAbstract();</b>
<b class="nc">&nbsp;			return ImmutableConstitution.NameForms.copyOf(typeAbstract)</b>
<b class="nc">&nbsp;					.withRelativeRaw(DOT_JOINER.join(typeAbstract.relativeRaw(), innerBuilder.simpleName))</b>
<b class="nc">&nbsp;					.withSimple(innerBuilder.simpleName);</b>
&nbsp;		}
<b class="nc">&nbsp;		return typeImplementationBuilder();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public NameForms typeImplementationBuilder() {
<b class="nc">&nbsp;		TypeNames names = names();</b>
&nbsp;
<b class="nc">&nbsp;		boolean outside = isOutsideBuilder();</b>
<b class="nc">&nbsp;		boolean nested = protoclass().kind().isNested();</b>
&nbsp;
<b class="nc">&nbsp;		String simple = typeBuilderSimpleName();</b>
&nbsp;		String relative;
&nbsp;
<b class="nc">&nbsp;		if (outside &amp;&amp; nested) {</b>
<b class="nc">&nbsp;			relative = inPackage(typeImmutableEnclosingSimpleName(), simple);</b>
<b class="nc">&nbsp;		} else if (outside) {</b>
<b class="nc">&nbsp;			relative = inPackage(simple);</b>
<b class="nc">&nbsp;		} else if (nested) {</b>
<b class="nc">&nbsp;			relative = inPackage(inPackage(typeImmutableEnclosingSimpleName(), names.typeImmutableNested(), simple));</b>
&nbsp;		} else {
<b class="nc">&nbsp;			relative = inPackage(inPackage(names.typeImmutable, simple));</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		Visibility visibility = builderVisibility();</b>
&nbsp;
<b class="nc">&nbsp;		return ImmutableConstitution.NameForms.builder()</b>
<b class="nc">&nbsp;				.simple(simple)</b>
<b class="nc">&nbsp;				.relativeRaw(relative)</b>
<b class="nc">&nbsp;				.genericArgs(generics().args())</b>
<b class="nc">&nbsp;				.packageOf(implementationPackage())</b>
<b class="nc">&nbsp;				.visibility(visibility)</b>
<b class="nc">&nbsp;				.build();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Immutable
<b class="nc">&nbsp;	public static abstract class AppliedNameForms extends AbstractNameForms {</b>
&nbsp;		public abstract NameForms forms();
&nbsp;
&nbsp;		public abstract String applied();
&nbsp;
&nbsp;		@Override
&nbsp;		@Value.Derived
&nbsp;		public String simple() {
<b class="nc">&nbsp;			return isNew()</b>
<b class="nc">&nbsp;					? (NEW_KEYWORD + &#39; &#39; + forms().simple())</b>
<b class="nc">&nbsp;					: applied();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String relativeRaw() {
<b class="nc">&nbsp;			return isNew()</b>
<b class="nc">&nbsp;					? (NEW_KEYWORD + &#39; &#39; + forms().relativeRaw())</b>
<b class="nc">&nbsp;					: (forms().relativeRaw() + &#39;.&#39; + applied());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String relative() {
<b class="nc">&nbsp;			return combineApplied(false);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Value.Derived
&nbsp;		public boolean isNew() {
<b class="nc">&nbsp;			return NEW_KEYWORD.equals(applied());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			if (relativeAlreadyQualified()) {</b>
<b class="nc">&nbsp;				return relative();</b>
&nbsp;			}
<b class="nc">&nbsp;			return combineApplied(true);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String genericArgs() {
<b class="nc">&nbsp;			return forms().genericArgs();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public String packageOf() {
<b class="nc">&nbsp;			return forms().packageOf();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public Visibility visibility() {
<b class="nc">&nbsp;			return forms().visibility();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public boolean relativeAlreadyQualified() {
<b class="nc">&nbsp;			return forms().relativeAlreadyQualified();</b>
&nbsp;		}
&nbsp;
&nbsp;		private String combineApplied(boolean qualifyWithPackage) {
<b class="nc">&nbsp;			String base = forms().relativeRaw();</b>
<b class="nc">&nbsp;			if (qualifyWithPackage) {</b>
<b class="nc">&nbsp;				base = qualifyWithPackage(base);</b>
&nbsp;			}
<b class="nc">&nbsp;			return isNew()</b>
<b class="nc">&nbsp;					? (NEW_KEYWORD + &#39; &#39; + base + genericArgs())</b>
<b class="nc">&nbsp;					: (base + &#39;.&#39; + genericArgs() + applied());</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public static abstract class AbstractNameForms {</b>
&nbsp;		private static final String PUBLIC_MODIFIER_PREFIX = &quot;public &quot;;
&nbsp;		private static final String PRIVATE_MODIFIER_PREFIX = &quot;private &quot;;
&nbsp;
&nbsp;		public abstract String simple();
&nbsp;
&nbsp;		public abstract String relativeRaw();
&nbsp;
&nbsp;		public abstract String packageOf();
&nbsp;
&nbsp;		public abstract Visibility visibility();
&nbsp;
&nbsp;		@Value.Default
&nbsp;		public String absolute() {
<b class="nc">&nbsp;			return DOT_JOINER.join(packageOf(), relative());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Value.Default
&nbsp;		public String absoluteRaw() {
<b class="nc">&nbsp;			return DOT_JOINER.join(packageOf(), relativeRaw());</b>
&nbsp;		}
&nbsp;
&nbsp;		@Value.Default
&nbsp;		public String genericArgs() {
<b class="nc">&nbsp;			return &quot;&quot;;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Value.Default
&nbsp;		public boolean relativeAlreadyQualified() {
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		public String relative() {
<b class="nc">&nbsp;			return relativeRaw() + genericArgs();</b>
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Access prefix. Includes trailing space separator if not empty (package private).
&nbsp;		 * @return access keyword text
&nbsp;		 */
&nbsp;		public String access() {
<b class="nc">&nbsp;			switch (visibility()) {</b>
&nbsp;			case PRIVATE:
<b class="nc">&nbsp;				return PRIVATE_MODIFIER_PREFIX;</b>
&nbsp;			case PUBLIC:
<b class="nc">&nbsp;				return PUBLIC_MODIFIER_PREFIX;</b>
&nbsp;			default:
<b class="nc">&nbsp;				return &quot;&quot;;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		protected String qualifyWithPackage(String reference) {
<b class="nc">&nbsp;			return DOT_JOINER.join(Strings.emptyToNull(packageOf()), reference);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Value.Immutable
<b class="nc">&nbsp;	public static abstract class NameForms extends AbstractNameForms {</b>
&nbsp;
&nbsp;		/**
&nbsp;		 * Fully qualified type name
&nbsp;		 */
&nbsp;		@Override
&nbsp;		public String toString() {
<b class="nc">&nbsp;			return relativeAlreadyQualified()</b>
<b class="nc">&nbsp;					? relative()</b>
<b class="nc">&nbsp;					: qualifyWithPackage(relative());</b>
&nbsp;		}
&nbsp;
&nbsp;		public AppliedNameForms applied(String input) {
<b class="nc">&nbsp;			return ImmutableConstitution.AppliedNameForms.builder()</b>
<b class="nc">&nbsp;					.forms(this)</b>
<b class="nc">&nbsp;					.applied(input)</b>
<b class="nc">&nbsp;					.build();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public InnerBuilderDefinition innerBuilder() {
<b class="nc">&nbsp;		return new InnerBuilderDefinition();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Value.Lazy
&nbsp;	public InnerModifiableDefinition innerModifiable() {
<b class="nc">&nbsp;		return new InnerModifiableDefinition();</b>
&nbsp;	}
&nbsp;
&nbsp;	public final class InnerBuilderDefinition extends InnerBaseClassDefinition {
<b class="nc">&nbsp;		public InnerBuilderDefinition() {</b>
<b class="nc">&nbsp;			super(names().namings.typeInnerBuilder);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected boolean isApplicableTo(Protoclass p) {
<b class="nc">&nbsp;			return p.kind().isValue();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected boolean isExtending(TypeElement element) {
<b class="nc">&nbsp;			if (element.getKind() == ElementKind.CLASS) {</b>
<b class="nc">&nbsp;				String superclassString = SourceExtraction.getSuperclassString(element);</b>
<b class="nc">&nbsp;				String rawSuperclass = SourceTypes.extract(superclassString).getKey();</b>
&nbsp;				// If we are extending yet to be generated builder, we detect it by having the same name
&nbsp;				// as relative name of builder type
<b class="nc">&nbsp;				return rawSuperclass.endsWith(typeImplementationBuilder().relativeRaw());</b>
&nbsp;			}
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected void lateValidateExtending(TypeElement t) {
<b class="nc">&nbsp;			super.lateValidateExtending(t);</b>
&nbsp;
<b class="nc">&nbsp;			if (protoclass().styles().style().stagedBuilder()) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.warning(About.INCOMPAT,</b>
&nbsp;								&quot;Extending %s shouldn&#39;t be used with stagedBuilder style attribute, they are incompartible:&quot;
&nbsp;										+ &quot; Staged builder generate series of staged interfaces, but extending builder actually&quot;
&nbsp;										+ &quot; extends implementation and do not provide type safety for setting first attribute,&quot;
&nbsp;										+ &quot; as well as stagedBuilder forces generated builder interfaces to leak in code using the builder&quot;
&nbsp;										+ &quot; and hence defeating the purpose of using extending builder.&quot;,
<b class="nc">&nbsp;								t.getSimpleName());</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final class InnerModifiableDefinition extends InnerBaseClassDefinition {
<b class="nc">&nbsp;		public InnerModifiableDefinition() {</b>
<b class="nc">&nbsp;			super(names().namings.typeInnerModifiable);</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected boolean isApplicableTo(Protoclass p) {
<b class="nc">&nbsp;			return p.kind().isModifiable();</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected boolean isExtending(TypeElement t) {
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		protected void lateValidateSuper(TypeElement t) {
<b class="nc">&nbsp;			super.lateValidateSuper(t);</b>
&nbsp;
<b class="nc">&nbsp;			if (t.getKind() == ElementKind.CLASS) {</b>
<b class="nc">&nbsp;				String superclassString = SourceExtraction.getSuperclassString(t);</b>
<b class="nc">&nbsp;				String rawSuperclass = SourceTypes.extract(superclassString).getKey();</b>
&nbsp;				// We need to extend the base class
<b class="nc">&nbsp;				if (!typeAbstract().toString().endsWith(rawSuperclass)) {</b>
<b class="nc">&nbsp;					protoclass()</b>
<b class="nc">&nbsp;							.report()</b>
<b class="nc">&nbsp;							.withElement(t)</b>
<b class="nc">&nbsp;							.error(&quot;%s needs to extend the base class&quot;,</b>
<b class="nc">&nbsp;									t.getSimpleName());</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public abstract class InnerBaseClassDefinition {
&nbsp;		public final boolean isAccessibleFields;
&nbsp;		public final boolean isPresent;
&nbsp;		public final boolean isExtending;
&nbsp;		public final boolean isSuper;
&nbsp;		public final boolean isInterface;
&nbsp;		public final Visibility visibility;
&nbsp;		public final @Nullable String simpleName;
&nbsp;		public final @Nullable Generics generics;
&nbsp;		public final Naming naming;
&nbsp;
<b class="nc">&nbsp;		InnerBaseClassDefinition(Naming naming) {</b>
<b class="nc">&nbsp;			this.naming = naming;</b>
&nbsp;
<b class="nc">&nbsp;			@Nullable TypeElement baseElement = findBaseClassElement();</b>
&nbsp;			// The following series of checks designed
&nbsp;			// to not validate inner builder if it&#39;s disabled,
&nbsp;			// but at the same time we need such validation
&nbsp;			// if we are using &quot;extending&quot; builder which is still allowed
&nbsp;			// on demand even if builder feature is disabled
<b class="nc">&nbsp;			boolean extending = false;</b>
&nbsp;
<b class="nc">&nbsp;			if (baseElement != null) {</b>
<b class="nc">&nbsp;				extending = isExtending(baseElement);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (baseElement != null &amp;&amp; !protoclass().features().builder() &amp;&amp; !extending) {</b>
<b class="nc">&nbsp;				baseElement = null;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (baseElement != null &amp;&amp; !isValidInnerBaseClass(baseElement)) {</b>
<b class="nc">&nbsp;				baseElement = null;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (baseElement != null) {</b>
<b class="nc">&nbsp;				this.isAccessibleFields = AccessibleFieldsMirror.find(baseElement).isPresent();</b>
<b class="nc">&nbsp;				this.isPresent = true;</b>
<b class="nc">&nbsp;				this.isInterface = baseElement.getKind() == ElementKind.INTERFACE;</b>
<b class="nc">&nbsp;				this.isExtending = extending;</b>
<b class="nc">&nbsp;				this.isSuper = !extending;</b>
<b class="nc">&nbsp;				this.simpleName = baseElement.getSimpleName().toString();</b>
<b class="nc">&nbsp;				this.visibility = Visibility.of(baseElement);</b>
<b class="nc">&nbsp;				this.generics = new Generics(protoclass(), baseElement);</b>
<b class="nc">&nbsp;				if (isExtending) {</b>
<b class="nc">&nbsp;					lateValidateExtending(baseElement);</b>
&nbsp;				}
<b class="nc">&nbsp;				if (isSuper) {</b>
<b class="nc">&nbsp;					lateValidateSuper(baseElement);</b>
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				this.isAccessibleFields = false;</b>
<b class="nc">&nbsp;				this.isPresent = false;</b>
<b class="nc">&nbsp;				this.isInterface = false;</b>
<b class="nc">&nbsp;				this.isExtending = false;</b>
<b class="nc">&nbsp;				this.isSuper = false;</b>
<b class="nc">&nbsp;				this.visibility = Visibility.PRIVATE;</b>
<b class="nc">&nbsp;				this.simpleName = null;</b>
<b class="nc">&nbsp;				this.generics = Generics.empty();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		protected void lateValidateSuper(TypeElement t) {
<b class="nc">&nbsp;			List&lt;String&gt; undeclaredParams = Lists.newArrayList();</b>
<b class="nc">&nbsp;			for (String v : this.generics.vars()) {</b>
<b class="nc">&nbsp;				if (!generics().hasParameter(v)) {</b>
<b class="nc">&nbsp;					undeclaredParams.add(v);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!undeclaredParams.isEmpty()) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.error(&quot;Inner type %s%s uses generic parameter %s which are not present in value&#39;s declaration: %s&quot;,</b>
<b class="nc">&nbsp;								t.getSimpleName(),</b>
<b class="nc">&nbsp;								this.generics.args(),</b>
<b class="nc">&nbsp;								Joiner.on(&quot;, &quot;).join(undeclaredParams),</b>
<b class="nc">&nbsp;								generics());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		protected void lateValidateExtending(TypeElement t) {
<b class="nc">&nbsp;			if (t.getModifiers().contains(Modifier.ABSTRACT)) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.error(&quot;Extending %s shouldn&#39;t be abstract, it has to be instantiable&quot;,</b>
<b class="nc">&nbsp;								t.getSimpleName());</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (!this.generics.def().equals(generics().def())) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.error(&quot;Inner type %s should have the same type parameters as abstract value type: %s&quot;,</b>
<b class="nc">&nbsp;								t.getSimpleName(),</b>
<b class="nc">&nbsp;								generics().def());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		/**
&nbsp;		 * Used to determine if the inner class we&#39;re looking for is revelant
&nbsp;		 * given the annotations on the prototype class.  For example, there&#39;s
&nbsp;		 * no point in doing anything with an Modifiable inner class if it&#39;s
&nbsp;		 * not setup with the Value.Modifiable annotation.
&nbsp;		 */
&nbsp;		protected abstract boolean isApplicableTo(Protoclass p);
&nbsp;
&nbsp;		protected abstract boolean isExtending(TypeElement t);
&nbsp;
&nbsp;		@Nullable
&nbsp;		private TypeElement findBaseClassElement() {
<b class="nc">&nbsp;			Protoclass protoclass = protoclass();</b>
<b class="nc">&nbsp;			if (!isApplicableTo(protoclass)) {</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;			}
<b class="nc">&nbsp;			for (Element t : protoclass.sourceElement().getEnclosedElements()) {</b>
<b class="nc">&nbsp;				ElementKind kind = t.getKind();</b>
<b class="nc">&nbsp;				if (kind.isClass() || kind.isInterface()) {</b>
<b class="nc">&nbsp;					String simpleName = t.getSimpleName().toString();</b>
<b class="nc">&nbsp;					Naming typeInnerClassNaming = naming;</b>
&nbsp;
<b class="nc">&nbsp;					if (!typeInnerClassNaming.detect(simpleName).isEmpty()) {</b>
<b class="nc">&nbsp;						return (TypeElement) t;</b>
&nbsp;					}
&nbsp;				}
<b class="nc">&nbsp;			}</b>
<b class="nc">&nbsp;			return null;</b>
&nbsp;		}
&nbsp;
&nbsp;		private boolean isValidInnerBaseClass(Element t) {
<b class="nc">&nbsp;			ElementKind kind = t.getKind();</b>
<b class="nc">&nbsp;			if (kind != ElementKind.CLASS</b>
&nbsp;					&amp;&amp; kind != ElementKind.INTERFACE) {
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.warning(About.INCOMPAT,</b>
&nbsp;								&quot;Inner type %s is %s - not supported as Builder extend/super type&quot;,
<b class="nc">&nbsp;								t.getSimpleName(),</b>
<b class="nc">&nbsp;								kind.name().toLowerCase());</b>
&nbsp;
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			Set&lt;Modifier&gt; modifiers = t.getModifiers();</b>
&nbsp;
<b class="nc">&nbsp;			if (!modifiers.contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;					|| modifiers.contains(Modifier.PRIVATE)) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.warning(About.INCOMPAT,</b>
&nbsp;								&quot;Inner type %s should be static non-private to be supported as Builder extend/super type&quot;,
<b class="nc">&nbsp;								t.getSimpleName());</b>
&nbsp;
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (kind == ElementKind.CLASS</b>
<b class="nc">&nbsp;					&amp;&amp; !hasAccessibleConstructor(t)) {</b>
<b class="nc">&nbsp;				protoclass()</b>
<b class="nc">&nbsp;						.report()</b>
<b class="nc">&nbsp;						.withElement(t)</b>
<b class="nc">&nbsp;						.warning(About.INCOMPAT,</b>
&nbsp;								&quot;%s should have non-private no-argument constructor to be supported as Builder extend/super type&quot;,
<b class="nc">&nbsp;								t.getSimpleName());</b>
&nbsp;
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
&nbsp;		private boolean hasAccessibleConstructor(Element type) {
<b class="nc">&nbsp;			List&lt;ExecutableElement&gt; constructors = ElementFilter.constructorsIn(type.getEnclosedElements());</b>
&nbsp;
<b class="nc">&nbsp;			if (constructors.isEmpty()) {</b>
&nbsp;				// It is unclear (not checked) if we will have syntethic no-arg constructor
&nbsp;				// included, so we will assume no constructor to equate having a single constructors.
<b class="nc">&nbsp;				return true;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			for (ExecutableElement c : constructors) {</b>
<b class="nc">&nbsp;				if (c.getParameters().isEmpty()) {</b>
<b class="nc">&nbsp;					return !Visibility.of(c).isPrivate();</b>
&nbsp;				}
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
