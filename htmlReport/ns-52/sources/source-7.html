


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AttributeBuilderReflection</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.meta</a>
</div>

<h1>Coverage Summary for Class: AttributeBuilderReflection (org.immutables.value.processor.meta)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AttributeBuilderReflection</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AttributeBuilderReflection$FirstPartyStrategy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AttributeBuilderReflection$Strategy</td>
  </tr>
  <tr>
    <td class="name">AttributeBuilderReflection$ThirdPartyAttributeBuilderStrategy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/124)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/137)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/150)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/187)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.immutables.value.processor.meta;
&nbsp;
&nbsp;import com.google.common.base.Joiner;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.lang.model.element.ElementKind;
&nbsp;import javax.lang.model.element.ExecutableElement;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import javax.lang.model.element.TypeElement;
&nbsp;import javax.lang.model.type.TypeKind;
&nbsp;import javax.lang.model.util.Types;
&nbsp;import org.immutables.value.Value.Derived;
&nbsp;import org.immutables.value.Value.Immutable;
&nbsp;import org.immutables.value.Value.Lazy;
&nbsp;import org.immutables.value.Value.Parameter;
&nbsp;import org.immutables.value.Value.Style;
&nbsp;import org.immutables.value.Value.Style.ImplementationVisibility;
&nbsp;import org.immutables.value.processor.meta.AttributeBuilderDescriptor.ValueToBuilderTarget;
&nbsp;
&nbsp;/**
&nbsp; * Reflects over the returnType and generates strings for the {@link AttributeBuilderDescriptor}
&nbsp; */
&nbsp;@Immutable(builder = false)
&nbsp;@Style(visibility = ImplementationVisibility.PRIVATE)
<b class="nc">&nbsp;public abstract class AttributeBuilderReflection {</b>
<b class="nc">&nbsp;  private static final Map&lt;String, AttributeBuilderDescriptor&gt; analyzedReturnTypes = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;  // The discovery is based off of the class being investigated, AND the current attributeBuilder discovery pattern
&nbsp;  // The same class included in two parents, may or may not be nested builders based on that discovery pattern
&nbsp;  private static String cachingKey(ValueAttribute valueAttribute) {
<b class="nc">&nbsp;    return String.format(&quot;%s-%s&quot;,</b>
<b class="nc">&nbsp;        valueAttribute.containedTypeElement.getQualifiedName(),</b>
<b class="nc">&nbsp;        Joiner.on(&quot;.&quot;).join(valueAttribute.containingType.constitution.style().attributeBuilder()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public static AttributeBuilderReflection forValueType(ValueAttribute valueAttribute) {
<b class="nc">&nbsp;    return ImmutableAttributeBuilderReflection.of(valueAttribute);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Parameter
&nbsp;  abstract ValueAttribute valueAttribute();
&nbsp;
&nbsp;  @Lazy
&nbsp;  protected List&lt;Strategy&gt; getStrategies() {
&nbsp;    // Order here matters. We want first party to be found first.
<b class="nc">&nbsp;    return Arrays.asList(</b>
<b class="nc">&nbsp;        ImmutableFirstPartyStrategy.of(valueAttribute()),</b>
<b class="nc">&nbsp;        ThirdPartyAttributeBuilderStrategy.of(valueAttribute())</b>
&nbsp;    );
&nbsp;  }
&nbsp;
&nbsp;  @Lazy
&nbsp;  boolean isAttributeBuilder() {
<b class="nc">&nbsp;    if (!valueAttribute().containingType.constitution.style().attributeBuilderDetection()) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (valueAttribute().containedTypeElement == null) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    String cacheKey = cachingKey(valueAttribute());</b>
&nbsp;
<b class="nc">&nbsp;    if (analyzedReturnTypes.containsKey(cacheKey)) {</b>
<b class="nc">&nbsp;      return analyzedReturnTypes.get(cacheKey) != null;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (Strategy strategy : getStrategies()) {</b>
<b class="nc">&nbsp;      if (strategy.isAttributeBuilder()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    analyzedReturnTypes.put(cacheKey, null);</b>
&nbsp;
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Lazy
&nbsp;  AttributeBuilderDescriptor getAttributeBuilderDescriptor() {
<b class="nc">&nbsp;    if (!isAttributeBuilder()) {</b>
<b class="nc">&nbsp;      throw new IllegalStateException(</b>
&nbsp;          &quot;Should not call getReflectionStrategy unless isAttributeBuilder is true&quot;);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (valueAttribute().containedTypeElement == null) {</b>
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    String cacheKey = cachingKey(valueAttribute());</b>
<b class="nc">&nbsp;    if (analyzedReturnTypes.containsKey(cacheKey)) {</b>
<b class="nc">&nbsp;      return Preconditions.checkNotNull(analyzedReturnTypes</b>
<b class="nc">&nbsp;          .get(cacheKey));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    AttributeBuilderDescriptor descriptor = getReflectionStrategy().getAttributeBuilderDescriptor();</b>
<b class="nc">&nbsp;    analyzedReturnTypes.put(cacheKey, descriptor);</b>
&nbsp;
<b class="nc">&nbsp;    return descriptor;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Lazy
&nbsp;  protected Strategy getReflectionStrategy() {
<b class="nc">&nbsp;    for (Strategy strategy : getStrategies()) {</b>
<b class="nc">&nbsp;      if (strategy.isAttributeBuilder()) {</b>
<b class="nc">&nbsp;        return strategy;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    throw new AssertionError(&quot;isAttributeBuilder flip-flopped from true to false.&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Allows for different mechanisms of discovering nested builders.
&nbsp;   *
&nbsp;   * This is needed because Immutables value objects may not be available on the
&nbsp;   * class path during processing, which will be order dependent.
&nbsp;   */
&nbsp;  interface Strategy {
&nbsp;
&nbsp;    boolean isAttributeBuilder();
&nbsp;
&nbsp;    AttributeBuilderDescriptor getAttributeBuilderDescriptor();
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Strategy for processing first party immutables.  Honors both deepImmutableDiscovery, and
&nbsp;   * builder extension.
&nbsp;   */
&nbsp;  @Immutable(builder = false)
<b class="nc">&nbsp;  abstract static class FirstPartyStrategy implements Strategy {</b>
&nbsp;
&nbsp;    @Parameter
&nbsp;    abstract ValueAttribute valueAttribute();
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAttributeBuilder() {
<b class="nc">&nbsp;      return valueAttribute().attributeValueType != null &amp;&amp;</b>
<b class="nc">&nbsp;          valueAttribute().attributeValueType.isUseBuilder();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AttributeBuilderDescriptor getAttributeBuilderDescriptor() {
<b class="nc">&nbsp;      return ImmutableAttributeBuilderDescriptor.builder()</b>
<b class="nc">&nbsp;          .valueToBuilderTarget(ValueToBuilderTarget.BUILDER_INSTANCE)</b>
<b class="nc">&nbsp;          .valueToBuilderMethod(attributeValueType().names().from)</b>
<b class="nc">&nbsp;          .buildMethod(attributeValueType().names().build)</b>
<b class="nc">&nbsp;          .qualifiedValueTypeName(attributeValueType().typeImmutable().toString())</b>
<b class="nc">&nbsp;          .qualifiedBuilderTypeName(attributeValueType().typeBuilderImpl().toString())</b>
<b class="nc">&nbsp;          .qualifiedBuilderConstructorMethod(attributeValueType().factoryBuilder().toString())</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    ValueType attributeValueType() {
<b class="nc">&nbsp;      return valueAttribute().attributeValueType;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Strategy for parsing third party immutables. for example: the protocol buffer API.
&nbsp;   *
&nbsp;   * Assumes that all third party classes are available on the class path at processing time.
&nbsp;   *
&nbsp;   * If this is not the case, we may need to use a processing method that allows deferring of
&nbsp;   * compilation. Example, moving from auto-value to immutables... though maybe you would just
&nbsp;   * implement a new strategy for that use case...
&nbsp;   */
&nbsp;  @Immutable(builder = false)
<b class="nc">&nbsp;  abstract static class ThirdPartyAttributeBuilderStrategy implements Strategy {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Guaranteed not null if isAttributeBuilder is true.
&nbsp;     * @return model of how to generate attributeBuilder.
&nbsp;     */
&nbsp;    @Nullable @Parameter
&nbsp;    protected abstract AttributeBuilderThirdPartyModel builderModel();
&nbsp;
&nbsp;    /**
&nbsp;     * Guaranteed not null if isAttributeBuilder is true.
&nbsp;     * @return containingType of the value attribute.
&nbsp;     */
&nbsp;    @Nullable @Parameter
&nbsp;    protected abstract TypeElement attributeValueType();
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAttributeBuilder() {
<b class="nc">&nbsp;      return builderModel() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    @Override
&nbsp;    @Derived
&nbsp;    public AttributeBuilderDescriptor getAttributeBuilderDescriptor() {
<b class="nc">&nbsp;      if (!isAttributeBuilder()) {</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;      }
&nbsp;
&nbsp;      ValueToBuilderTarget target;
<b class="nc">&nbsp;      ExecutableElement copyMethod = builderModel().copyMethod();</b>
<b class="nc">&nbsp;      ExecutableElement builderMethod = builderModel().builderMethod();</b>
<b class="nc">&nbsp;      ExecutableElement buildMethod = builderModel().buildMethod();</b>
<b class="nc">&nbsp;      TypeElement attributeBuilderType = builderModel().builderType();</b>
&nbsp;
<b class="nc">&nbsp;      if (copyMethod.getKind() == ElementKind.CONSTRUCTOR) {</b>
<b class="nc">&nbsp;        target = ValueToBuilderTarget.BUILDER_CONSTRUCTOR;</b>
<b class="nc">&nbsp;      } else if (copyMethod.getModifiers().contains(Modifier.STATIC)) {</b>
<b class="nc">&nbsp;        if (copyMethod.getEnclosingElement().equals(attributeValueType())) {</b>
<b class="nc">&nbsp;          target = ValueToBuilderTarget.VALUE_TYPE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;          target = ValueToBuilderTarget.BUILDER_TYPE;</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        if (copyMethod.getEnclosingElement().equals(attributeValueType())) {</b>
<b class="nc">&nbsp;          target = ValueToBuilderTarget.VALUE_INSTANCE;</b>
&nbsp;        } else {
<b class="nc">&nbsp;          target = ValueToBuilderTarget.BUILDER_INSTANCE;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      String qualifiedBuilderConstructorMethod;
<b class="nc">&nbsp;      if (builderMethod.getEnclosingElement().equals(attributeValueType())) {</b>
<b class="nc">&nbsp;        qualifiedBuilderConstructorMethod = String.format(&quot;%s.%s&quot;,</b>
<b class="nc">&nbsp;            attributeValueType().getQualifiedName(),</b>
<b class="nc">&nbsp;            builderMethod.getSimpleName());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        if (builderMethod.getKind() == ElementKind.CONSTRUCTOR) {</b>
<b class="nc">&nbsp;          qualifiedBuilderConstructorMethod = String.format(&quot;new %s&quot;,</b>
<b class="nc">&nbsp;              attributeBuilderType.getQualifiedName());</b>
&nbsp;        } else {
<b class="nc">&nbsp;          qualifiedBuilderConstructorMethod = String.format(&quot;%s.%s&quot;,</b>
<b class="nc">&nbsp;              attributeBuilderType.getQualifiedName(),</b>
<b class="nc">&nbsp;              builderMethod.getSimpleName());</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return ImmutableAttributeBuilderDescriptor.builder()</b>
<b class="nc">&nbsp;          .valueToBuilderTarget(target)</b>
<b class="nc">&nbsp;          .valueToBuilderMethod(copyMethod.getSimpleName().toString())</b>
<b class="nc">&nbsp;          .buildMethod(buildMethod.getSimpleName().toString())</b>
<b class="nc">&nbsp;          .qualifiedValueTypeName(attributeValueType().getQualifiedName().toString())</b>
<b class="nc">&nbsp;          .qualifiedBuilderTypeName(attributeBuilderType.getQualifiedName().toString())</b>
<b class="nc">&nbsp;          .qualifiedBuilderConstructorMethod(qualifiedBuilderConstructorMethod)</b>
<b class="nc">&nbsp;          .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return strategy which has an AttributeBuilderDescriptor if attributeValue is an attributeBuilder.
&nbsp;     */
&nbsp;    static ThirdPartyAttributeBuilderStrategy of(ValueAttribute valueAttribute) {
<b class="nc">&nbsp;      TypeElement attributeValueType = valueAttribute.containedTypeElement;</b>
<b class="nc">&nbsp;      if (attributeValueType == null) {</b>
<b class="nc">&nbsp;        return ImmutableThirdPartyAttributeBuilderStrategy.of(null, null);</b>
&nbsp;      }
&nbsp;
&nbsp;      // Map of possible builder class to needed methods.
<b class="nc">&nbsp;      Map&lt;TypeElement, AttributeBuilderThirdPartyModel.Creator&gt; partiallyBuiltModels = new HashMap&lt;&gt;();</b>
&nbsp;      for (Element possibleBuilderMethodCopyMethodOrClass
<b class="nc">&nbsp;          : attributeValueType.getEnclosedElements()) {</b>
<b class="nc">&nbsp;        AttributeBuilderThirdPartyModel.Creator newBuilderModel = ModifiableCreator.create();</b>
&nbsp;
<b class="nc">&nbsp;        if (isPossibleBuilderClass(possibleBuilderMethodCopyMethodOrClass, valueAttribute)) {</b>
<b class="nc">&nbsp;          newBuilderModel.builderType((TypeElement) possibleBuilderMethodCopyMethodOrClass);</b>
<b class="nc">&nbsp;        } else if (isPossibleBuilderMethod(possibleBuilderMethodCopyMethodOrClass, true, valueAttribute)) {</b>
<b class="nc">&nbsp;          newBuilderModel</b>
<b class="nc">&nbsp;              .builderMethod((ExecutableElement) possibleBuilderMethodCopyMethodOrClass);</b>
<b class="nc">&nbsp;        } else if (isPossibleCopyMethod(valueAttribute,</b>
&nbsp;            possibleBuilderMethodCopyMethodOrClass, true)) {
<b class="nc">&nbsp;          newBuilderModel</b>
<b class="nc">&nbsp;              .copyMethod((ExecutableElement) possibleBuilderMethodCopyMethodOrClass);</b>
&nbsp;        }
&nbsp;
&nbsp;        // We found something on the loop interesting
<b class="nc">&nbsp;        if (newBuilderModel.findBuilderType() != null) {</b>
&nbsp;          AttributeBuilderThirdPartyModel.Creator maybeCompleteModel;
&nbsp;
<b class="nc">&nbsp;          if (partiallyBuiltModels.containsKey(newBuilderModel.findBuilderType())) {</b>
<b class="nc">&nbsp;            AttributeBuilderThirdPartyModel.Creator partiallyBuiltModel = partiallyBuiltModels</b>
<b class="nc">&nbsp;                .get(newBuilderModel.findBuilderType());</b>
<b class="nc">&nbsp;            partiallyBuiltModel.mergeFrom(newBuilderModel);</b>
<b class="nc">&nbsp;            maybeCompleteModel = partiallyBuiltModel;</b>
<b class="nc">&nbsp;          } else {</b>
<b class="nc">&nbsp;            processPossibleBuilder(valueAttribute, newBuilderModel);</b>
<b class="nc">&nbsp;            partiallyBuiltModels.put(newBuilderModel.findBuilderType(), newBuilderModel);</b>
<b class="nc">&nbsp;            maybeCompleteModel = newBuilderModel;</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          if (maybeCompleteModel.complete()) {</b>
<b class="nc">&nbsp;            return ImmutableThirdPartyAttributeBuilderStrategy.of(</b>
<b class="nc">&nbsp;                maybeCompleteModel.toImmutable(),</b>
&nbsp;                valueAttribute.containedTypeElement);
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return ImmutableThirdPartyAttributeBuilderStrategy.of(null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    // NB: because of the null checks here, we will prefer using static initialization
&nbsp;    // from the value object, but eh, doesn&#39;t really work that well because we may
&nbsp;    // break out of the value loop if this call to processPossibleBuilder completes the model.
&nbsp;    private static void processPossibleBuilder(ValueAttribute attribute,
&nbsp;        AttributeBuilderThirdPartyModel.Creator builderModel) {
<b class="nc">&nbsp;      for (Element possibleBuildMethodOrConstructor : builderModel.findBuilderType().getEnclosedElements()) {</b>
&nbsp;
<b class="nc">&nbsp;        if (builderModel.buildMethod() == null</b>
<b class="nc">&nbsp;            &amp;&amp; isPossibleBuildMethod(attribute, possibleBuildMethodOrConstructor)) {</b>
<b class="nc">&nbsp;          builderModel.buildMethod((ExecutableElement) possibleBuildMethodOrConstructor);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (builderModel.builderMethod() == null</b>
<b class="nc">&nbsp;            &amp;&amp; isPossibleBuilderMethod(possibleBuildMethodOrConstructor, false, attribute)) {</b>
<b class="nc">&nbsp;          builderModel.builderMethod((ExecutableElement) possibleBuildMethodOrConstructor);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (builderModel.copyMethod() == null</b>
<b class="nc">&nbsp;            &amp;&amp; isPossibleCopyMethod(attribute, possibleBuildMethodOrConstructor, false)) {</b>
<b class="nc">&nbsp;          builderModel.copyMethod((ExecutableElement) possibleBuildMethodOrConstructor);</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if there&#39;s a public way to build the value type with an instance no-arg method.
&nbsp;     *
&nbsp;     * @param attribute value attribute to check.
&nbsp;     * @param possibleBuildMethod method which matches {@link StyleMirror#attributeBuilder()}
&nbsp;     * @return true if this is the possibleBuildMethod can build the value type.
&nbsp;     */
&nbsp;    private static boolean isPossibleBuildMethod(ValueAttribute attribute, Element possibleBuildMethod) {
<b class="nc">&nbsp;      if (possibleBuildMethod.getKind() != ElementKind.METHOD) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (!attribute.containingType.names().possibleAttributeBuilder(possibleBuildMethod.getSimpleName())) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Types typeUtils = attribute.containingType.constitution.protoclass()</b>
<b class="nc">&nbsp;          .environment()</b>
<b class="nc">&nbsp;          .processing()</b>
<b class="nc">&nbsp;          .getTypeUtils();</b>
&nbsp;
<b class="nc">&nbsp;      ExecutableElement candidateBuildMethod = (ExecutableElement) possibleBuildMethod;</b>
<b class="nc">&nbsp;      return !candidateBuildMethod.getModifiers().contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;          &amp;&amp; candidateBuildMethod.getModifiers().contains(Modifier.PUBLIC)</b>
<b class="nc">&nbsp;          &amp;&amp; candidateBuildMethod.getTypeParameters().isEmpty()</b>
<b class="nc">&nbsp;          &amp;&amp; candidateBuildMethod.getReturnType().getKind() == TypeKind.DECLARED</b>
<b class="nc">&nbsp;          &amp;&amp; typeUtils.isSameType(candidateBuildMethod.getReturnType(), attribute.containedTypeElement.asType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return true if the possibleBuilderMethod matches the
&nbsp;     * Style#attributeBuilder() and returns a class.
&nbsp;     *
&nbsp;     * TODO: may need to make this return true if the return type is an interface too...
&nbsp;     *
&nbsp;     * @param possibleBuilderMethod executableElement
&nbsp;     */
&nbsp;    private static boolean isPossibleBuilderMethod(Element possibleBuilderMethod, boolean onValueType, ValueAttribute valueAttribute) {
<b class="nc">&nbsp;      if (possibleBuilderMethod.getKind() == ElementKind.METHOD) {</b>
<b class="nc">&nbsp;        if (!valueAttribute.containingType.names().possibleAttributeBuilder(possibleBuilderMethod.getSimpleName())) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ExecutableElement candidateMethod = (ExecutableElement) possibleBuilderMethod;</b>
&nbsp;
<b class="nc">&nbsp;        TypeKind kind = candidateMethod.getReturnType().getKind();</b>
&nbsp;
<b class="nc">&nbsp;        return possibleBuilderMethod.getModifiers().containsAll(</b>
<b class="nc">&nbsp;            Arrays.asList(Modifier.STATIC, Modifier.PUBLIC))</b>
<b class="nc">&nbsp;            &amp;&amp; candidateMethod.getParameters().isEmpty()</b>
<b class="nc">&nbsp;            &amp;&amp; candidateMethod.getReturnType().getKind() == TypeKind.DECLARED</b>
<b class="nc">&nbsp;            &amp;&amp; !kind.isPrimitive() &amp;&amp; kind != TypeKind.ARRAY;</b>
&nbsp;
<b class="nc">&nbsp;      } else if (!onValueType &amp;&amp; possibleBuilderMethod.getKind() == ElementKind.CONSTRUCTOR) {</b>
<b class="nc">&nbsp;        if (!valueAttribute.containingType.names().newTokenInAttributeBuilder()) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ExecutableElement candidateConstructor = (ExecutableElement) possibleBuilderMethod;</b>
&nbsp;
<b class="nc">&nbsp;        return candidateConstructor.getModifiers().contains(Modifier.PUBLIC)</b>
<b class="nc">&nbsp;            &amp;&amp; candidateConstructor.getTypeParameters().isEmpty();</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine if inner class could be a builder.
&nbsp;     *
&nbsp;     * @param possibleBuilderClass nested value element that could be builder class.
&nbsp;     * @return true if it&#39;s a static inner class.
&nbsp;     */
&nbsp;    private static boolean isPossibleBuilderClass(Element possibleBuilderClass, ValueAttribute valueAttribute) {
<b class="nc">&nbsp;      if (possibleBuilderClass.getKind() == ElementKind.CLASS) {</b>
<b class="nc">&nbsp;        return possibleBuilderClass.getModifiers().contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;            &amp;&amp; possibleBuilderClass.getKind() == ElementKind.CLASS</b>
<b class="nc">&nbsp;            &amp;&amp; valueAttribute.containingType.names().possibleAttributeBuilder(possibleBuilderClass.getSimpleName());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies to both builder and value candidates.
&nbsp;     *
&nbsp;     * @param valueAttribute the valueAttribute.
&nbsp;     * @param possibleCopyMethod candidate to check.
&nbsp;     */
&nbsp;    protected static boolean isPossibleCopyMethod(
&nbsp;        ValueAttribute valueAttribute,
&nbsp;        Element possibleCopyMethod,
&nbsp;        boolean onValueType) {
<b class="nc">&nbsp;      if (possibleCopyMethod.getKind() == ElementKind.METHOD) {</b>
<b class="nc">&nbsp;        if (!valueAttribute.containingType.names().possibleAttributeBuilder(possibleCopyMethod.getSimpleName())) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ExecutableElement candidateCopyMethod = (ExecutableElement) possibleCopyMethod;</b>
&nbsp;
<b class="nc">&nbsp;        Types typeUtils = valueAttribute.containingType.constitution.protoclass()</b>
<b class="nc">&nbsp;            .environment()</b>
<b class="nc">&nbsp;            .processing()</b>
<b class="nc">&nbsp;            .getTypeUtils();</b>
&nbsp;
<b class="nc">&nbsp;        if (candidateCopyMethod.getParameters().size() == 1</b>
<b class="nc">&nbsp;            &amp;&amp; typeUtils.isSameType(</b>
<b class="nc">&nbsp;                candidateCopyMethod.getParameters().get(0).asType(),</b>
<b class="nc">&nbsp;                valueAttribute.containedTypeElement.asType())) {</b>
&nbsp;
<b class="nc">&nbsp;          TypeKind kind = candidateCopyMethod.getReturnType().getKind();</b>
<b class="nc">&nbsp;          return !kind.isPrimitive() &amp;&amp; kind != TypeKind.ARRAY;</b>
&nbsp;          // handle proto style toBuilder() copy method... lots of BuilderModels created because of this
<b class="nc">&nbsp;        } else if (onValueType</b>
<b class="nc">&nbsp;            &amp;&amp; candidateCopyMethod.getParameters().size() == 0</b>
<b class="nc">&nbsp;            &amp;&amp; !candidateCopyMethod.getModifiers().contains(Modifier.STATIC)) {</b>
&nbsp;
<b class="nc">&nbsp;          TypeKind kind = candidateCopyMethod.getReturnType().getKind();</b>
<b class="nc">&nbsp;          return !kind.isPrimitive() &amp;&amp; kind != TypeKind.ARRAY;</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (!onValueType &amp;&amp; possibleCopyMethod.getKind() == ElementKind.CONSTRUCTOR) {</b>
&nbsp;
<b class="nc">&nbsp;        if (!valueAttribute.containingType.names().newTokenInAttributeBuilder()) {</b>
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ExecutableElement candidateConstructor = (ExecutableElement) possibleCopyMethod;</b>
<b class="nc">&nbsp;        return candidateConstructor.getParameters().size() == 1</b>
<b class="nc">&nbsp;            &amp;&amp; candidateConstructor.getParameters().get(0).asType().equals(valueAttribute.containedTypeElement.asType());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
