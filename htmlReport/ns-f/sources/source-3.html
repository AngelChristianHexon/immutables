


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > InMemoryBackend</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.criteria.inmemory</a>
</div>

<h1>Coverage Summary for Class: InMemoryBackend (org.immutables.criteria.inmemory)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InMemoryBackend</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InMemoryBackend$1</td>
  </tr>
  <tr>
    <td class="name">InMemoryBackend$Session</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/98)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/105)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2019 Immutables Authors and Contributors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.immutables.criteria.inmemory;
&nbsp;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import io.reactivex.Flowable;
&nbsp;import org.immutables.criteria.backend.Backend;
&nbsp;import org.immutables.criteria.backend.BackendException;
&nbsp;import org.immutables.criteria.backend.DefaultResult;
&nbsp;import org.immutables.criteria.backend.KeyExtractor;
&nbsp;import org.immutables.criteria.backend.StandardOperations;
&nbsp;import org.immutables.criteria.backend.WriteResult;
&nbsp;import org.immutables.criteria.expression.Collation;
&nbsp;import org.immutables.criteria.expression.Expression;
&nbsp;import org.immutables.criteria.expression.Query;
&nbsp;import org.reactivestreams.Publisher;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;/**
&nbsp; * Backend backed by a {@link Map} (usually {@link ConcurrentMap}).
&nbsp; */
&nbsp;@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;public class InMemoryBackend implements Backend {
&nbsp;
&nbsp;  /** mapping between class and its store */
&nbsp;  private final ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;Object, Object&gt;&gt; classToStore;
&nbsp;  private final KeyExtractor.Factory keyExtractorFactory;
&nbsp;
&nbsp;  public InMemoryBackend() {
<b class="nc">&nbsp;    this(InMemorySetup.of());</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public InMemoryBackend(InMemorySetup setup) {</b>
<b class="nc">&nbsp;    Objects.requireNonNull(setup, &quot;setup&quot;);</b>
<b class="nc">&nbsp;    this.keyExtractorFactory = setup.keyExtractorFactory();</b>
<b class="nc">&nbsp;    this.classToStore = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Session open(Class&lt;?&gt; entityType) {
<b class="nc">&nbsp;    final Map&lt;Object, Object&gt; store = classToStore.computeIfAbsent(entityType, key -&gt; new ConcurrentHashMap&lt;&gt;());</b>
<b class="nc">&nbsp;    return new Session(entityType, keyExtractorFactory.create(entityType), store);</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private static class Session implements Backend.Session {</b>
&nbsp;
&nbsp;    private final Class&lt;?&gt; entityType;
&nbsp;    private final PathExtractor pathExtractor;
&nbsp;    private final KeyExtractor keyExtractor;
&nbsp;    private final Map&lt;Object, Object&gt; store;
&nbsp;
<b class="nc">&nbsp;    private Session(Class&lt;?&gt; entityType, KeyExtractor extractor, Map&lt;Object, Object&gt; store) {</b>
<b class="nc">&nbsp;      this.entityType  = entityType;</b>
<b class="nc">&nbsp;      this.store = Objects.requireNonNull(store, &quot;store&quot;);</b>
<b class="nc">&nbsp;      Preconditions.checkArgument(extractor.metadata().isKeyDefined(),</b>
<b class="nc">&nbsp;              &quot;Key should be defined for %s. Did you use correct KeyExtractor %s ? &quot;, entityType, extractor.getClass().getName());</b>
<b class="nc">&nbsp;      this.keyExtractor = extractor;</b>
<b class="nc">&nbsp;      this.pathExtractor = new ReflectionExtractor();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Class&lt;?&gt; entityType() {
<b class="nc">&nbsp;      return entityType;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Result execute(Operation operation) {
<b class="nc">&nbsp;      return DefaultResult.of(executeInternal(operation));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;?&gt; executeInternal(Operation operation) {
<b class="nc">&nbsp;      if (operation instanceof StandardOperations.Select) {</b>
<b class="nc">&nbsp;        return query((StandardOperations.Select) operation);</b>
<b class="nc">&nbsp;      } else if (operation instanceof StandardOperations.Insert) {</b>
<b class="nc">&nbsp;        return insert((StandardOperations.Insert) operation);</b>
<b class="nc">&nbsp;      } else if (operation instanceof StandardOperations.Update) {</b>
<b class="nc">&nbsp;        return update((StandardOperations.Update) operation);</b>
<b class="nc">&nbsp;      } else if (operation instanceof StandardOperations.Delete) {</b>
<b class="nc">&nbsp;        return delete((StandardOperations.Delete) operation);</b>
<b class="nc">&nbsp;      } else if (operation instanceof StandardOperations.DeleteByKey) {</b>
<b class="nc">&nbsp;        return deleteByKey((StandardOperations.DeleteByKey) operation);</b>
<b class="nc">&nbsp;      } else if (operation instanceof StandardOperations.GetByKey) {</b>
<b class="nc">&nbsp;        return getByKey((StandardOperations.GetByKey) operation);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Flowable.error(new UnsupportedOperationException(String.format(&quot;Operation %s not supported&quot;, operation)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;?&gt; query(StandardOperations.Select select) {
<b class="nc">&nbsp;      final Query query = select.query();</b>
<b class="nc">&nbsp;      if (query.hasAggregations()) {</b>
<b class="nc">&nbsp;        throw new UnsupportedOperationException(&quot;Aggregations are not yet supported by &quot; + InMemoryBackend.class.getSimpleName());</b>
&nbsp;      }
<b class="nc">&nbsp;      Stream&lt;Object&gt; stream = store.values().stream();</b>
&nbsp;
&nbsp;      // filter
<b class="nc">&nbsp;      if (query.filter().isPresent()) {</b>
<b class="nc">&nbsp;        Predicate&lt;Object&gt; predicate = ExpressionInterpreter.of(query.filter().get()).asPredicate();</b>
<b class="nc">&nbsp;        stream = stream.filter(predicate);</b>
&nbsp;      }
&nbsp;
&nbsp;      // sort
<b class="nc">&nbsp;      if (!query.collations().isEmpty()) {</b>
<b class="nc">&nbsp;        Comparator&lt;Object&gt; comparator = null;</b>
<b class="nc">&nbsp;        for (Collation collation: query.collations()) {</b>
<b class="nc">&nbsp;          Function&lt;Object, Comparable&lt;Object&gt;&gt; fn = obj -&gt; (Comparable&lt;Object&gt;) pathExtractor.extract(collation.path(), obj);</b>
&nbsp;          @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;          Comparator&lt;Object&gt; newComparator = Comparator.&lt;Object, Comparable&gt;comparing(fn);</b>
<b class="nc">&nbsp;          if (!collation.direction().isAscending()) {</b>
<b class="nc">&nbsp;            newComparator = newComparator.reversed();</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          if (comparator != null) {</b>
<b class="nc">&nbsp;            comparator = comparator.thenComparing(newComparator);</b>
&nbsp;          } else {
<b class="nc">&nbsp;            comparator = newComparator;</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        stream = stream.sorted(comparator);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (query.hasProjections()) {</b>
<b class="nc">&nbsp;        final TupleExtractor extractor = new TupleExtractor(query, pathExtractor);</b>
<b class="nc">&nbsp;        stream = stream.map(extractor::extract);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (query.distinct()) {</b>
<b class="nc">&nbsp;        stream = stream.distinct();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (query.offset().isPresent()) {</b>
<b class="nc">&nbsp;        stream = stream.skip(query.offset().getAsLong());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (query.limit().isPresent()) {</b>
<b class="nc">&nbsp;        stream = stream.limit(query.limit().getAsLong());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (query.count()) {</b>
&nbsp;        // just return count
<b class="nc">&nbsp;        return Flowable.just(stream.count());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Flowable.fromIterable(stream.collect(Collectors.toList()));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;WriteResult&gt; update(StandardOperations.Update op) {
<b class="nc">&nbsp;      if (op.values().isEmpty()) {</b>
<b class="nc">&nbsp;        return Flowable.just(WriteResult.empty());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Map&lt;Object, Object&gt; toUpdate = op.values().stream().collect(Collectors.toMap(keyExtractor::extract, v -&gt; v));</b>
&nbsp;
<b class="nc">&nbsp;      if (op.upsert()) {</b>
<b class="nc">&nbsp;        return Flowable.fromCallable(() -&gt; {</b>
<b class="nc">&nbsp;          store.putAll(toUpdate);</b>
<b class="nc">&nbsp;          return WriteResult.unknown();</b>
&nbsp;        });
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Flowable.fromCallable(() -&gt; {</b>
<b class="nc">&nbsp;        toUpdate.forEach(store::replace);</b>
<b class="nc">&nbsp;        return WriteResult.unknown();</b>
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;WriteResult&gt; insert(StandardOperations.Insert op) {
<b class="nc">&nbsp;      if (op.values().isEmpty()) {</b>
<b class="nc">&nbsp;        return Flowable.just(WriteResult.empty());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final Map&lt;Object, Object&gt; toInsert = op.values().stream().collect(Collectors.toMap(keyExtractor::extract, x -&gt; x));</b>
<b class="nc">&nbsp;      toInsert.forEach((k, v) -&gt; {</b>
<b class="nc">&nbsp;        Object result = store.putIfAbsent(k, v);</b>
<b class="nc">&nbsp;        if (result != null) {</b>
<b class="nc">&nbsp;          throw new BackendException(String.format(&quot;Duplicate key %s for %s&quot;, k, entityType()));</b>
&nbsp;        }
&nbsp;      });
&nbsp;
<b class="nc">&nbsp;      return Flowable.just(WriteResult.unknown());</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;WriteResult&gt; deleteByKey(StandardOperations.DeleteByKey op) {
<b class="nc">&nbsp;      int deleted = 0;</b>
<b class="nc">&nbsp;      for(Object key: op.keys()) {</b>
<b class="nc">&nbsp;        if (store.remove(key) != null) {</b>
<b class="nc">&nbsp;          deleted++;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Flowable.just(WriteResult.empty().withDeletedCount(deleted));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;?&gt; getByKey(StandardOperations.GetByKey op) {
<b class="nc">&nbsp;      List&lt;Object&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;      for (Object key: op.keys()) {</b>
<b class="nc">&nbsp;        Object value = store.get(key);</b>
<b class="nc">&nbsp;        if (value != null) {</b>
<b class="nc">&nbsp;          result.add(value);</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return Flowable.fromIterable(result);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Publisher&lt;WriteResult&gt; delete(StandardOperations.Delete op) {
<b class="nc">&nbsp;      if (!op.query().filter().isPresent()) {</b>
&nbsp;        // delete all
<b class="nc">&nbsp;        int deleted = store.size();</b>
<b class="nc">&nbsp;        store.clear();</b>
<b class="nc">&nbsp;        return Flowable.just(WriteResult.empty().withDeletedCount(deleted));</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Expression filter = op.query().filter().orElseThrow(() -&gt; new IllegalArgumentException(&quot;no filter&quot;));</b>
&nbsp;
<b class="nc">&nbsp;      Predicate&lt;Object&gt; predicate = ExpressionInterpreter.of(filter).asPredicate();</b>
<b class="nc">&nbsp;      int deleted = 0;</b>
<b class="nc">&nbsp;      Iterator&lt;Object&gt; iter = store.values().iterator();</b>
<b class="nc">&nbsp;      while (iter.hasNext()) {</b>
<b class="nc">&nbsp;        if (predicate.test(iter.next())) {</b>
<b class="nc">&nbsp;          deleted++;</b>
<b class="nc">&nbsp;          iter.remove();</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Flowable.just(WriteResult.empty().withDeletedCount(deleted));</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
