


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Repositories</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.mongo.repository</a>
</div>

<h1>Coverage Summary for Class: Repositories (org.immutables.mongo.repository)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Repositories$Criteria</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Finder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Finder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$FinderWithDelete</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Indexer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Modifier</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Operation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Replacer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/42)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Repository$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$UpdatatingOperation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Repositories$Updater</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/180)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2013-2018 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.mongo.repository;
&nbsp;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.collect.FluentIterable;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.mongodb.client.FindIterable;
&nbsp;import com.mongodb.client.MongoCollection;
&nbsp;import com.mongodb.client.MongoCursor;
&nbsp;import com.mongodb.client.model.FindOneAndDeleteOptions;
&nbsp;import com.mongodb.client.model.FindOneAndReplaceOptions;
&nbsp;import com.mongodb.client.model.FindOneAndUpdateOptions;
&nbsp;import com.mongodb.client.model.IndexOptions;
&nbsp;import com.mongodb.client.model.ReplaceOptions;
&nbsp;import com.mongodb.client.model.ReturnDocument;
&nbsp;import com.mongodb.client.model.UpdateOptions;
&nbsp;import com.mongodb.client.result.DeleteResult;
&nbsp;import com.mongodb.client.result.UpdateResult;
&nbsp;import org.bson.codecs.configuration.CodecRegistry;
&nbsp;import org.bson.conversions.Bson;
&nbsp;import org.immutables.mongo.concurrent.FluentFuture;
&nbsp;import org.immutables.mongo.concurrent.FluentFutures;
&nbsp;import org.immutables.mongo.repository.internal.Constraints;
&nbsp;
&nbsp;import javax.annotation.Nonnegative;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.concurrent.NotThreadSafe;
&nbsp;import javax.annotation.concurrent.ThreadSafe;
&nbsp;import java.util.List;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import static com.google.common.base.Preconditions.checkArgument;
&nbsp;import static com.google.common.base.Preconditions.checkNotNull;
&nbsp;import static com.google.common.base.Preconditions.checkState;
&nbsp;import static org.immutables.mongo.repository.internal.Support.convertToBson;
&nbsp;import static org.immutables.mongo.repository.internal.Support.convertToIndex;
&nbsp;
&nbsp;/**
&nbsp; * Umbrella class which contains abstract super-types of repository and operation objects that
&nbsp; * inherited by generated repositories. These base classes performs bridging to underlying MongoDB
&nbsp; * java driver.
&nbsp; */
&nbsp;public final class Repositories {
&nbsp;  private static final int LARGE_BATCH_SIZE = 2000;
&nbsp;
&nbsp;  private Repositories() {}
&nbsp;
&nbsp;  /**
&nbsp;   * Base abstract class for repositories.
&nbsp;   * @param &lt;T&gt; type of document
&nbsp;   */
&nbsp;  @ThreadSafe
&nbsp;  public static abstract class Repository&lt;T&gt; {
&nbsp;
&nbsp;    private final RepositorySetup configuration;
&nbsp;    private final MongoCollection&lt;T&gt; collection;
&nbsp;    private final RepositorySetup.FieldNamingStrategy fieldNamingStrategy;
&nbsp;
&nbsp;    protected Repository(
&nbsp;        RepositorySetup configuration,
&nbsp;        String collectionName,
<b class="nc">&nbsp;        Class&lt;T&gt; type) {</b>
&nbsp;
<b class="nc">&nbsp;      this.configuration = checkNotNull(configuration, &quot;configuration&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(collectionName, &quot;collectionName&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(type, &quot;type&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      MongoCollection&lt;T&gt; collection =</b>
<b class="nc">&nbsp;          configuration.database.getCollection(collectionName, type);</b>
&nbsp;
<b class="nc">&nbsp;      this.collection = collection.withCodecRegistry(configuration.codecRegistry);</b>
&nbsp;
<b class="nc">&nbsp;      this.fieldNamingStrategy = configuration.fieldNamingStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Codec used for current collection type.
&nbsp;     * @return registry
&nbsp;     */
&nbsp;    protected final CodecRegistry codecRegistry() {
<b class="nc">&nbsp;      return collection.getCodecRegistry();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final RepositorySetup.FieldNamingStrategy fieldNamingStrategy() {
<b class="nc">&nbsp;      return fieldNamingStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final MongoCollection&lt;T&gt; collection() {
<b class="nc">&nbsp;      return collection;</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;V&gt; FluentFuture&lt;V&gt; submit(Callable&lt;V&gt; callable) {
<b class="nc">&nbsp;      return FluentFutures.from(configuration.executor.submit(callable));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Void&gt; doIndex(
&nbsp;        final Constraints.Constraint fields,
&nbsp;        final IndexOptions options) {
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;Void&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Void call() {
<b class="nc">&nbsp;          collection().createIndex(convertToIndex(fields), options);</b>
<b class="nc">&nbsp;          return null;</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Integer&gt; doInsert(final ImmutableList&lt;T&gt; documents) {
<b class="nc">&nbsp;      if (documents.isEmpty()) {</b>
<b class="nc">&nbsp;        return FluentFutures.from(Futures.immediateFuture(0));</b>
&nbsp;      }
<b class="nc">&nbsp;      return submit(new Callable&lt;Integer&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Integer call() {
<b class="nc">&nbsp;          collection().insertMany(documents);</b>
<b class="nc">&nbsp;          return 0; // java driver for mongo returns 0 anyway</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Optional&lt;T&gt;&gt; doReplace(
&nbsp;            final Constraints.ConstraintHost criteria,
&nbsp;            final T document,
&nbsp;            final FindOneAndReplaceOptions options) {
&nbsp;
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(document, &quot;document&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(options, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;Optional&lt;T&gt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Optional&lt;T&gt; call() throws Exception {
<b class="nc">&nbsp;          @Nullable T result = collection().findOneAndReplace(</b>
<b class="nc">&nbsp;              convertToBson(criteria), // query</b>
&nbsp;              document,
&nbsp;              options);
&nbsp;
<b class="nc">&nbsp;          return Optional.fromNullable(result);</b>
&nbsp;        }
&nbsp;      });
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Optional&lt;T&gt;&gt; doModify(
&nbsp;            final Constraints.ConstraintHost criteria,
&nbsp;            final Constraints.Constraint update,
&nbsp;            final FindOneAndUpdateOptions options) {
&nbsp;
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(update, &quot;update&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;Optional&lt;T&gt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Optional&lt;T&gt; call() throws Exception {
<b class="nc">&nbsp;          @Nullable T result = collection().findOneAndUpdate(</b>
<b class="nc">&nbsp;                  convertToBson(criteria),</b>
<b class="nc">&nbsp;                  convertToBson(update),</b>
&nbsp;                  options);
&nbsp;
<b class="nc">&nbsp;          return Optional.fromNullable(result);</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Optional&lt;T&gt;&gt; doFindOneAndDelete(
&nbsp;            final Constraints.ConstraintHost criteria,
&nbsp;            final FindOneAndDeleteOptions options) {
&nbsp;
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(options, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;Optional&lt;T&gt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Optional&lt;T&gt; call() throws Exception {
<b class="nc">&nbsp;          @Nullable T result = collection().findOneAndDelete(convertToBson(criteria), options);</b>
<b class="nc">&nbsp;          return Optional.fromNullable(result);</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Integer&gt; doUpdateFirst(
&nbsp;            final Constraints.ConstraintHost criteria,
&nbsp;            final Constraints.Constraint update,
&nbsp;            final FindOneAndUpdateOptions options
&nbsp;    ) {
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(update, &quot;update&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(options, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;Integer&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Integer call() {
<b class="nc">&nbsp;          T result = collection().findOneAndUpdate(</b>
<b class="nc">&nbsp;                  convertToBson(criteria),</b>
<b class="nc">&nbsp;                  convertToBson(update),</b>
&nbsp;                  options);
&nbsp;
<b class="nc">&nbsp;          return result == null ? 0 : 1;</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Integer&gt; doUpdate(
&nbsp;            final Constraints.ConstraintHost criteria,
&nbsp;            final Constraints.Constraint update,
&nbsp;            final UpdateOptions options) {
&nbsp;
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(update, &quot;update&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(options, &quot;options&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      return submit(new Callable&lt;UpdateResult&gt;() {</b>
&nbsp;        @Override
&nbsp;        public UpdateResult call() {
<b class="nc">&nbsp;          return collection()</b>
<b class="nc">&nbsp;              .updateMany(</b>
<b class="nc">&nbsp;              convertToBson(criteria),</b>
<b class="nc">&nbsp;              convertToBson(update),</b>
&nbsp;              options);
&nbsp;        }
<b class="nc">&nbsp;      }).lazyTransform(new Function&lt;UpdateResult, Integer&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Integer apply(UpdateResult input) {
<b class="nc">&nbsp;          return (int) input.getModifiedCount();</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;Integer&gt; doDelete(
&nbsp;        final Constraints.ConstraintHost criteria) {
<b class="nc">&nbsp;      checkNotNull(criteria);</b>
<b class="nc">&nbsp;      return submit(new Callable&lt;DeleteResult&gt;() {</b>
&nbsp;        @Override
&nbsp;        public DeleteResult call() {
<b class="nc">&nbsp;          return collection().deleteMany(convertToBson(criteria));</b>
&nbsp;        }
<b class="nc">&nbsp;      }).lazyTransform(new Function&lt;DeleteResult, Integer&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Integer apply(DeleteResult input) {
<b class="nc">&nbsp;          return (int) input.getDeletedCount();</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    protected final FluentFuture&lt;Integer&gt; doUpsert(
&nbsp;        final Constraints.ConstraintHost criteria,
&nbsp;        final T document) {
<b class="nc">&nbsp;      checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      checkNotNull(document, &quot;document&quot;);</b>
<b class="nc">&nbsp;      return submit(new Callable&lt;Integer&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Integer call() {
<b class="nc">&nbsp;          collection().replaceOne(convertToBson(criteria), document, new ReplaceOptions().upsert(true));</b>
&nbsp;          // upsert will always return 1:
&nbsp;          // if document doesn&#39;t exists, it will be inserted (modCount == 1)
&nbsp;          // if document exists, it will be updated (modCount == 1)
&nbsp;
<b class="nc">&nbsp;          return 1;</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    protected final FluentFuture&lt;List&lt;T&gt;&gt; doFetch(
&nbsp;        final @Nullable Constraints.ConstraintHost criteria,
&nbsp;        final Constraints.Constraint ordering,
&nbsp;        final Constraints.Constraint exclusion,
&nbsp;        final @Nonnegative int skip,
&nbsp;        final @Nonnegative int limit) {
<b class="nc">&nbsp;      return submit(new Callable&lt;List&lt;T&gt;&gt;() {</b>
&nbsp;        @SuppressWarnings(&quot;resource&quot;)
&nbsp;        @Override
&nbsp;        public List&lt;T&gt; call() throws Exception {
<b class="nc">&nbsp;          @Nullable Bson query = criteria != null ? convertToBson(criteria) : null;</b>
&nbsp;
<b class="nc">&nbsp;          FindIterable&lt;T&gt; cursor = collection().find(query);</b>
&nbsp;
<b class="nc">&nbsp;          if (!exclusion.isNil()) {</b>
<b class="nc">&nbsp;            cursor.projection(convertToBson(exclusion));</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          if (!ordering.isNil()) {</b>
<b class="nc">&nbsp;            cursor.sort(convertToBson(ordering));</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          cursor.skip(skip);</b>
&nbsp;
<b class="nc">&nbsp;          if (limit != 0) {</b>
<b class="nc">&nbsp;            cursor.limit(limit);</b>
<b class="nc">&nbsp;            if (limit &lt;= LARGE_BATCH_SIZE) {</b>
&nbsp;              // if limit specified and is smaller than reasonable large batch size
&nbsp;              // then we force batch size to be the same as limit,
&nbsp;              // but negative, this force cursor to close right after result is sent
<b class="nc">&nbsp;              cursor.batchSize(-limit);</b>
&nbsp;            }
&nbsp;          }
&nbsp;
&nbsp;          // close properly
<b class="nc">&nbsp;          try (MongoCursor&lt;T&gt; iterator = cursor.iterator()) {</b>
<b class="nc">&nbsp;            return ImmutableList.copyOf(iterator);</b>
<b class="nc">&nbsp;          }</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Call methods on Criteria to add constraint for search query.
&nbsp;   * As each constraint that is added, new immutable criteria created and returned. {@code Criteria}
&nbsp;   * objects are immutable so they can be passed along when needed in situations
&nbsp;   * such as when you need to separate how you choose documents from how you process them.
&nbsp;   * &lt;p&gt;
&nbsp;   * Constraints keeps adding up as using &#39;AND&#39; condition and could be separated in &#39;OR&#39; blocks
&nbsp;   * using {@link #or()} method, and ultimately, these blocks form a so called disjunctive normal
&nbsp;   * form. Such approach (DNF) was taken to achieve fine power/expressiveness balance in criteria
&nbsp;   * DSL embedded into Java language.
&nbsp;   */
&nbsp;  @ThreadSafe
<b class="nc">&nbsp;  public static abstract class Criteria {</b>
&nbsp;    /**
&nbsp;     * Returns chained criteria handle used to &quot;OR&quot; new constraint set to form logical DNF.
&nbsp;     * @return disjunction separated criteria handle
&nbsp;     */
&nbsp;    public abstract Criteria or();
&nbsp;  }
&nbsp;
&nbsp;  @NotThreadSafe
&nbsp;  static abstract class Operation&lt;T&gt; {
&nbsp;    protected final Repository&lt;T&gt; repository;
&nbsp;
<b class="nc">&nbsp;    protected Operation(Repository&lt;T&gt; repository) {</b>
<b class="nc">&nbsp;      this.repository = repository;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @NotThreadSafe
&nbsp;  static abstract class UpdatatingOperation&lt;T&gt; extends Operation&lt;T&gt; {
&nbsp;    @Nullable
&nbsp;    protected Constraints.ConstraintHost criteria;
<b class="nc">&nbsp;    protected Constraints.Constraint setFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint setOnInsertFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint incrementFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint addToSetFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint pushFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint pullFields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint unsetFields = Constraints.nilConstraint();</b>
&nbsp;
&nbsp;    protected UpdatatingOperation(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Constraints.Constraint collectRequiredUpdate() {
<b class="nc">&nbsp;      Constraints.Constraint update = collectUpdate();</b>
<b class="nc">&nbsp;      checkState(!update.isNil());</b>
<b class="nc">&nbsp;      return update;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Constraints.Constraint collectUpdate() {
<b class="nc">&nbsp;      Constraints.Constraint update = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$set&quot;, setFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$setOnInsert&quot;, setOnInsertFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$inc&quot;, incrementFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$addToSet&quot;, addToSetFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$push&quot;, pushFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$pull&quot;, pullFields);</b>
<b class="nc">&nbsp;      update = appendFields(update, &quot;$unset&quot;, unsetFields);</b>
<b class="nc">&nbsp;      return update;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Constraints.Constraint appendFields(
&nbsp;        Constraints.Constraint fields,
&nbsp;        String name,
&nbsp;        Constraints.Constraint setOfFields) {
<b class="nc">&nbsp;      return !setOfFields.isNil() ? fields.equal(name, false, setOfFields) : fields;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Base class which handles update operations (like {@code upsert}, {@code updateAll}, {@code updateFirst} etc.)
&nbsp;   * @param &lt;T&gt; document type
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class Updater&lt;T&gt; extends UpdatatingOperation&lt;T&gt; {
&nbsp;    protected Updater(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Perform upsert: update single element or inserts a new one if none of the document matches.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;em&gt;Note: Upsert operation requires special care to set or init all required attributes in case of insertion
&nbsp;     * (including but not limited to &#39;_id&#39;), so that valid document could be inserted into collection.
&nbsp;     * &lt;/em&gt;
&nbsp;     * @return future of number of processed document (expected to be 1)
&nbsp;     */
&nbsp;    public FluentFuture&lt;Integer&gt; upsert() {
<b class="nc">&nbsp;      UpdateOptions options = new UpdateOptions();</b>
<b class="nc">&nbsp;      options.upsert(true);</b>
<b class="nc">&nbsp;      return repository.doUpdate(criteria, collectRequiredUpdate(), options);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates a single document that matches.
&nbsp;     * @return number of updated documents. 0 or 1
&nbsp;     */
&nbsp;    public FluentFuture&lt;Integer&gt; updateFirst() {
<b class="nc">&nbsp;      return repository.doUpdateFirst(criteria, collectRequiredUpdate(), new FindOneAndUpdateOptions());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates all matching document.
&nbsp;     * @return future of number of updated document
&nbsp;     */
&nbsp;    public FluentFuture&lt;Integer&gt; updateAll() {
<b class="nc">&nbsp;      return repository.doUpdate(criteria, collectRequiredUpdate(), new UpdateOptions());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Provides base configuration methods and action methods to perform &#39;modify&#39; step in
&nbsp;   * &#39;findAndModify&#39; operation.
&nbsp;   *
&nbsp;   * @param &lt;T&gt; document type
&nbsp;   * @param &lt;M&gt; a self type of extended modifier class
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class Modifier&lt;T, M extends Modifier&lt;T, M&gt;&gt; extends UpdatatingOperation&lt;T&gt; {
<b class="nc">&nbsp;    protected Constraints.Constraint ordering = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint exclusion = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    private final FindOneAndUpdateOptions options = new FindOneAndUpdateOptions();</b>
&nbsp;
&nbsp;    protected Modifier(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this modifier so that old (not updated) version of document will be returned in
&nbsp;     * case of successful update.
&nbsp;     * This is default behavior so it may be called only for explanatory reasons.
&nbsp;     * @see #returningNew()
&nbsp;     * @return {@code this} modifier for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final M returningOld() {
<b class="nc">&nbsp;      options.returnDocument(ReturnDocument.BEFORE);</b>
<b class="nc">&nbsp;      return (M) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this modifier so that new (updated) version of document will be returned in
&nbsp;     * case of successful update.
&nbsp;     * @see #returningOld()
&nbsp;     * @return {@code this} modifier for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final M returningNew() {
<b class="nc">&nbsp;      options.returnDocument(ReturnDocument.AFTER);</b>
<b class="nc">&nbsp;      return (M) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs an upsert. If query will match a document, then it will be modified and old or new
&nbsp;     * version of document returned (depending if {@link #returningNew()} was configured). When
&nbsp;     * there
&nbsp;     * isn&#39;t any such matching document, a new one will be created and returned if
&nbsp;     * {@link #returningNew()} was configured.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;em&gt;Note: Upsert operation requires special care to set or init all required attributes
&nbsp;     * (including but not limited to &#39;_id&#39;), so that valid document could be inserted into collection.
&nbsp;     * &lt;/em&gt;
&nbsp;     * @return future of optional document.
&nbsp;     *
&nbsp;     */
&nbsp;    public final FluentFuture&lt;Optional&lt;T&gt;&gt; upsert() {
<b class="nc">&nbsp;      options.upsert(true);</b>
<b class="nc">&nbsp;      options.sort(convertToBson(ordering));</b>
&nbsp;      // TODO exclusion / projection
<b class="nc">&nbsp;      return repository.doModify(criteria, collectRequiredUpdate(), options);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs an update. If query will match a document, then it will be modified and old or new
&nbsp;     * version of document returned (depending if {@link #returningNew()} was configured). When
&nbsp;     * there
&nbsp;     * isn&#39;t any matching document, {@link Optional#absent()} will be result of the operation.
&nbsp;     * @return future of optional document (present if matching document would be found)
&nbsp;     */
&nbsp;    public final FluentFuture&lt;Optional&lt;T&gt;&gt; update() {
<b class="nc">&nbsp;      options.sort(convertToBson(ordering));</b>
&nbsp;      // TODO exlusion / projection
<b class="nc">&nbsp;      return repository.doModify(criteria, collectRequiredUpdate(), options);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Base class for handling replace operations on a mongo document given a criteria.
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class Replacer&lt;T, M extends Replacer&lt;T, M&gt;&gt; extends UpdatatingOperation&lt;T&gt; {
&nbsp;
&nbsp;    private final FindOneAndReplaceOptions options;
&nbsp;    private final T document;
&nbsp;    private final Constraints.ConstraintHost criteria;
&nbsp;    private final Constraints.Constraint ordering;
&nbsp;
&nbsp;    protected Replacer(
&nbsp;        Repository&lt;T&gt; repository,
&nbsp;        T document,
&nbsp;        Constraints.ConstraintHost criteria,
&nbsp;        Constraints.Constraint ordering) {
<b class="nc">&nbsp;      super(repository);</b>
<b class="nc">&nbsp;      this.document = checkNotNull(document, &quot;document&quot;);</b>
<b class="nc">&nbsp;      this.criteria = checkNotNull(criteria, &quot;criteria&quot;);</b>
<b class="nc">&nbsp;      this.ordering = checkNotNull(ordering, &quot;ordering&quot;);</b>
<b class="nc">&nbsp;      this.options = new FindOneAndReplaceOptions();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this modifier so that old (not updated) version of document will be returned in
&nbsp;     * case of successful update.
&nbsp;     * This is default behavior so it may be called only for explanatory reasons.
&nbsp;     * @see #returningNew()
&nbsp;     * @return {@code this} modifier for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final M returningOld() {
<b class="nc">&nbsp;      options.returnDocument(ReturnDocument.BEFORE);</b>
<b class="nc">&nbsp;      return (M) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this modifier so that new (updated) version of document will be returned in
&nbsp;     * case of successful update.
&nbsp;     * @see #returningOld()
&nbsp;     * @return {@code this} modifier for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final M returningNew() {
<b class="nc">&nbsp;      options.returnDocument(ReturnDocument.AFTER);</b>
<b class="nc">&nbsp;      return (M) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public final FluentFuture&lt;Optional&lt;T&gt;&gt; upsert() {
<b class="nc">&nbsp;      options.upsert(true);</b>
<b class="nc">&nbsp;      options.sort(convertToBson(ordering));</b>
<b class="nc">&nbsp;      return repository.doReplace(criteria, document, options);</b>
&nbsp;    }
&nbsp;
&nbsp;    public final FluentFuture&lt;Optional&lt;T&gt;&gt; update() {
<b class="nc">&nbsp;      options.sort(convertToBson(ordering));</b>
<b class="nc">&nbsp;      return repository.doReplace(criteria, document, options);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Base class for the indexer objects. Allows to create indexes for mongo documents at runtime.
&nbsp;   * @param &lt;T&gt; document type
&nbsp;   * @param &lt;I&gt; a self type of extended indexer class
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class Indexer&lt;T, I extends Indexer&lt;T, I&gt;&gt; extends Operation&lt;T&gt; {
<b class="nc">&nbsp;    protected Constraints.Constraint fields = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    private final IndexOptions options = new IndexOptions();</b>
&nbsp;
&nbsp;    protected Indexer(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures name for an index, that is otherwise will be auto-named by index fields.
&nbsp;     * @param indexName explicitly provided index name
&nbsp;     * @return {@code this} indexer for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final I named(String indexName) {
<b class="nc">&nbsp;      options.name(indexName);</b>
<b class="nc">&nbsp;      return (I) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes an index to enforce unique constraint.
&nbsp;     * @return {@code this} indexer for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final I unique() {
<b class="nc">&nbsp;      options.unique(true);</b>
<b class="nc">&nbsp;      return (I) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures and TTL for an index. Creates an index on a time field, and document will be
&nbsp;     * removed when TTL will expire.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;em&gt;Note: Care should be taken to configure TTL only on single time instant field&lt;/em&gt;
&nbsp;     * @param timeToLiveSeconds time to live for an object, non-zero time in seconds required.
&nbsp;     * @return {@code this} indexer for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect I to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final I expireAfterSeconds(int timeToLiveSeconds) {
<b class="nc">&nbsp;      options.expireAfter((long) timeToLiveSeconds, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;      return (I) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates configured index on a set of fields, if one does not already exist.
&nbsp;     * @see MongoCollection#createIndex(Bson, IndexOptions)
&nbsp;     * @return future of indexing operation, future value is insignificant ({@code null} typed as
&nbsp;     *         {@link Void})
&nbsp;     */
&nbsp;    public final FluentFuture&lt;Void&gt; ensure() {
<b class="nc">&nbsp;      return repository.doIndex(fields, options);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Fetcher class which adds delete functionality to the base class {@link Finder}.
&nbsp;   *
&nbsp;   * @param &lt;T&gt; document type
&nbsp;   * @param &lt;F&gt; a self type of extended finder class
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class FinderWithDelete&lt;T, F extends Finder&lt;T, F&gt;&gt; extends Finder&lt;T, F&gt; {
&nbsp;    protected FinderWithDelete(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delete all matching documents from the collection if they matches {@link Criteria}.
&nbsp;     * @return future of number of deleted documents if WriteConcern allows.
&nbsp;     */
&nbsp;    public FluentFuture&lt;Integer&gt; deleteAll() {
<b class="nc">&nbsp;      checkState(numberToSkip == 0, &quot;Cannot use .skip() with .deleteAll()&quot;);</b>
<b class="nc">&nbsp;      return repository.doDelete(criteria);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes and returns first matching document. Returns {@link Optional#absent()} if none
&nbsp;     * documents matches.
&nbsp;     * @return future of optional matching deleted document.
&nbsp;     */
&nbsp;    public FluentFuture&lt;Optional&lt;T&gt;&gt; deleteFirst() {
<b class="nc">&nbsp;      checkState(numberToSkip == 0, &quot;Cannot use .skip() with .deleteFirst()&quot;);</b>
<b class="nc">&nbsp;      FindOneAndDeleteOptions options = new FindOneAndDeleteOptions();</b>
<b class="nc">&nbsp;      options.sort(convertToBson(ordering));</b>
<b class="nc">&nbsp;      return repository.doFindOneAndDelete(criteria, options);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Base class for the finder objects. Fetcher objects are used to configure query.
&nbsp;   * @param &lt;T&gt; document type
&nbsp;   * @param &lt;F&gt; a self type of extended finder class
&nbsp;   */
&nbsp;  @NotThreadSafe
&nbsp;  public static abstract class Finder&lt;T, F extends Finder&lt;T, F&gt;&gt; extends Operation&lt;T&gt; {
&nbsp;    int numberToSkip;
&nbsp;
&nbsp;    @Nullable
&nbsp;    protected Constraints.ConstraintHost criteria;
<b class="nc">&nbsp;    protected Constraints.Constraint ordering = Constraints.nilConstraint();</b>
<b class="nc">&nbsp;    protected Constraints.Constraint exclusion = Constraints.nilConstraint();</b>
&nbsp;
&nbsp;    protected Finder(Repository&lt;T&gt; repository) {
<b class="nc">&nbsp;      super(repository);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures finder to skip a number of document. Useful for results pagination in
&nbsp;     * conjunction with {@link #fetchWithLimit(int) limiting}
&nbsp;     * @param numberToSkip number of documents to skip.
&nbsp;     * @return {@code this} finder for chained invocation
&nbsp;     */
&nbsp;    // safe unchecked: we expect F to be a self type
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public F skip(@Nonnegative int numberToSkip) {
<b class="nc">&nbsp;      checkArgument(numberToSkip &gt;= 0, &quot;number to skip cannot be negative&quot;);</b>
<b class="nc">&nbsp;      this.numberToSkip = numberToSkip;</b>
<b class="nc">&nbsp;      return (F) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fetches result list with at most as {@code limitSize} matching documents. It could
&nbsp;     * be used together with {@link #skip(int)} to paginate results.
&nbsp;     * &lt;p&gt;
&nbsp;     * Zero limit ({@code fetchWithLimit(0)}) is equivalent to {@link #fetchAll()}.
&nbsp;     * &lt;p&gt;
&nbsp;     * As an performance optimization, when limit is &quot;not so large&quot;, then batch size will be set to
&nbsp;     * a negative limit: this forces a MongoDB to sent results in a single batch and immediately
&nbsp;     * closes cursor.
&nbsp;     * @param limitSize specify limit on the number of document in result.
&nbsp;     * @return future of matching document list
&nbsp;     */
&nbsp;    public final FluentFuture&lt;List&lt;T&gt;&gt; fetchWithLimit(@Nonnegative int limitSize) {
<b class="nc">&nbsp;      checkArgument(limitSize &gt;= 0, &quot;limit cannot be negative&quot;);</b>
<b class="nc">&nbsp;      return repository.doFetch(criteria, ordering, exclusion, numberToSkip, limitSize);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fetches all matching documents list.
&nbsp;     * &lt;p&gt;
&nbsp;     * If number or results could be very large, then prefer to use {@link #fetchWithLimit(int)} to
&nbsp;     * always limit result to some large but reasonable size.
&nbsp;     * @return future of matching document list
&nbsp;     */
&nbsp;    public final FluentFuture&lt;List&lt;T&gt;&gt; fetchAll() {
<b class="nc">&nbsp;      return fetchWithLimit(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fetches first matching document. If none of the documents matches, then
&nbsp;     * {@link Optional#absent()} will be returned.
&nbsp;     * @return future of optional matching document
&nbsp;     */
&nbsp;    public final FluentFuture&lt;Optional&lt;T&gt;&gt; fetchFirst() {
<b class="nc">&nbsp;      return fetchWithLimit(1).transform(new Function&lt;List&lt;T&gt;, Optional&lt;T&gt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Optional&lt;T&gt; apply(List&lt;T&gt; input) {
<b class="nc">&nbsp;          return FluentIterable.from(input).first();</b>
&nbsp;        }
&nbsp;      });
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
