


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Accessors</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.generator.processor</a>
</div>

<h1>Coverage Summary for Class: Accessors (org.immutables.generator.processor)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Accessors</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Accessors$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$Accessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$Binder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$BoundAccess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$BoundAccessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$Cache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$LocalAccess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Accessors$UnresolvedAccessorException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/91)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/170)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2014 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.generator.processor;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import com.google.common.base.MoreObjects;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Throwables;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableMap;
&nbsp;import com.google.common.collect.Maps;
&nbsp;import org.immutables.generator.SourceOrdering;
&nbsp;import org.immutables.generator.SourceOrdering.AccessorProvider;
&nbsp;import org.immutables.generator.Templates;
&nbsp;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.concurrent.NotThreadSafe;
&nbsp;import javax.annotation.processing.ProcessingEnvironment;
&nbsp;import javax.lang.model.element.*;
&nbsp;import javax.lang.model.type.*;
&nbsp;import javax.lang.model.util.ElementFilter;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;
<b class="nc">&nbsp;public final class Accessors extends Introspection {</b>
<b class="nc">&nbsp;  private static final String OPTIONAL_TYPE_SIMPLE_NAME = Optional.class.getSimpleName();</b>
&nbsp;
&nbsp;  public final TypeMirror iterableTypeErasure;
&nbsp;  public final TypeElement iterableElement;
&nbsp;  public final TypeMirror invokableType;
&nbsp;  public final TypeMirror iterationType;
&nbsp;  public final TypeMirror objectType;
&nbsp;
&nbsp;  Accessors(ProcessingEnvironment environment) {
<b class="nc">&nbsp;    super(environment);</b>
<b class="nc">&nbsp;    this.iterableElement = elements.getTypeElement(Iterable.class.getName());</b>
<b class="nc">&nbsp;    this.iterableTypeErasure = types.erasure(iterableElement.asType());</b>
<b class="nc">&nbsp;    this.invokableType = elements.getTypeElement(Templates.Invokable.class.getCanonicalName()).asType();</b>
<b class="nc">&nbsp;    this.iterationType = elements.getTypeElement(Templates.Iteration.class.getCanonicalName()).asType();</b>
<b class="nc">&nbsp;    this.objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();</b>
&nbsp;  }
&nbsp;
&nbsp;  public TypeMirror wrapIterable(TypeMirror typeMirror) {
<b class="nc">&nbsp;    return types.getDeclaredType(iterableElement, typeMirror);</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private final Cache&lt;String, ImmutableMap&lt;String, Accessor&gt;&gt; accessorsDefined =</b>
<b class="nc">&nbsp;      new Cache&lt;String, ImmutableMap&lt;String, Accessor&gt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public ImmutableMap&lt;String, Accessor&gt; load(String key) throws Exception {
<b class="nc">&nbsp;          return extractFrom(elements.getTypeElement(key));</b>
&nbsp;        }
&nbsp;      };
&nbsp;
&nbsp;  ImmutableMap&lt;String, Accessor&gt; definedBy(TypeMirror type) {
<b class="nc">&nbsp;    if (type.getKind() == TypeKind.DECLARED) {</b>
<b class="nc">&nbsp;      return accessorsDefined.get(toName(type));</b>
&nbsp;    }
<b class="nc">&nbsp;    return ImmutableMap.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private ImmutableMap&lt;String, Accessor&gt; extractFrom(@Nullable TypeElement type) {
<b class="nc">&nbsp;    if (type == null) {</b>
<b class="nc">&nbsp;      return ImmutableMap.of();</b>
&nbsp;    }
<b class="nc">&nbsp;    Map&lt;String, Accessor&gt; accesors = Maps.newHashMap();</b>
<b class="nc">&nbsp;    collectAccessors(type, accesors);</b>
&nbsp;
<b class="nc">&nbsp;    Optional&lt;TypeElement&gt; implementationSubclass = getImplementationSubclass(type);</b>
<b class="nc">&nbsp;    if (implementationSubclass.isPresent()) {</b>
<b class="nc">&nbsp;      collectAccessors(implementationSubclass.get(), accesors);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return ImmutableMap.copyOf(accesors);</b>
&nbsp;  }
&nbsp;
&nbsp;  private Optional&lt;TypeElement&gt; getImplementationSubclass(TypeElement type) {
<b class="nc">&nbsp;    return Optional.fromNullable(</b>
<b class="nc">&nbsp;        elements.getTypeElement(</b>
<b class="nc">&nbsp;            GeneratedTypes.getQualifiedName(elements, type)));</b>
&nbsp;  }
&nbsp;
&nbsp;  private void collectAccessors(TypeElement type, Map&lt;String, Accessor&gt; accesors) {
<b class="nc">&nbsp;    List&lt;? extends Element&gt; allMembers = elements.getAllMembers(type);</b>
<b class="nc">&nbsp;    for (VariableElement field : ElementFilter.fieldsIn(allMembers)) {</b>
<b class="nc">&nbsp;      if (isAccessible(field)) {</b>
<b class="nc">&nbsp;        Accessor accessor = new Accessor(field);</b>
<b class="nc">&nbsp;        accesors.put(accessor.name, accessor);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;    // toString, hashCode from Object
<b class="nc">&nbsp;    for (ExecutableElement method : ElementFilter.methodsIn(allMembers)) {</b>
<b class="nc">&nbsp;      TypeElement definingType = (TypeElement) method.getEnclosingElement();</b>
<b class="nc">&nbsp;      if (definingType.getQualifiedName().contentEquals(Object.class.getCanonicalName())</b>
<b class="nc">&nbsp;          || isSimpleAccessor(method) &amp;&amp; isAccessible(method)) {</b>
<b class="nc">&nbsp;        Accessor accessor = new Accessor(method);</b>
<b class="nc">&nbsp;        accesors.put(accessor.name, accessor);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // For other accessors we use shared utility
<b class="nc">&nbsp;    AccessorProvider provider = SourceOrdering.getAllAccessorsProvider(elements, types, type);</b>
<b class="nc">&nbsp;    for (ExecutableElement method : provider.get()) {</b>
&nbsp;      // this should be already checked, but we check for completeness
<b class="nc">&nbsp;      if (isSimpleAccessor(method) &amp;&amp; isAccessible(method)) {</b>
<b class="nc">&nbsp;        Accessor accessor = new Accessor(method);</b>
<b class="nc">&nbsp;        accesors.put(accessor.name, accessor);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isAccessible(Element element) {
<b class="nc">&nbsp;    return !element.getModifiers().contains(Modifier.STATIC)</b>
<b class="nc">&nbsp;        &amp;&amp; !element.getModifiers().contains(Modifier.PRIVATE);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isSimpleAccessor(ExecutableElement method) {
<b class="nc">&nbsp;    return method.getParameters().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; method.getThrownTypes().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; method.getTypeParameters().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; method.getReturnType().getKind() != TypeKind.VOID;</b>
&nbsp;  }
&nbsp;
&nbsp;  public final class Accessor {
&nbsp;    public final Element element;
&nbsp;    public final String name;
&nbsp;    public final boolean callable;
&nbsp;
<b class="nc">&nbsp;    Accessor(Element element) {</b>
<b class="nc">&nbsp;      this.element = element;</b>
<b class="nc">&nbsp;      this.name = element.getSimpleName().toString();</b>
<b class="nc">&nbsp;      this.callable = element.getKind() == ElementKind.METHOD;</b>
&nbsp;    }
&nbsp;
&nbsp;    final BoundAccessor bind(TypeMirror target) {
&nbsp;      // asMemberOf wrongly implemented in ECJ,
&nbsp;      // we use it for fields only in Javac
&nbsp;      // but we expect it is already resolved
<b class="nc">&nbsp;      TypeMirror type = !inEclipseCompiler</b>
<b class="nc">&nbsp;          ? types.asMemberOf((DeclaredType) target, element)</b>
<b class="nc">&nbsp;          : element.asType();</b>
&nbsp;
<b class="nc">&nbsp;      if (type instanceof ExecutableType) {</b>
<b class="nc">&nbsp;        type = ((ExecutableType) type).getReturnType();</b>
&nbsp;      }
<b class="nc">&nbsp;      return new BoundAccessor(this, target, type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return element.getEnclosingElement().getSimpleName() + &quot;.&quot; + name + &quot;&quot; + (callable ? &quot;()&quot; : &quot;&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public abstract class BoundAccess {
&nbsp;    public final TypeMirror type;
&nbsp;    @Nullable
&nbsp;    public final TypeMirror containedType;
&nbsp;    public final String name;
&nbsp;    public final boolean invokable;
&nbsp;    public final boolean callable;
&nbsp;    public final boolean boxed;
&nbsp;
<b class="nc">&nbsp;    protected BoundAccess(TypeMirror type, String name, boolean callable) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.callable = callable;</b>
<b class="nc">&nbsp;      this.type = boxed(type);</b>
<b class="nc">&nbsp;      this.boxed = this.type != type;</b>
<b class="nc">&nbsp;      this.containedType = boxed(inferContainedType(type));</b>
<b class="nc">&nbsp;      this.invokable = types.isAssignable(type, invokableType);</b>
&nbsp;    }
&nbsp;
&nbsp;    private TypeMirror boxed(TypeMirror type) {
&nbsp;      // types.boxedClass fails on some compiler implementations
<b class="nc">&nbsp;      if (type == null) {</b>
<b class="nc">&nbsp;        return type;</b>
&nbsp;      }
<b class="nc">&nbsp;      Class&lt;?&gt; boxedClass = null;</b>
<b class="nc">&nbsp;      switch (type.getKind()) {</b>
&nbsp;      case BOOLEAN:
<b class="nc">&nbsp;        boxedClass = Boolean.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case SHORT:
<b class="nc">&nbsp;        boxedClass = Short.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case INT:
<b class="nc">&nbsp;        boxedClass = Integer.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case LONG:
<b class="nc">&nbsp;        boxedClass = Long.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case FLOAT:
<b class="nc">&nbsp;        boxedClass = Float.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case DOUBLE:
<b class="nc">&nbsp;        boxedClass = Double.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case CHAR:
<b class="nc">&nbsp;        boxedClass = Character.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case BYTE:
<b class="nc">&nbsp;        boxedClass = Byte.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case VOID:
<b class="nc">&nbsp;        boxedClass = Void.class;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      default:
&nbsp;      }
<b class="nc">&nbsp;      return boxedClass == null</b>
<b class="nc">&nbsp;          ? type</b>
<b class="nc">&nbsp;          : elements.getTypeElement(boxedClass.getName()).asType();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isContainer() {
<b class="nc">&nbsp;      return containedType != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    private TypeMirror inferContainedType(TypeMirror type) {
<b class="nc">&nbsp;      if (type.getKind() == TypeKind.DECLARED) {</b>
<b class="nc">&nbsp;        DeclaredType declaredType = (DeclaredType) type;</b>
<b class="nc">&nbsp;        if (isIterableType(declaredType) || isOptionalType(declaredType)) {</b>
&nbsp;          // TBD wrong logic to unpack, need to create super utility for introspecting type
&nbsp;          // hierarchy. Need to be fixed.
<b class="nc">&nbsp;          List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments();</b>
<b class="nc">&nbsp;          return typeArguments.size() == 1</b>
<b class="nc">&nbsp;              ? upperBound(typeArguments.get(0))</b>
<b class="nc">&nbsp;              : objectType;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      if (type instanceof ArrayType) {</b>
<b class="nc">&nbsp;        return upperBound(((ArrayType) type).getComponentType());</b>
&nbsp;      }
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private TypeMirror upperBound(TypeMirror type) {
<b class="nc">&nbsp;      switch (type.getKind()) {</b>
&nbsp;      case WILDCARD:
<b class="nc">&nbsp;        return MoreObjects.firstNonNull(((WildcardType) type).getExtendsBound(), objectType);</b>
&nbsp;      case TYPEVAR:
<b class="nc">&nbsp;        return ((TypeVariable) type).getUpperBound();</b>
&nbsp;      default:
<b class="nc">&nbsp;        return type;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    private boolean isIterableType(TypeMirror type) {
<b class="nc">&nbsp;      return types.isSubtype(types.erasure(type), iterableTypeErasure);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isOptionalType(DeclaredType parametrizedType) {
<b class="nc">&nbsp;      return parametrizedType.asElement().getSimpleName().contentEquals(OPTIONAL_TYPE_SIMPLE_NAME)</b>
<b class="nc">&nbsp;          &amp;&amp; parametrizedType.getTypeArguments().size() == 1;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public final class LocalAccess extends BoundAccess {
<b class="nc">&nbsp;    LocalAccess(String name, TypeMirror type) {</b>
<b class="nc">&nbsp;      super(type, name, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return &quot;&quot; + name + &quot;: &quot; + type;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public final class BoundAccessor extends BoundAccess {
&nbsp;    public final Accessor accessor;
&nbsp;    public final TypeMirror target;
&nbsp;
<b class="nc">&nbsp;    BoundAccessor(Accessor accessor, TypeMirror target, TypeMirror type) {</b>
<b class="nc">&nbsp;      super(type, accessor.name, accessor.callable);</b>
<b class="nc">&nbsp;      this.target = target;</b>
<b class="nc">&nbsp;      this.accessor = accessor;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return accessor + &quot;: &quot; + type;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public LocalAccess local(String value, TypeMirror requiredVar) {
<b class="nc">&nbsp;    return new LocalAccess(value, requiredVar);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Binder binder() {
<b class="nc">&nbsp;    return new Binder();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public final class Binder {</b>
<b class="nc">&nbsp;    private Binder() {}</b>
&nbsp;
&nbsp;    public BoundAccessor bind(TypeMirror targetType, String attribute) {
<b class="nc">&nbsp;      @Nullable BoundAccessor accessor = resolveAccessorWithBeanAccessor(targetType, attribute);</b>
&nbsp;
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      throw new UnresolvedAccessorException(</b>
&nbsp;          targetType,
&nbsp;          attribute,
<b class="nc">&nbsp;          collectAlternatives(targetType));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    private BoundAccessor resolveAccessorWithBeanAccessor(TypeMirror targetType, String attribute) {
<b class="nc">&nbsp;      @Nullable BoundAccessor accessor = resolveAccessor(targetType, attribute);</b>
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      String capitalizedName = CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, attribute);</b>
&nbsp;
<b class="nc">&nbsp;      accessor = resolveAccessor(targetType, &quot;get&quot; + capitalizedName);</b>
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      accessor = resolveAccessor(targetType, &quot;is&quot; + capitalizedName);</b>
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      accessor = resolveAccessor(targetType, &quot;$$&quot; + attribute);</b>
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return accessor;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    private BoundAccessor resolveAccessor(TypeMirror targetType, String attribute) {
<b class="nc">&nbsp;      @Nullable Accessor accessor = definedBy(targetType).get(attribute);</b>
&nbsp;
<b class="nc">&nbsp;      if (accessor != null) {</b>
<b class="nc">&nbsp;        return accessor.bind(targetType);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public BoundAccess bindLocalOrThis(TypeMirror type, String name, Map&lt;String, TypeMirror&gt; locals) {
<b class="nc">&nbsp;      TypeMirror typeMirror = locals.get(name);</b>
<b class="nc">&nbsp;      if (typeMirror != null) {</b>
<b class="nc">&nbsp;        return new LocalAccess(name, typeMirror);</b>
&nbsp;      }
<b class="nc">&nbsp;      return bind(type, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ImmutableList&lt;Accessor&gt; collectAlternatives(TypeMirror targetType) {
<b class="nc">&nbsp;      ImmutableList.Builder&lt;Accessor&gt; builder = ImmutableList.builder();</b>
&nbsp;
<b class="nc">&nbsp;      builder.addAll(definedBy(targetType).values());</b>
&nbsp;
<b class="nc">&nbsp;      return builder.build();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public static class UnresolvedAccessorException extends RuntimeException {
&nbsp;    public final TypeMirror targetType;
&nbsp;    public final String attribute;
&nbsp;    public final ImmutableList&lt;Accessor&gt; alternatives;
&nbsp;
&nbsp;    public UnresolvedAccessorException(
&nbsp;        TypeMirror targetType,
&nbsp;        String attribute,
<b class="nc">&nbsp;        ImmutableList&lt;Accessor&gt; alternatives) {</b>
<b class="nc">&nbsp;      this.targetType = targetType;</b>
<b class="nc">&nbsp;      this.attribute = attribute;</b>
<b class="nc">&nbsp;      this.alternatives = alternatives;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getMessage() {
<b class="nc">&nbsp;      return &quot;Unresolvable: &quot; + targetType + &quot;.&quot; + attribute + &quot;\n\tAlternatives: &quot; + alternatives;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // Do not use guava cache to slim down minimized jar
&nbsp;  @NotThreadSafe
<b class="nc">&nbsp;  private static abstract class Cache&lt;K, V&gt; {</b>
<b class="nc">&nbsp;    private final Map&lt;K, V&gt; map = Maps.newHashMap();</b>
&nbsp;
&nbsp;    protected abstract V load(K key) throws Exception;
&nbsp;
&nbsp;    final V get(K key) {
<b class="nc">&nbsp;      @Nullable V value = map.get(key);</b>
<b class="nc">&nbsp;      if (value == null) {</b>
&nbsp;        try {
<b class="nc">&nbsp;          value = load(key);</b>
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;          throw Throwables.propagate(ex);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        map.put(key, value);</b>
&nbsp;      }
<b class="nc">&nbsp;      return value;</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
