


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ImmutableTrees</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.generator.processor</a>
</div>

<h1>Coverage Summary for Class: ImmutableTrees (org.immutables.generator.processor)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
</tr>
  <tr>
    <td class="name">ImmutableTrees$1</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ApplyExpression</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ApplyExpression$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$AssignGenerator</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$AssignGenerator$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$BoundAccessExpression</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$BoundAccessExpression$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Comment</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ConditionalBlock</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ConditionalBlock$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Else</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ElseIf</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ElseIf$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$For</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$For$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ForEnd</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ForIterationAccessExpression</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ForStatement</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ForStatement$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ForStatement$InitShim</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Identifier</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$If</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$If$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$IfEnd</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$IfStatement</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$IfStatement$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokableDeclaration</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokableDeclaration$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Invoke</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Invoke$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokeEnd</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokeStatement</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokeStatement$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$InvokeString</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$IterationGenerator</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$IterationGenerator$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Let</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Let$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$LetEnd</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$LetStatement</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$LetStatement$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Newline</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Parameter</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Parameter$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ResolvedType</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ResolvedType$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$SimpleAccessExpression</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$SimpleAccessExpression$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$SimpleBlock</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$SimpleBlock$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$StringLiteral</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Template</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Template$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TemplateEnd</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TextBlock</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TextBlock$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TextFragment</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TextLine</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TextLine$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TransformGenerator</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TransformGenerator$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TypeDeclaration</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TypeDeclaration$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$TypeIdentifier</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Unit</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$Unit$Builder</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ValueDeclaration</td>
  </tr>
  <tr>
    <td class="name">ImmutableTrees$ValueDeclaration$Builder</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.immutables.generator.processor;
&nbsp;
&nbsp;import com.google.common.base.MoreObjects;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.primitives.Booleans;
&nbsp;import com.google.errorprone.annotations.CanIgnoreReturnValue;
&nbsp;import com.google.errorprone.annotations.Var;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import javax.annotation.CheckReturnValue;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.ParametersAreNonnullByDefault;
&nbsp;import javax.annotation.concurrent.Immutable;
&nbsp;import javax.annotation.concurrent.NotThreadSafe;
&nbsp;import org.immutables.value.Generated;
&nbsp;
&nbsp;/**
&nbsp; * {@code ImmutableTrees} contains immutable implementation classes generated from
&nbsp; * abstract value types defined as nested inside {@link Trees}.
&nbsp; * @see ImmutableTrees.Identifier
&nbsp; * @see ImmutableTrees.TypeIdentifier
&nbsp; * @see ImmutableTrees.TypeDeclaration
&nbsp; * @see ImmutableTrees.ResolvedType
&nbsp; * @see ImmutableTrees.BoundAccessExpression
&nbsp; * @see ImmutableTrees.InvokableDeclaration
&nbsp; * @see ImmutableTrees.ValueDeclaration
&nbsp; * @see ImmutableTrees.Parameter
&nbsp; * @see ImmutableTrees.SimpleBlock
&nbsp; * @see ImmutableTrees.Comment
&nbsp; * @see ImmutableTrees.ConditionalBlock
&nbsp; * @see ImmutableTrees.IfStatement
&nbsp; * @see ImmutableTrees.ForStatement
&nbsp; * @see ImmutableTrees.ForIterationAccessExpression
&nbsp; * @see ImmutableTrees.LetStatement
&nbsp; * @see ImmutableTrees.InvokeStatement
&nbsp; * @see ImmutableTrees.LetEnd
&nbsp; * @see ImmutableTrees.ForEnd
&nbsp; * @see ImmutableTrees.IfEnd
&nbsp; * @see ImmutableTrees.InvokeEnd
&nbsp; * @see ImmutableTrees.InvokeString
&nbsp; * @see ImmutableTrees.Invoke
&nbsp; * @see ImmutableTrees.Let
&nbsp; * @see ImmutableTrees.Unit
&nbsp; * @see ImmutableTrees.Template
&nbsp; * @see ImmutableTrees.SimpleAccessExpression
&nbsp; * @see ImmutableTrees.ApplyExpression
&nbsp; * @see ImmutableTrees.AssignGenerator
&nbsp; * @see ImmutableTrees.IterationGenerator
&nbsp; * @see ImmutableTrees.TransformGenerator
&nbsp; * @see ImmutableTrees.For
&nbsp; * @see ImmutableTrees.If
&nbsp; * @see ImmutableTrees.ElseIf
&nbsp; * @see ImmutableTrees.Else
&nbsp; * @see ImmutableTrees.TemplateEnd
&nbsp; * @see ImmutableTrees.StringLiteral
&nbsp; * @see ImmutableTrees.Newline
&nbsp; * @see ImmutableTrees.TextFragment
&nbsp; * @see ImmutableTrees.TextBlock
&nbsp; * @see ImmutableTrees.TextLine
&nbsp; */
&nbsp;@Generated(from = &quot;Trees&quot;, generator = &quot;Immutables&quot;)
&nbsp;@SuppressWarnings({&quot;all&quot;})
&nbsp;@ParametersAreNonnullByDefault
&nbsp;@javax.annotation.processing.Generated(&quot;org.immutables.processor.ProxyProcessor&quot;)
&nbsp;public final class ImmutableTrees {
&nbsp;  private ImmutableTrees() {}
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Identifier}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Identifier.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Identifier&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Identifier extends Trees.Identifier {
&nbsp;    private final String value;
&nbsp;
&nbsp;    private Identifier(String value) {
&nbsp;      this.value = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private Identifier(ImmutableTrees.Identifier original, String value) {
&nbsp;      this.value = value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code value} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String value() {
&nbsp;      return value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Identifier#value() value} attribute.
&nbsp;     * An equals check used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for value
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Identifier withValue(String value) {
&nbsp;      String newValue = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;      if (this.value.equals(newValue)) return this;
&nbsp;      return new ImmutableTrees.Identifier(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Identifier} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Identifier
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Identifier) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Identifier another) {
&nbsp;      return value.equals(another.value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code value}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + value.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code Identifier} instance.
&nbsp;     * @param value The value for the {@code value} attribute
&nbsp;     * @return An immutable Identifier instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Identifier of(String value) {
&nbsp;      return new ImmutableTrees.Identifier(value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Identifier} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Identifier instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Identifier copyOf(Trees.Identifier instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Identifier) {
&nbsp;        return (ImmutableTrees.Identifier) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Identifier.of(instance.value());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TypeIdentifier}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TypeIdentifier.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TypeIdentifier&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TypeIdentifier extends Trees.TypeIdentifier {
&nbsp;    private final String value;
&nbsp;
&nbsp;    private TypeIdentifier(String value) {
&nbsp;      this.value = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private TypeIdentifier(ImmutableTrees.TypeIdentifier original, String value) {
&nbsp;      this.value = value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code value} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String value() {
&nbsp;      return value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TypeIdentifier#value() value} attribute.
&nbsp;     * An equals check used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for value
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TypeIdentifier withValue(String value) {
&nbsp;      String newValue = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;      if (this.value.equals(newValue)) return this;
&nbsp;      return new ImmutableTrees.TypeIdentifier(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TypeIdentifier} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TypeIdentifier
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TypeIdentifier) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TypeIdentifier another) {
&nbsp;      return value.equals(another.value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code value}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + value.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code TypeIdentifier} instance.
&nbsp;     * @param value The value for the {@code value} attribute
&nbsp;     * @return An immutable TypeIdentifier instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TypeIdentifier of(String value) {
&nbsp;      return new ImmutableTrees.TypeIdentifier(value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TypeIdentifier} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TypeIdentifier instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TypeIdentifier copyOf(Trees.TypeIdentifier instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TypeIdentifier) {
&nbsp;        return (ImmutableTrees.TypeIdentifier) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TypeIdentifier.of(instance.value());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TypeDeclaration}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TypeDeclaration.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TypeDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TypeDeclaration extends Trees.TypeDeclaration {
&nbsp;    private final Trees.TypeIdentifier type;
&nbsp;    private final Trees.TypeDeclaration.Kind kind;
&nbsp;
&nbsp;    private TypeDeclaration(ImmutableTrees.TypeDeclaration.Builder builder) {
&nbsp;      this.type = builder.type;
&nbsp;      this.kind = builder.kind != null
&nbsp;          ? builder.kind
&nbsp;          : Objects.requireNonNull(super.kind(), &quot;kind&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private TypeDeclaration(
&nbsp;        Trees.TypeIdentifier type,
&nbsp;        Trees.TypeDeclaration.Kind kind) {
&nbsp;      this.type = type;
&nbsp;      this.kind = kind;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code type} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.TypeIdentifier type() {
&nbsp;      return type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code kind} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.TypeDeclaration.Kind kind() {
&nbsp;      return kind;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TypeDeclaration#type() type} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for type
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TypeDeclaration withType(Trees.TypeIdentifier value) {
&nbsp;      if (this.type == value) return this;
&nbsp;      Trees.TypeIdentifier newValue = Objects.requireNonNull(value, &quot;type&quot;);
&nbsp;      return new ImmutableTrees.TypeDeclaration(newValue, this.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TypeDeclaration#kind() kind} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for kind
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TypeDeclaration withKind(Trees.TypeDeclaration.Kind value) {
&nbsp;      if (this.kind == value) return this;
&nbsp;      Trees.TypeDeclaration.Kind newValue = Objects.requireNonNull(value, &quot;kind&quot;);
&nbsp;      if (this.kind.equals(newValue)) return this;
&nbsp;      return new ImmutableTrees.TypeDeclaration(this.type, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TypeDeclaration} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TypeDeclaration
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TypeDeclaration) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TypeDeclaration another) {
&nbsp;      return type.equals(another.type)
&nbsp;          &amp;&amp; kind.equals(another.kind);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code type}, {@code kind}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + type.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + kind.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code TypeDeclaration} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;TypeDeclaration&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;type&quot;, type)
&nbsp;          .add(&quot;kind&quot;, kind)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TypeDeclaration} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TypeDeclaration instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TypeDeclaration copyOf(Trees.TypeDeclaration instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TypeDeclaration) {
&nbsp;        return (ImmutableTrees.TypeDeclaration) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TypeDeclaration.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.TypeDeclaration TypeDeclaration}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.TypeDeclaration.builder()
&nbsp;     *    .type(org.immutables.generator.processor.Trees.TypeIdentifier) // required {@link Trees.TypeDeclaration#type() type}
&nbsp;     *    .kind(org.immutables.generator.processor.Trees.TypeDeclaration.Kind) // optional {@link Trees.TypeDeclaration#kind() kind}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new TypeDeclaration builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.TypeDeclaration.Builder builder() {
&nbsp;      return new ImmutableTrees.TypeDeclaration.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.TypeDeclaration TypeDeclaration}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.TypeDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_TYPE = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.TypeIdentifier type;
&nbsp;      private @Nullable Trees.TypeDeclaration.Kind kind;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code TypeDeclaration} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.TypeDeclaration instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        type(instance.type());
&nbsp;        kind(instance.kind());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TypeDeclaration#type() type} attribute.
&nbsp;       * @param type The value for type 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder type(Trees.TypeIdentifier type) {
&nbsp;        this.type = Objects.requireNonNull(type, &quot;type&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_TYPE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TypeDeclaration#kind() kind} attribute.
&nbsp;       * &lt;p&gt;&lt;em&gt;If not set, this attribute will have a default value as returned by the initializer of {@link Trees.TypeDeclaration#kind() kind}.&lt;/em&gt;
&nbsp;       * @param kind The value for kind 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder kind(Trees.TypeDeclaration.Kind kind) {
&nbsp;        this.kind = Objects.requireNonNull(kind, &quot;kind&quot;);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.TypeDeclaration TypeDeclaration}.
&nbsp;       * @return An immutable instance of TypeDeclaration
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.TypeDeclaration build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.TypeDeclaration(this);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_TYPE) != 0) attributes.add(&quot;type&quot;);
&nbsp;        return &quot;Cannot build TypeDeclaration, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ResolvedType}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ResolvedType.builder()}.
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ResolvedType.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ResolvedType&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ResolvedType extends Trees.ResolvedType {
&nbsp;    private final Object type;
&nbsp;
&nbsp;    private ResolvedType(Object type) {
&nbsp;      this.type = Objects.requireNonNull(type, &quot;type&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private ResolvedType(ImmutableTrees.ResolvedType original, Object type) {
&nbsp;      this.type = type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code type} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Object type() {
&nbsp;      return type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ResolvedType#type() type} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for type
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ResolvedType withType(Object value) {
&nbsp;      if (this.type == value) return this;
&nbsp;      Object newValue = Objects.requireNonNull(value, &quot;type&quot;);
&nbsp;      return new ImmutableTrees.ResolvedType(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ResolvedType} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ResolvedType
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ResolvedType) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ResolvedType another) {
&nbsp;      return type.equals(another.type);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code type}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + type.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code ResolvedType} instance.
&nbsp;     * @param type The value for the {@code type} attribute
&nbsp;     * @return An immutable ResolvedType instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ResolvedType of(Object type) {
&nbsp;      return new ImmutableTrees.ResolvedType(type);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ResolvedType} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ResolvedType instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ResolvedType copyOf(Trees.ResolvedType instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ResolvedType) {
&nbsp;        return (ImmutableTrees.ResolvedType) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ResolvedType.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ResolvedType ResolvedType}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ResolvedType.builder()
&nbsp;     *    .type(Object) // required {@link Trees.ResolvedType#type() type}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ResolvedType builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ResolvedType.Builder builder() {
&nbsp;      return new ImmutableTrees.ResolvedType.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ResolvedType ResolvedType}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ResolvedType&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_TYPE = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Object type;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code ResolvedType} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ResolvedType instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        type(instance.type());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ResolvedType#type() type} attribute.
&nbsp;       * @param type The value for type 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder type(Object type) {
&nbsp;        this.type = Objects.requireNonNull(type, &quot;type&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_TYPE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ResolvedType ResolvedType}.
&nbsp;       * @return An immutable instance of ResolvedType
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ResolvedType build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.ResolvedType(null, type);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_TYPE) != 0) attributes.add(&quot;type&quot;);
&nbsp;        return &quot;Cannot build ResolvedType, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.BoundAccessExpression}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.BoundAccessExpression.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.BoundAccessExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class BoundAccessExpression
&nbsp;      extends Trees.BoundAccessExpression {
&nbsp;    private final ImmutableList&lt;Trees.Identifier&gt; path;
&nbsp;    private final ImmutableList&lt;Object&gt; accessor;
&nbsp;
&nbsp;    private BoundAccessExpression(
&nbsp;        ImmutableList&lt;Trees.Identifier&gt; path,
&nbsp;        ImmutableList&lt;Object&gt; accessor) {
&nbsp;      this.path = path;
&nbsp;      this.accessor = accessor;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code path} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Identifier&gt; path() {
&nbsp;      return path;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code accessor} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Object&gt; accessor() {
&nbsp;      return accessor;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.BoundAccessExpression#path() path}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.BoundAccessExpression withPath(Trees.Identifier... elements) {
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.BoundAccessExpression(newValue, this.accessor);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.BoundAccessExpression#path() path}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of path elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.BoundAccessExpression withPath(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;      if (this.path == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.BoundAccessExpression(newValue, this.accessor);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.BoundAccessExpression#accessor() accessor}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.BoundAccessExpression withAccessor(Object... elements) {
&nbsp;      ImmutableList&lt;Object&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.BoundAccessExpression(this.path, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.BoundAccessExpression#accessor() accessor}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of accessor elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.BoundAccessExpression withAccessor(Iterable&lt;? extends Object&gt; elements) {
&nbsp;      if (this.accessor == elements) return this;
&nbsp;      ImmutableList&lt;Object&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.BoundAccessExpression(this.path, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code BoundAccessExpression} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.BoundAccessExpression
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.BoundAccessExpression) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.BoundAccessExpression another) {
&nbsp;      return path.equals(another.path)
&nbsp;          &amp;&amp; accessor.equals(another.accessor);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code path}, {@code accessor}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + path.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + accessor.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.BoundAccessExpression} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable BoundAccessExpression instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.BoundAccessExpression copyOf(Trees.BoundAccessExpression instance) {
&nbsp;      if (instance instanceof ImmutableTrees.BoundAccessExpression) {
&nbsp;        return (ImmutableTrees.BoundAccessExpression) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.BoundAccessExpression.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.BoundAccessExpression BoundAccessExpression}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.BoundAccessExpression.builder()
&nbsp;     *    .addPath|addAllPath(org.immutables.generator.processor.Trees.Identifier) // {@link Trees.BoundAccessExpression#path() path} elements
&nbsp;     *    .addAccessor|addAllAccessor(Object) // {@link Trees.BoundAccessExpression#accessor() accessor} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new BoundAccessExpression builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.BoundAccessExpression.Builder builder() {
&nbsp;      return new ImmutableTrees.BoundAccessExpression.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.BoundAccessExpression BoundAccessExpression}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.BoundAccessExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.Identifier&gt; path = ImmutableList.builder();
&nbsp;      private ImmutableList.Builder&lt;Object&gt; accessor = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.BoundAccessExpression} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.BoundAccessExpression instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.AccessExpression} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.AccessExpression instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.BoundAccessExpression) {
&nbsp;          Trees.BoundAccessExpression instance = (Trees.BoundAccessExpression) object;
&nbsp;          addAllAccessor(instance.accessor());
&nbsp;        }
&nbsp;        if (object instanceof Trees.AccessExpression) {
&nbsp;          Trees.AccessExpression instance = (Trees.AccessExpression) object;
&nbsp;          addAllPath(instance.path());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.BoundAccessExpression#path() path} list.
&nbsp;       * @param element A path element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addPath(Trees.Identifier element) {
&nbsp;        this.path.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.BoundAccessExpression#path() path} list.
&nbsp;       * @param elements An array of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addPath(Trees.Identifier... elements) {
&nbsp;        this.path.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.BoundAccessExpression#path() path} list.
&nbsp;       * @param elements An iterable of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder path(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;        this.path = ImmutableList.builder();
&nbsp;        return addAllPath(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.BoundAccessExpression#path() path} list.
&nbsp;       * @param elements An iterable of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllPath(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;        this.path.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.BoundAccessExpression#accessor() accessor} list.
&nbsp;       * @param element A accessor element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAccessor(Object element) {
&nbsp;        this.accessor.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.BoundAccessExpression#accessor() accessor} list.
&nbsp;       * @param elements An array of accessor elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAccessor(Object... elements) {
&nbsp;        this.accessor.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.BoundAccessExpression#accessor() accessor} list.
&nbsp;       * @param elements An iterable of accessor elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder accessor(Iterable&lt;? extends Object&gt; elements) {
&nbsp;        this.accessor = ImmutableList.builder();
&nbsp;        return addAllAccessor(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.BoundAccessExpression#accessor() accessor} list.
&nbsp;       * @param elements An iterable of accessor elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllAccessor(Iterable&lt;? extends Object&gt; elements) {
&nbsp;        this.accessor.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.BoundAccessExpression BoundAccessExpression}.
&nbsp;       * @return An immutable instance of BoundAccessExpression
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.BoundAccessExpression build() {
&nbsp;        return new ImmutableTrees.BoundAccessExpression(path.build(), accessor.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.InvokableDeclaration}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.InvokableDeclaration.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.InvokableDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class InvokableDeclaration
&nbsp;      implements Trees.InvokableDeclaration {
&nbsp;    private final Trees.Identifier name;
&nbsp;    private final ImmutableList&lt;Trees.Parameter&gt; parameters;
&nbsp;
&nbsp;    private InvokableDeclaration(
&nbsp;        Trees.Identifier name,
&nbsp;        ImmutableList&lt;Trees.Parameter&gt; parameters) {
&nbsp;      this.name = name;
&nbsp;      this.parameters = parameters;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code name} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Identifier name() {
&nbsp;      return name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parameters} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Parameter&gt; parameters() {
&nbsp;      return parameters;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.InvokableDeclaration#name() name} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for name
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokableDeclaration withName(Trees.Identifier value) {
&nbsp;      if (this.name == value) return this;
&nbsp;      Trees.Identifier newValue = Objects.requireNonNull(value, &quot;name&quot;);
&nbsp;      return new ImmutableTrees.InvokableDeclaration(newValue, this.parameters);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokableDeclaration#parameters() parameters}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokableDeclaration withParameters(Trees.Parameter... elements) {
&nbsp;      ImmutableList&lt;Trees.Parameter&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokableDeclaration(this.name, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokableDeclaration#parameters() parameters}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parameters elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokableDeclaration withParameters(Iterable&lt;? extends Trees.Parameter&gt; elements) {
&nbsp;      if (this.parameters == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Parameter&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokableDeclaration(this.name, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code InvokableDeclaration} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.InvokableDeclaration
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.InvokableDeclaration) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.InvokableDeclaration another) {
&nbsp;      return name.equals(another.name)
&nbsp;          &amp;&amp; parameters.equals(another.parameters);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}, {@code parameters}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + parameters.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code InvokableDeclaration} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;InvokableDeclaration&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .add(&quot;parameters&quot;, parameters)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.InvokableDeclaration} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable InvokableDeclaration instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokableDeclaration copyOf(Trees.InvokableDeclaration instance) {
&nbsp;      if (instance instanceof ImmutableTrees.InvokableDeclaration) {
&nbsp;        return (ImmutableTrees.InvokableDeclaration) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.InvokableDeclaration.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.InvokableDeclaration InvokableDeclaration}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.InvokableDeclaration.builder()
&nbsp;     *    .name(org.immutables.generator.processor.Trees.Identifier) // required {@link Trees.InvokableDeclaration#name() name}
&nbsp;     *    .addParameters|addAllParameters(org.immutables.generator.processor.Trees.Parameter) // {@link Trees.InvokableDeclaration#parameters() parameters} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new InvokableDeclaration builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokableDeclaration.Builder builder() {
&nbsp;      return new ImmutableTrees.InvokableDeclaration.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.InvokableDeclaration InvokableDeclaration}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.InvokableDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_NAME = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.Identifier name;
&nbsp;      private ImmutableList.Builder&lt;Trees.Parameter&gt; parameters = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokableDeclaration} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokableDeclaration instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Named} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Named instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.InvokableDeclaration) {
&nbsp;          Trees.InvokableDeclaration instance = (Trees.InvokableDeclaration) object;
&nbsp;          addAllParameters(instance.parameters());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Named) {
&nbsp;          Trees.Named instance = (Trees.Named) object;
&nbsp;          name(instance.name());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.InvokableDeclaration#name() name} attribute.
&nbsp;       * @param name The value for name 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder name(Trees.Identifier name) {
&nbsp;        this.name = Objects.requireNonNull(name, &quot;name&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_NAME;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.InvokableDeclaration#parameters() parameters} list.
&nbsp;       * @param element A parameters element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParameters(Trees.Parameter element) {
&nbsp;        this.parameters.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokableDeclaration#parameters() parameters} list.
&nbsp;       * @param elements An array of parameters elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParameters(Trees.Parameter... elements) {
&nbsp;        this.parameters.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.InvokableDeclaration#parameters() parameters} list.
&nbsp;       * @param elements An iterable of parameters elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parameters(Iterable&lt;? extends Trees.Parameter&gt; elements) {
&nbsp;        this.parameters = ImmutableList.builder();
&nbsp;        return addAllParameters(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokableDeclaration#parameters() parameters} list.
&nbsp;       * @param elements An iterable of parameters elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParameters(Iterable&lt;? extends Trees.Parameter&gt; elements) {
&nbsp;        this.parameters.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.InvokableDeclaration InvokableDeclaration}.
&nbsp;       * @return An immutable instance of InvokableDeclaration
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.InvokableDeclaration build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.InvokableDeclaration(name, parameters.build());
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_NAME) != 0) attributes.add(&quot;name&quot;);
&nbsp;        return &quot;Cannot build InvokableDeclaration, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ValueDeclaration}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ValueDeclaration.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ValueDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ValueDeclaration implements Trees.ValueDeclaration {
&nbsp;    private final Trees.Identifier name;
&nbsp;    private final Optional&lt;Trees.TypeReference&gt; type;
&nbsp;    private final Optional&lt;Trees.TypeReference&gt; containedType;
&nbsp;
&nbsp;    private ValueDeclaration(
&nbsp;        Trees.Identifier name,
&nbsp;        Optional&lt;Trees.TypeReference&gt; type,
&nbsp;        Optional&lt;Trees.TypeReference&gt; containedType) {
&nbsp;      this.name = name;
&nbsp;      this.type = type;
&nbsp;      this.containedType = containedType;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code name} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Identifier name() {
&nbsp;      return name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code type} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.TypeReference&gt; type() {
&nbsp;      return type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code containedType} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.TypeReference&gt; containedType() {
&nbsp;      return containedType;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ValueDeclaration#name() name} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for name
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ValueDeclaration withName(Trees.Identifier value) {
&nbsp;      if (this.name == value) return this;
&nbsp;      Trees.Identifier newValue = Objects.requireNonNull(value, &quot;name&quot;);
&nbsp;      return new ImmutableTrees.ValueDeclaration(newValue, this.type, this.containedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.ValueDeclaration#type() type} attribute.
&nbsp;     * @param value The value for type
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ValueDeclaration withType(Trees.TypeReference value) {
&nbsp;      Optional&lt;Trees.TypeReference&gt; newValue = Optional.of(value);
&nbsp;      if (this.type.isPresent() &amp;&amp; this.type.get() == value) return this;
&nbsp;      return new ImmutableTrees.ValueDeclaration(this.name, newValue, this.containedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.ValueDeclaration#type() type} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for type
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.ValueDeclaration withType(Optional&lt;? extends Trees.TypeReference&gt; optional) {
&nbsp;      Optional&lt;Trees.TypeReference&gt; value = (Optional&lt;Trees.TypeReference&gt;) optional;
&nbsp;      if (!this.type.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.type.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.type.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.ValueDeclaration(this.name, value, this.containedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.ValueDeclaration#containedType() containedType} attribute.
&nbsp;     * @param value The value for containedType
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ValueDeclaration withContainedType(Trees.TypeReference value) {
&nbsp;      Optional&lt;Trees.TypeReference&gt; newValue = Optional.of(value);
&nbsp;      if (this.containedType.isPresent() &amp;&amp; this.containedType.get() == value) return this;
&nbsp;      return new ImmutableTrees.ValueDeclaration(this.name, this.type, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.ValueDeclaration#containedType() containedType} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for containedType
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.ValueDeclaration withContainedType(Optional&lt;? extends Trees.TypeReference&gt; optional) {
&nbsp;      Optional&lt;Trees.TypeReference&gt; value = (Optional&lt;Trees.TypeReference&gt;) optional;
&nbsp;      if (!this.containedType.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.containedType.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.containedType.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.ValueDeclaration(this.name, this.type, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ValueDeclaration} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ValueDeclaration
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ValueDeclaration) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ValueDeclaration another) {
&nbsp;      return name.equals(another.name)
&nbsp;          &amp;&amp; type.equals(another.type)
&nbsp;          &amp;&amp; containedType.equals(another.containedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}, {@code type}, {@code containedType}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + type.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + containedType.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ValueDeclaration} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ValueDeclaration&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .add(&quot;type&quot;, type.orNull())
&nbsp;          .add(&quot;containedType&quot;, containedType.orNull())
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ValueDeclaration} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ValueDeclaration instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ValueDeclaration copyOf(Trees.ValueDeclaration instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ValueDeclaration) {
&nbsp;        return (ImmutableTrees.ValueDeclaration) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ValueDeclaration.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ValueDeclaration ValueDeclaration}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ValueDeclaration.builder()
&nbsp;     *    .name(org.immutables.generator.processor.Trees.Identifier) // required {@link Trees.ValueDeclaration#name() name}
&nbsp;     *    .type(org.immutables.generator.processor.Trees.TypeReference) // optional {@link Trees.ValueDeclaration#type() type}
&nbsp;     *    .containedType(org.immutables.generator.processor.Trees.TypeReference) // optional {@link Trees.ValueDeclaration#containedType() containedType}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ValueDeclaration builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ValueDeclaration.Builder builder() {
&nbsp;      return new ImmutableTrees.ValueDeclaration.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ValueDeclaration ValueDeclaration}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ValueDeclaration&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_NAME = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.Identifier name;
&nbsp;      private Optional&lt;Trees.TypeReference&gt; type = Optional.absent();
&nbsp;      private Optional&lt;Trees.TypeReference&gt; containedType = Optional.absent();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.ValueDeclaration} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ValueDeclaration instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Named} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Named instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.ValueDeclaration) {
&nbsp;          Trees.ValueDeclaration instance = (Trees.ValueDeclaration) object;
&nbsp;          Optional&lt;Trees.TypeReference&gt; typeOptional = instance.type();
&nbsp;          if (typeOptional.isPresent()) {
&nbsp;            type(typeOptional);
&nbsp;          }
&nbsp;          Optional&lt;Trees.TypeReference&gt; containedTypeOptional = instance.containedType();
&nbsp;          if (containedTypeOptional.isPresent()) {
&nbsp;            containedType(containedTypeOptional);
&nbsp;          }
&nbsp;        }
&nbsp;        if (object instanceof Trees.Named) {
&nbsp;          Trees.Named instance = (Trees.Named) object;
&nbsp;          name(instance.name());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ValueDeclaration#name() name} attribute.
&nbsp;       * @param name The value for name 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder name(Trees.Identifier name) {
&nbsp;        this.name = Objects.requireNonNull(name, &quot;name&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_NAME;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.ValueDeclaration#type() type} to type.
&nbsp;       * @param type The value for type
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder type(Trees.TypeReference type) {
&nbsp;        this.type = Optional.of(type);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.ValueDeclaration#type() type} to type.
&nbsp;       * @param type The value for type
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder type(Optional&lt;? extends Trees.TypeReference&gt; type) {
&nbsp;        this.type = (Optional&lt;Trees.TypeReference&gt;) type;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.ValueDeclaration#containedType() containedType} to containedType.
&nbsp;       * @param containedType The value for containedType
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder containedType(Trees.TypeReference containedType) {
&nbsp;        this.containedType = Optional.of(containedType);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.ValueDeclaration#containedType() containedType} to containedType.
&nbsp;       * @param containedType The value for containedType
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder containedType(Optional&lt;? extends Trees.TypeReference&gt; containedType) {
&nbsp;        this.containedType = (Optional&lt;Trees.TypeReference&gt;) containedType;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ValueDeclaration ValueDeclaration}.
&nbsp;       * @return An immutable instance of ValueDeclaration
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ValueDeclaration build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.ValueDeclaration(name, type, containedType);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_NAME) != 0) attributes.add(&quot;name&quot;);
&nbsp;        return &quot;Cannot build ValueDeclaration, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Parameter}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Parameter.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Parameter&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Parameter implements Trees.Parameter {
&nbsp;    private final Trees.Identifier name;
&nbsp;    private final Trees.TypeReference type;
&nbsp;
&nbsp;    private Parameter(
&nbsp;        Trees.Identifier name,
&nbsp;        Trees.TypeReference type) {
&nbsp;      this.name = name;
&nbsp;      this.type = type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code name} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Identifier name() {
&nbsp;      return name;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code type} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.TypeReference type() {
&nbsp;      return type;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Parameter#name() name} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for name
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Parameter withName(Trees.Identifier value) {
&nbsp;      if (this.name == value) return this;
&nbsp;      Trees.Identifier newValue = Objects.requireNonNull(value, &quot;name&quot;);
&nbsp;      return new ImmutableTrees.Parameter(newValue, this.type);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Parameter#type() type} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for type
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Parameter withType(Trees.TypeReference value) {
&nbsp;      if (this.type == value) return this;
&nbsp;      Trees.TypeReference newValue = Objects.requireNonNull(value, &quot;type&quot;);
&nbsp;      return new ImmutableTrees.Parameter(this.name, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Parameter} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Parameter
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Parameter) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Parameter another) {
&nbsp;      return name.equals(another.name)
&nbsp;          &amp;&amp; type.equals(another.type);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code name}, {@code type}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + name.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + type.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Parameter} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Parameter&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;name&quot;, name)
&nbsp;          .add(&quot;type&quot;, type)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Parameter} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Parameter instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Parameter copyOf(Trees.Parameter instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Parameter) {
&nbsp;        return (ImmutableTrees.Parameter) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Parameter.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.Parameter Parameter}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.Parameter.builder()
&nbsp;     *    .name(org.immutables.generator.processor.Trees.Identifier) // required {@link Trees.Parameter#name() name}
&nbsp;     *    .type(org.immutables.generator.processor.Trees.TypeReference) // required {@link Trees.Parameter#type() type}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Parameter builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.Parameter.Builder builder() {
&nbsp;      return new ImmutableTrees.Parameter.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.Parameter Parameter}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.Parameter&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_NAME = 0x1L;
&nbsp;      private static final long INIT_BIT_TYPE = 0x2L;
&nbsp;      private long initBits = 0x3L;
&nbsp;
&nbsp;      private @Nullable Trees.Identifier name;
&nbsp;      private @Nullable Trees.TypeReference type;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Typed} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Typed instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Named} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Named instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Parameter} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Parameter instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Typed) {
&nbsp;          Trees.Typed instance = (Trees.Typed) object;
&nbsp;          type(instance.type());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Named) {
&nbsp;          Trees.Named instance = (Trees.Named) object;
&nbsp;          name(instance.name());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Parameter#name() name} attribute.
&nbsp;       * @param name The value for name 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder name(Trees.Identifier name) {
&nbsp;        this.name = Objects.requireNonNull(name, &quot;name&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_NAME;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Parameter#type() type} attribute.
&nbsp;       * @param type The value for type 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder type(Trees.TypeReference type) {
&nbsp;        this.type = Objects.requireNonNull(type, &quot;type&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_TYPE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.Parameter Parameter}.
&nbsp;       * @return An immutable instance of Parameter
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.Parameter build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.Parameter(name, type);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_NAME) != 0) attributes.add(&quot;name&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_TYPE) != 0) attributes.add(&quot;type&quot;);
&nbsp;        return &quot;Cannot build Parameter, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.SimpleBlock}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.SimpleBlock.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.SimpleBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class SimpleBlock implements Trees.SimpleBlock {
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;
&nbsp;    private SimpleBlock(
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts) {
&nbsp;      this.parts = parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.SimpleBlock#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.SimpleBlock withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.SimpleBlock(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.SimpleBlock#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.SimpleBlock withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.SimpleBlock(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code SimpleBlock} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.SimpleBlock
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.SimpleBlock) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.SimpleBlock another) {
&nbsp;      return parts.equals(another.parts);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code SimpleBlock} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;SimpleBlock&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.SimpleBlock} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable SimpleBlock instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.SimpleBlock copyOf(Trees.SimpleBlock instance) {
&nbsp;      if (instance instanceof ImmutableTrees.SimpleBlock) {
&nbsp;        return (ImmutableTrees.SimpleBlock) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.SimpleBlock.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.SimpleBlock SimpleBlock}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.SimpleBlock.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.SimpleBlock#parts() parts} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new SimpleBlock builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.SimpleBlock.Builder builder() {
&nbsp;      return new ImmutableTrees.SimpleBlock.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.SimpleBlock SimpleBlock}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.SimpleBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.SimpleBlock} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.SimpleBlock instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.SimpleBlock#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.SimpleBlock#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.SimpleBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.SimpleBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.SimpleBlock SimpleBlock}.
&nbsp;       * @return An immutable instance of SimpleBlock
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.SimpleBlock build() {
&nbsp;        return new ImmutableTrees.SimpleBlock(parts.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Comment}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.Comment.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Comment&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Comment implements Trees.Comment {
&nbsp;
&nbsp;    private Comment() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Comment} that have equal attribute values.
&nbsp;     * As instances of the {@code Comment} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 1487449787;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Comment}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;Comment{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.Comment INSTANCE = new ImmutableTrees.Comment();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code Comment}
&nbsp;     * @return An immutable instance of Comment
&nbsp;     */
&nbsp;    public static ImmutableTrees.Comment of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ConditionalBlock}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ConditionalBlock.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ConditionalBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ConditionalBlock implements Trees.ConditionalBlock {
&nbsp;    private final Trees.Expression condition;
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;
&nbsp;    private ConditionalBlock(
&nbsp;        Trees.Expression condition,
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts) {
&nbsp;      this.condition = condition;
&nbsp;      this.parts = parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code condition} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression condition() {
&nbsp;      return condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ConditionalBlock#condition() condition} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for condition
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ConditionalBlock withCondition(Trees.Expression value) {
&nbsp;      if (this.condition == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;condition&quot;);
&nbsp;      return new ImmutableTrees.ConditionalBlock(newValue, this.parts);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ConditionalBlock#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ConditionalBlock withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ConditionalBlock(this.condition, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ConditionalBlock#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ConditionalBlock withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ConditionalBlock(this.condition, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ConditionalBlock} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ConditionalBlock
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ConditionalBlock) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ConditionalBlock another) {
&nbsp;      return condition.equals(another.condition)
&nbsp;          &amp;&amp; parts.equals(another.parts);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code condition}, {@code parts}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + condition.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ConditionalBlock} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ConditionalBlock&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;condition&quot;, condition)
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ConditionalBlock} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ConditionalBlock instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ConditionalBlock copyOf(Trees.ConditionalBlock instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ConditionalBlock) {
&nbsp;        return (ImmutableTrees.ConditionalBlock) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ConditionalBlock.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ConditionalBlock ConditionalBlock}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ConditionalBlock.builder()
&nbsp;     *    .condition(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.ConditionalBlock#condition() condition}
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.ConditionalBlock#parts() parts} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ConditionalBlock builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ConditionalBlock.Builder builder() {
&nbsp;      return new ImmutableTrees.ConditionalBlock.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ConditionalBlock ConditionalBlock}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ConditionalBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_CONDITION = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.Expression condition;
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Conditional} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Conditional instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.ConditionalBlock} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ConditionalBlock instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Conditional) {
&nbsp;          Trees.Conditional instance = (Trees.Conditional) object;
&nbsp;          condition(instance.condition());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ConditionalBlock#condition() condition} attribute.
&nbsp;       * @param condition The value for condition 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Trees.Expression condition) {
&nbsp;        this.condition = Objects.requireNonNull(condition, &quot;condition&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_CONDITION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.ConditionalBlock#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ConditionalBlock#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.ConditionalBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ConditionalBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ConditionalBlock ConditionalBlock}.
&nbsp;       * @return An immutable instance of ConditionalBlock
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ConditionalBlock build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.ConditionalBlock(condition, parts.build());
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_CONDITION) != 0) attributes.add(&quot;condition&quot;);
&nbsp;        return &quot;Cannot build ConditionalBlock, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.IfStatement}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.IfStatement.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.IfStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class IfStatement implements Trees.IfStatement {
&nbsp;    private final Trees.ConditionalBlock then;
&nbsp;    private final ImmutableList&lt;Trees.ConditionalBlock&gt; otherwiseIf;
&nbsp;    private final Optional&lt;Trees.Block&gt; otherwise;
&nbsp;
&nbsp;    private IfStatement(
&nbsp;        Trees.ConditionalBlock then,
&nbsp;        ImmutableList&lt;Trees.ConditionalBlock&gt; otherwiseIf,
&nbsp;        Optional&lt;Trees.Block&gt; otherwise) {
&nbsp;      this.then = then;
&nbsp;      this.otherwiseIf = otherwiseIf;
&nbsp;      this.otherwise = otherwise;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code then} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.ConditionalBlock then() {
&nbsp;      return then;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code otherwiseIf} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.ConditionalBlock&gt; otherwiseIf() {
&nbsp;      return otherwiseIf;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code otherwise} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.Block&gt; otherwise() {
&nbsp;      return otherwise;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.IfStatement#then() then} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for then
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IfStatement withThen(Trees.ConditionalBlock value) {
&nbsp;      if (this.then == value) return this;
&nbsp;      Trees.ConditionalBlock newValue = Objects.requireNonNull(value, &quot;then&quot;);
&nbsp;      return new ImmutableTrees.IfStatement(newValue, this.otherwiseIf, this.otherwise);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.IfStatement#otherwiseIf() otherwiseIf}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IfStatement withOtherwiseIf(Trees.ConditionalBlock... elements) {
&nbsp;      ImmutableList&lt;Trees.ConditionalBlock&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.IfStatement(this.then, newValue, this.otherwise);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.IfStatement#otherwiseIf() otherwiseIf}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of otherwiseIf elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IfStatement withOtherwiseIf(Iterable&lt;? extends Trees.ConditionalBlock&gt; elements) {
&nbsp;      if (this.otherwiseIf == elements) return this;
&nbsp;      ImmutableList&lt;Trees.ConditionalBlock&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.IfStatement(this.then, newValue, this.otherwise);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.IfStatement#otherwise() otherwise} attribute.
&nbsp;     * @param value The value for otherwise
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IfStatement withOtherwise(Trees.Block value) {
&nbsp;      Optional&lt;Trees.Block&gt; newValue = Optional.of(value);
&nbsp;      if (this.otherwise.isPresent() &amp;&amp; this.otherwise.get() == value) return this;
&nbsp;      return new ImmutableTrees.IfStatement(this.then, this.otherwiseIf, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.IfStatement#otherwise() otherwise} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for otherwise
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.IfStatement withOtherwise(Optional&lt;? extends Trees.Block&gt; optional) {
&nbsp;      Optional&lt;Trees.Block&gt; value = (Optional&lt;Trees.Block&gt;) optional;
&nbsp;      if (!this.otherwise.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.otherwise.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.otherwise.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.IfStatement(this.then, this.otherwiseIf, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code IfStatement} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.IfStatement
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.IfStatement) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.IfStatement another) {
&nbsp;      return then.equals(another.then)
&nbsp;          &amp;&amp; otherwiseIf.equals(another.otherwiseIf)
&nbsp;          &amp;&amp; otherwise.equals(another.otherwise);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code then}, {@code otherwiseIf}, {@code otherwise}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + then.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + otherwiseIf.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + otherwise.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code IfStatement} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;IfStatement&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;then&quot;, then)
&nbsp;          .add(&quot;otherwiseIf&quot;, otherwiseIf)
&nbsp;          .add(&quot;otherwise&quot;, otherwise.orNull())
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.IfStatement} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable IfStatement instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.IfStatement copyOf(Trees.IfStatement instance) {
&nbsp;      if (instance instanceof ImmutableTrees.IfStatement) {
&nbsp;        return (ImmutableTrees.IfStatement) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.IfStatement.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.IfStatement IfStatement}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.IfStatement.builder()
&nbsp;     *    .then(org.immutables.generator.processor.Trees.ConditionalBlock) // required {@link Trees.IfStatement#then() then}
&nbsp;     *    .addOtherwiseIf|addAllOtherwiseIf(org.immutables.generator.processor.Trees.ConditionalBlock) // {@link Trees.IfStatement#otherwiseIf() otherwiseIf} elements
&nbsp;     *    .otherwise(org.immutables.generator.processor.Trees.Block) // optional {@link Trees.IfStatement#otherwise() otherwise}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new IfStatement builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.IfStatement.Builder builder() {
&nbsp;      return new ImmutableTrees.IfStatement.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.IfStatement IfStatement}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.IfStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_THEN = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.ConditionalBlock then;
&nbsp;      private ImmutableList.Builder&lt;Trees.ConditionalBlock&gt; otherwiseIf = ImmutableList.builder();
&nbsp;      private Optional&lt;Trees.Block&gt; otherwise = Optional.absent();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code IfStatement} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * Collection elements and entries will be added, not replaced.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.IfStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        then(instance.then());
&nbsp;        addAllOtherwiseIf(instance.otherwiseIf());
&nbsp;        Optional&lt;Trees.Block&gt; otherwiseOptional = instance.otherwise();
&nbsp;        if (otherwiseOptional.isPresent()) {
&nbsp;          otherwise(otherwiseOptional);
&nbsp;        }
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.IfStatement#then() then} attribute.
&nbsp;       * @param then The value for then 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder then(Trees.ConditionalBlock then) {
&nbsp;        this.then = Objects.requireNonNull(then, &quot;then&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_THEN;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.IfStatement#otherwiseIf() otherwiseIf} list.
&nbsp;       * @param element A otherwiseIf element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addOtherwiseIf(Trees.ConditionalBlock element) {
&nbsp;        this.otherwiseIf.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.IfStatement#otherwiseIf() otherwiseIf} list.
&nbsp;       * @param elements An array of otherwiseIf elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addOtherwiseIf(Trees.ConditionalBlock... elements) {
&nbsp;        this.otherwiseIf.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.IfStatement#otherwiseIf() otherwiseIf} list.
&nbsp;       * @param elements An iterable of otherwiseIf elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder otherwiseIf(Iterable&lt;? extends Trees.ConditionalBlock&gt; elements) {
&nbsp;        this.otherwiseIf = ImmutableList.builder();
&nbsp;        return addAllOtherwiseIf(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.IfStatement#otherwiseIf() otherwiseIf} list.
&nbsp;       * @param elements An iterable of otherwiseIf elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllOtherwiseIf(Iterable&lt;? extends Trees.ConditionalBlock&gt; elements) {
&nbsp;        this.otherwiseIf.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.IfStatement#otherwise() otherwise} to otherwise.
&nbsp;       * @param otherwise The value for otherwise
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder otherwise(Trees.Block otherwise) {
&nbsp;        this.otherwise = Optional.of(otherwise);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.IfStatement#otherwise() otherwise} to otherwise.
&nbsp;       * @param otherwise The value for otherwise
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder otherwise(Optional&lt;? extends Trees.Block&gt; otherwise) {
&nbsp;        this.otherwise = (Optional&lt;Trees.Block&gt;) otherwise;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.IfStatement IfStatement}.
&nbsp;       * @return An immutable instance of IfStatement
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.IfStatement build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.IfStatement(then, otherwiseIf.build(), otherwise);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_THEN) != 0) attributes.add(&quot;then&quot;);
&nbsp;        return &quot;Cannot build IfStatement, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ForStatement}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ForStatement.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ForStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ForStatement extends Trees.ForStatement {
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;    private final boolean useForAccess;
&nbsp;    private final boolean useDelimit;
&nbsp;    private final ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration;
&nbsp;
&nbsp;    private ForStatement(ImmutableTrees.ForStatement.Builder builder) {
&nbsp;      this.parts = builder.parts.build();
&nbsp;      this.declaration = builder.declaration.build();
&nbsp;      if (builder.useForAccessIsSet()) {
&nbsp;        initShim.useForAccess(builder.useForAccess);
&nbsp;      }
&nbsp;      if (builder.useDelimitIsSet()) {
&nbsp;        initShim.useDelimit(builder.useDelimit);
&nbsp;      }
&nbsp;      this.useForAccess = initShim.useForAccess();
&nbsp;      this.useDelimit = initShim.useDelimit();
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private ForStatement(
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts,
&nbsp;        boolean useForAccess,
&nbsp;        boolean useDelimit,
&nbsp;        ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration) {
&nbsp;      this.parts = parts;
&nbsp;      this.useForAccess = useForAccess;
&nbsp;      this.useDelimit = useDelimit;
&nbsp;      this.declaration = declaration;
&nbsp;      this.initShim = null;
&nbsp;    }
&nbsp;
&nbsp;    private static final byte STAGE_INITIALIZING = -1;
&nbsp;    private static final byte STAGE_UNINITIALIZED = 0;
&nbsp;    private static final byte STAGE_INITIALIZED = 1;
&nbsp;    @SuppressWarnings(&quot;Immutable&quot;)
&nbsp;    private transient volatile InitShim initShim = new InitShim();
&nbsp;
&nbsp;    @Generated(from = &quot;Trees.ForStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;    private final class InitShim {
&nbsp;      private byte useForAccessBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean useForAccess;
&nbsp;
&nbsp;      boolean useForAccess() {
&nbsp;        if (useForAccessBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (useForAccessBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          useForAccessBuildStage = STAGE_INITIALIZING;
&nbsp;          this.useForAccess = ForStatement.super.useForAccess();
&nbsp;          useForAccessBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.useForAccess;
&nbsp;      }
&nbsp;
&nbsp;      void useForAccess(boolean useForAccess) {
&nbsp;        this.useForAccess = useForAccess;
&nbsp;        useForAccessBuildStage = STAGE_INITIALIZED;
&nbsp;      }
&nbsp;
&nbsp;      private byte useDelimitBuildStage = STAGE_UNINITIALIZED;
&nbsp;      private boolean useDelimit;
&nbsp;
&nbsp;      boolean useDelimit() {
&nbsp;        if (useDelimitBuildStage == STAGE_INITIALIZING) throw new IllegalStateException(formatInitCycleMessage());
&nbsp;        if (useDelimitBuildStage == STAGE_UNINITIALIZED) {
&nbsp;          useDelimitBuildStage = STAGE_INITIALIZING;
&nbsp;          this.useDelimit = ForStatement.super.useDelimit();
&nbsp;          useDelimitBuildStage = STAGE_INITIALIZED;
&nbsp;        }
&nbsp;        return this.useDelimit;
&nbsp;      }
&nbsp;
&nbsp;      void useDelimit(boolean useDelimit) {
&nbsp;        this.useDelimit = useDelimit;
&nbsp;        useDelimitBuildStage = STAGE_INITIALIZED;
&nbsp;      }
&nbsp;
&nbsp;      private String formatInitCycleMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if (useForAccessBuildStage == STAGE_INITIALIZING) attributes.add(&quot;useForAccess&quot;);
&nbsp;        if (useDelimitBuildStage == STAGE_INITIALIZING) attributes.add(&quot;useDelimit&quot;);
&nbsp;        return &quot;Cannot build ForStatement, attribute initializers form cycle &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code useForAccess} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean useForAccess() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.useForAccess()
&nbsp;          : this.useForAccess;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code useDelimit} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean useDelimit() {
&nbsp;      InitShim shim = this.initShim;
&nbsp;      return shim != null
&nbsp;          ? shim.useDelimit()
&nbsp;          : this.useDelimit;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForStatement#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForStatement(newValue, this.useForAccess, this.useDelimit, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForStatement#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForStatement(newValue, this.useForAccess, this.useDelimit, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ForStatement#useForAccess() useForAccess} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for useForAccess
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withUseForAccess(boolean value) {
&nbsp;      if (this.useForAccess == value) return this;
&nbsp;      return new ImmutableTrees.ForStatement(this.parts, value, this.useDelimit, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ForStatement#useDelimit() useDelimit} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for useDelimit
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withUseDelimit(boolean value) {
&nbsp;      if (this.useDelimit == value) return this;
&nbsp;      return new ImmutableTrees.ForStatement(this.parts, this.useForAccess, value, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForStatement#declaration() declaration}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withDeclaration(Trees.GeneratorDeclaration... elements) {
&nbsp;      ImmutableList&lt;Trees.GeneratorDeclaration&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForStatement(this.parts, this.useForAccess, this.useDelimit, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForStatement#declaration() declaration}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of declaration elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForStatement withDeclaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;      if (this.declaration == elements) return this;
&nbsp;      ImmutableList&lt;Trees.GeneratorDeclaration&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForStatement(this.parts, this.useForAccess, this.useDelimit, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ForStatement} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ForStatement
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ForStatement) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ForStatement another) {
&nbsp;      return parts.equals(another.parts)
&nbsp;          &amp;&amp; useForAccess == another.useForAccess
&nbsp;          &amp;&amp; useDelimit == another.useDelimit
&nbsp;          &amp;&amp; declaration.equals(another.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}, {@code useForAccess}, {@code useDelimit}, {@code declaration}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + Booleans.hashCode(useForAccess);
&nbsp;      h += (h &lt;&lt; 5) + Booleans.hashCode(useDelimit);
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ForStatement} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ForStatement&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .add(&quot;useForAccess&quot;, useForAccess)
&nbsp;          .add(&quot;useDelimit&quot;, useDelimit)
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ForStatement} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ForStatement instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ForStatement copyOf(Trees.ForStatement instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ForStatement) {
&nbsp;        return (ImmutableTrees.ForStatement) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ForStatement.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ForStatement ForStatement}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ForStatement.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.ForStatement#parts() parts} elements
&nbsp;     *    .useForAccess(boolean) // optional {@link Trees.ForStatement#useForAccess() useForAccess}
&nbsp;     *    .useDelimit(boolean) // optional {@link Trees.ForStatement#useDelimit() useDelimit}
&nbsp;     *    .addDeclaration|addAllDeclaration(org.immutables.generator.processor.Trees.GeneratorDeclaration) // {@link Trees.ForStatement#declaration() declaration} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ForStatement builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ForStatement.Builder builder() {
&nbsp;      return new ImmutableTrees.ForStatement.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ForStatement ForStatement}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ForStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long OPT_BIT_USE_FOR_ACCESS = 0x1L;
&nbsp;      private static final long OPT_BIT_USE_DELIMIT = 0x2L;
&nbsp;      private long optBits;
&nbsp;
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;      private boolean useForAccess;
&nbsp;      private boolean useDelimit;
&nbsp;      private ImmutableList.Builder&lt;Trees.GeneratorDeclaration&gt; declaration = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.ForStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ForStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.ForStatement) {
&nbsp;          Trees.ForStatement instance = (Trees.ForStatement) object;
&nbsp;          useForAccess(instance.useForAccess());
&nbsp;          addAllDeclaration(instance.declaration());
&nbsp;          useDelimit(instance.useDelimit());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.ForStatement#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ForStatement#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.ForStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ForStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ForStatement#useForAccess() useForAccess} attribute.
&nbsp;       * &lt;p&gt;&lt;em&gt;If not set, this attribute will have a default value as returned by the initializer of {@link Trees.ForStatement#useForAccess() useForAccess}.&lt;/em&gt;
&nbsp;       * @param useForAccess The value for useForAccess 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder useForAccess(boolean useForAccess) {
&nbsp;        this.useForAccess = useForAccess;
&nbsp;        optBits |= OPT_BIT_USE_FOR_ACCESS;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ForStatement#useDelimit() useDelimit} attribute.
&nbsp;       * &lt;p&gt;&lt;em&gt;If not set, this attribute will have a default value as returned by the initializer of {@link Trees.ForStatement#useDelimit() useDelimit}.&lt;/em&gt;
&nbsp;       * @param useDelimit The value for useDelimit 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder useDelimit(boolean useDelimit) {
&nbsp;        this.useDelimit = useDelimit;
&nbsp;        optBits |= OPT_BIT_USE_DELIMIT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.ForStatement#declaration() declaration} list.
&nbsp;       * @param element A declaration element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addDeclaration(Trees.GeneratorDeclaration element) {
&nbsp;        this.declaration.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ForStatement#declaration() declaration} list.
&nbsp;       * @param elements An array of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addDeclaration(Trees.GeneratorDeclaration... elements) {
&nbsp;        this.declaration.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.ForStatement#declaration() declaration} list.
&nbsp;       * @param elements An iterable of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;        this.declaration = ImmutableList.builder();
&nbsp;        return addAllDeclaration(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ForStatement#declaration() declaration} list.
&nbsp;       * @param elements An iterable of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllDeclaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;        this.declaration.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ForStatement ForStatement}.
&nbsp;       * @return An immutable instance of ForStatement
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ForStatement build() {
&nbsp;        return new ImmutableTrees.ForStatement(this);
&nbsp;      }
&nbsp;
&nbsp;      private boolean useForAccessIsSet() {
&nbsp;        return (optBits &amp; OPT_BIT_USE_FOR_ACCESS) != 0;
&nbsp;      }
&nbsp;
&nbsp;      private boolean useDelimitIsSet() {
&nbsp;        return (optBits &amp; OPT_BIT_USE_DELIMIT) != 0;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ForIterationAccessExpression}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ForIterationAccessExpression.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ForIterationAccessExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ForIterationAccessExpression
&nbsp;      implements Trees.ForIterationAccessExpression {
&nbsp;    private final ImmutableList&lt;Trees.Identifier&gt; path;
&nbsp;    private final Trees.AccessExpression access;
&nbsp;
&nbsp;    private ForIterationAccessExpression(Trees.AccessExpression access) {
&nbsp;      this.access = Objects.requireNonNull(access, &quot;access&quot;);
&nbsp;      this.path = ImmutableList.of();
&nbsp;    }
&nbsp;
&nbsp;    private ForIterationAccessExpression(
&nbsp;        ImmutableList&lt;Trees.Identifier&gt; path,
&nbsp;        Trees.AccessExpression access) {
&nbsp;      this.path = path;
&nbsp;      this.access = access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code path} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Identifier&gt; path() {
&nbsp;      return path;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code access} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.AccessExpression access() {
&nbsp;      return access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForIterationAccessExpression#path() path}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForIterationAccessExpression withPath(Trees.Identifier... elements) {
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForIterationAccessExpression(newValue, this.access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ForIterationAccessExpression#path() path}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of path elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForIterationAccessExpression withPath(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;      if (this.path == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ForIterationAccessExpression(newValue, this.access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ForIterationAccessExpression#access() access} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for access
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ForIterationAccessExpression withAccess(Trees.AccessExpression value) {
&nbsp;      if (this.access == value) return this;
&nbsp;      Trees.AccessExpression newValue = Objects.requireNonNull(value, &quot;access&quot;);
&nbsp;      return new ImmutableTrees.ForIterationAccessExpression(this.path, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ForIterationAccessExpression} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ForIterationAccessExpression
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ForIterationAccessExpression) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ForIterationAccessExpression another) {
&nbsp;      return path.equals(another.path)
&nbsp;          &amp;&amp; access.equals(another.access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code path}, {@code access}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + path.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + access.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ForIterationAccessExpression} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ForIterationAccessExpression&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;path&quot;, path)
&nbsp;          .add(&quot;access&quot;, access)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code ForIterationAccessExpression} instance.
&nbsp;     * @param access The value for the {@code access} attribute
&nbsp;     * @return An immutable ForIterationAccessExpression instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ForIterationAccessExpression of(Trees.AccessExpression access) {
&nbsp;      return new ImmutableTrees.ForIterationAccessExpression(access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ForIterationAccessExpression} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ForIterationAccessExpression instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ForIterationAccessExpression copyOf(Trees.ForIterationAccessExpression instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ForIterationAccessExpression) {
&nbsp;        return (ImmutableTrees.ForIterationAccessExpression) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ForIterationAccessExpression.of(instance.access())
&nbsp;          .withPath(instance.path());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.LetStatement}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.LetStatement.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.LetStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class LetStatement implements Trees.LetStatement {
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;    private final Trees.InvokableDeclaration declaration;
&nbsp;
&nbsp;    private LetStatement(
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts,
&nbsp;        Trees.InvokableDeclaration declaration) {
&nbsp;      this.parts = parts;
&nbsp;      this.declaration = declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.InvokableDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.LetStatement#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.LetStatement withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.LetStatement(newValue, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.LetStatement#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.LetStatement withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.LetStatement(newValue, this.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.LetStatement#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.LetStatement withDeclaration(Trees.InvokableDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.InvokableDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.LetStatement(this.parts, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code LetStatement} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.LetStatement
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.LetStatement) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.LetStatement another) {
&nbsp;      return parts.equals(another.parts)
&nbsp;          &amp;&amp; declaration.equals(another.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}, {@code declaration}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code LetStatement} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;LetStatement&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.LetStatement} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable LetStatement instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.LetStatement copyOf(Trees.LetStatement instance) {
&nbsp;      if (instance instanceof ImmutableTrees.LetStatement) {
&nbsp;        return (ImmutableTrees.LetStatement) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.LetStatement.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.LetStatement LetStatement}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.LetStatement.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.LetStatement#parts() parts} elements
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.InvokableDeclaration) // required {@link Trees.LetStatement#declaration() declaration}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new LetStatement builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.LetStatement.Builder builder() {
&nbsp;      return new ImmutableTrees.LetStatement.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.LetStatement LetStatement}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.LetStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;      private @Nullable Trees.InvokableDeclaration declaration;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokableStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokableStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.LetStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.LetStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;        if (object instanceof Trees.InvokableStatement) {
&nbsp;          Trees.InvokableStatement instance = (Trees.InvokableStatement) object;
&nbsp;          declaration(instance.declaration());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.LetStatement#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.LetStatement#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.LetStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.LetStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.LetStatement#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.InvokableDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.LetStatement LetStatement}.
&nbsp;       * @return An immutable instance of LetStatement
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.LetStatement build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.LetStatement(parts.build(), declaration);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        return &quot;Cannot build LetStatement, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.InvokeStatement}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.InvokeStatement.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.InvokeStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class InvokeStatement implements Trees.InvokeStatement {
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;    private final Trees.Expression access;
&nbsp;    private final ImmutableList&lt;Trees.Expression&gt; params;
&nbsp;
&nbsp;    private InvokeStatement(
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts,
&nbsp;        Trees.Expression access,
&nbsp;        ImmutableList&lt;Trees.Expression&gt; params) {
&nbsp;      this.parts = parts;
&nbsp;      this.access = access;
&nbsp;      this.params = params;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code access} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression access() {
&nbsp;      return access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code params} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Expression&gt; params() {
&nbsp;      return params;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokeStatement#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeStatement withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokeStatement(newValue, this.access, this.params);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokeStatement#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeStatement withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokeStatement(newValue, this.access, this.params);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.InvokeStatement#access() access} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for access
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeStatement withAccess(Trees.Expression value) {
&nbsp;      if (this.access == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;access&quot;);
&nbsp;      return new ImmutableTrees.InvokeStatement(this.parts, newValue, this.params);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokeStatement#params() params}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeStatement withParams(Trees.Expression... elements) {
&nbsp;      ImmutableList&lt;Trees.Expression&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokeStatement(this.parts, this.access, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.InvokeStatement#params() params}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of params elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeStatement withParams(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;      if (this.params == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Expression&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.InvokeStatement(this.parts, this.access, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code InvokeStatement} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.InvokeStatement
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.InvokeStatement) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.InvokeStatement another) {
&nbsp;      return parts.equals(another.parts)
&nbsp;          &amp;&amp; access.equals(another.access)
&nbsp;          &amp;&amp; params.equals(another.params);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}, {@code access}, {@code params}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + access.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + params.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code InvokeStatement} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;InvokeStatement&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .add(&quot;access&quot;, access)
&nbsp;          .add(&quot;params&quot;, params)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.InvokeStatement} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable InvokeStatement instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeStatement copyOf(Trees.InvokeStatement instance) {
&nbsp;      if (instance instanceof ImmutableTrees.InvokeStatement) {
&nbsp;        return (ImmutableTrees.InvokeStatement) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.InvokeStatement.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.InvokeStatement InvokeStatement}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.InvokeStatement.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.InvokeStatement#parts() parts} elements
&nbsp;     *    .access(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.InvokeStatement#access() access}
&nbsp;     *    .addParams|addAllParams(org.immutables.generator.processor.Trees.Expression) // {@link Trees.InvokeStatement#params() params} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new InvokeStatement builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeStatement.Builder builder() {
&nbsp;      return new ImmutableTrees.InvokeStatement.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.InvokeStatement InvokeStatement}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.InvokeStatement&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_ACCESS = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;      private @Nullable Trees.Expression access;
&nbsp;      private ImmutableList.Builder&lt;Trees.Expression&gt; params = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokeStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokeStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.InvokeStatement) {
&nbsp;          Trees.InvokeStatement instance = (Trees.InvokeStatement) object;
&nbsp;          addAllParams(instance.params());
&nbsp;          access(instance.access());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.InvokeStatement#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokeStatement#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.InvokeStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokeStatement#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.InvokeStatement#access() access} attribute.
&nbsp;       * @param access The value for access 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder access(Trees.Expression access) {
&nbsp;        this.access = Objects.requireNonNull(access, &quot;access&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ACCESS;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.InvokeStatement#params() params} list.
&nbsp;       * @param element A params element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParams(Trees.Expression element) {
&nbsp;        this.params.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokeStatement#params() params} list.
&nbsp;       * @param elements An array of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParams(Trees.Expression... elements) {
&nbsp;        this.params.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.InvokeStatement#params() params} list.
&nbsp;       * @param elements An iterable of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder params(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;        this.params = ImmutableList.builder();
&nbsp;        return addAllParams(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.InvokeStatement#params() params} list.
&nbsp;       * @param elements An iterable of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParams(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;        this.params.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.InvokeStatement InvokeStatement}.
&nbsp;       * @return An immutable instance of InvokeStatement
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.InvokeStatement build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.InvokeStatement(parts.build(), access, params.build());
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_ACCESS) != 0) attributes.add(&quot;access&quot;);
&nbsp;        return &quot;Cannot build InvokeStatement, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.LetEnd}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.LetEnd.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.LetEnd&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class LetEnd implements Trees.LetEnd {
&nbsp;
&nbsp;    private LetEnd() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code LetEnd} that have equal attribute values.
&nbsp;     * As instances of the {@code LetEnd} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 1959147778;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code LetEnd}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;LetEnd{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.LetEnd INSTANCE = new ImmutableTrees.LetEnd();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code LetEnd}
&nbsp;     * @return An immutable instance of LetEnd
&nbsp;     */
&nbsp;    public static ImmutableTrees.LetEnd of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ForEnd}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.ForEnd.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ForEnd&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ForEnd implements Trees.ForEnd {
&nbsp;
&nbsp;    private ForEnd() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ForEnd} that have equal attribute values.
&nbsp;     * As instances of the {@code ForEnd} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 1796548500;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ForEnd}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;ForEnd{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.ForEnd INSTANCE = new ImmutableTrees.ForEnd();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code ForEnd}
&nbsp;     * @return An immutable instance of ForEnd
&nbsp;     */
&nbsp;    public static ImmutableTrees.ForEnd of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.IfEnd}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.IfEnd.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.IfEnd&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class IfEnd implements Trees.IfEnd {
&nbsp;
&nbsp;    private IfEnd() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code IfEnd} that have equal attribute values.
&nbsp;     * As instances of the {@code IfEnd} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 2000076314;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code IfEnd}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;IfEnd{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.IfEnd INSTANCE = new ImmutableTrees.IfEnd();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code IfEnd}
&nbsp;     * @return An immutable instance of IfEnd
&nbsp;     */
&nbsp;    public static ImmutableTrees.IfEnd of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.InvokeEnd}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.InvokeEnd.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.InvokeEnd&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class InvokeEnd implements Trees.InvokeEnd {
&nbsp;    private final Trees.AccessExpression access;
&nbsp;
&nbsp;    private InvokeEnd(Trees.AccessExpression access) {
&nbsp;      this.access = Objects.requireNonNull(access, &quot;access&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private InvokeEnd(
&nbsp;        ImmutableTrees.InvokeEnd original,
&nbsp;        Trees.AccessExpression access) {
&nbsp;      this.access = access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code access} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.AccessExpression access() {
&nbsp;      return access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.InvokeEnd#access() access} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for access
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeEnd withAccess(Trees.AccessExpression value) {
&nbsp;      if (this.access == value) return this;
&nbsp;      Trees.AccessExpression newValue = Objects.requireNonNull(value, &quot;access&quot;);
&nbsp;      return new ImmutableTrees.InvokeEnd(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code InvokeEnd} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.InvokeEnd
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.InvokeEnd) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.InvokeEnd another) {
&nbsp;      return access.equals(another.access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code access}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + access.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code InvokeEnd} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;InvokeEnd&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;access&quot;, access)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code InvokeEnd} instance.
&nbsp;     * @param access The value for the {@code access} attribute
&nbsp;     * @return An immutable InvokeEnd instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeEnd of(Trees.AccessExpression access) {
&nbsp;      return new ImmutableTrees.InvokeEnd(access);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.InvokeEnd} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable InvokeEnd instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeEnd copyOf(Trees.InvokeEnd instance) {
&nbsp;      if (instance instanceof ImmutableTrees.InvokeEnd) {
&nbsp;        return (ImmutableTrees.InvokeEnd) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.InvokeEnd.of(instance.access());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.InvokeString}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.InvokeString.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.InvokeString&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class InvokeString implements Trees.InvokeString {
&nbsp;    private final Trees.StringLiteral literal;
&nbsp;
&nbsp;    private InvokeString(Trees.StringLiteral literal) {
&nbsp;      this.literal = Objects.requireNonNull(literal, &quot;literal&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private InvokeString(
&nbsp;        ImmutableTrees.InvokeString original,
&nbsp;        Trees.StringLiteral literal) {
&nbsp;      this.literal = literal;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code literal} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.StringLiteral literal() {
&nbsp;      return literal;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.InvokeString#literal() literal} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for literal
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.InvokeString withLiteral(Trees.StringLiteral value) {
&nbsp;      if (this.literal == value) return this;
&nbsp;      Trees.StringLiteral newValue = Objects.requireNonNull(value, &quot;literal&quot;);
&nbsp;      return new ImmutableTrees.InvokeString(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code InvokeString} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.InvokeString
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.InvokeString) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.InvokeString another) {
&nbsp;      return literal.equals(another.literal);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code literal}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + literal.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code InvokeString} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;InvokeString&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;literal&quot;, literal)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code InvokeString} instance.
&nbsp;     * @param literal The value for the {@code literal} attribute
&nbsp;     * @return An immutable InvokeString instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeString of(Trees.StringLiteral literal) {
&nbsp;      return new ImmutableTrees.InvokeString(literal);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.InvokeString} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable InvokeString instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.InvokeString copyOf(Trees.InvokeString instance) {
&nbsp;      if (instance instanceof ImmutableTrees.InvokeString) {
&nbsp;        return (ImmutableTrees.InvokeString) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.InvokeString.of(instance.literal());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Invoke}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Invoke.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Invoke&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Invoke implements Trees.Invoke {
&nbsp;    private final Trees.AccessExpression access;
&nbsp;    private final Optional&lt;Trees.ApplyExpression&gt; invoke;
&nbsp;
&nbsp;    private Invoke(
&nbsp;        Trees.AccessExpression access,
&nbsp;        Optional&lt;Trees.ApplyExpression&gt; invoke) {
&nbsp;      this.access = access;
&nbsp;      this.invoke = invoke;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code access} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.AccessExpression access() {
&nbsp;      return access;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code invoke} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.ApplyExpression&gt; invoke() {
&nbsp;      return invoke;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Invoke#access() access} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for access
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Invoke withAccess(Trees.AccessExpression value) {
&nbsp;      if (this.access == value) return this;
&nbsp;      Trees.AccessExpression newValue = Objects.requireNonNull(value, &quot;access&quot;);
&nbsp;      return new ImmutableTrees.Invoke(newValue, this.invoke);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.Invoke#invoke() invoke} attribute.
&nbsp;     * @param value The value for invoke
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Invoke withInvoke(Trees.ApplyExpression value) {
&nbsp;      Optional&lt;Trees.ApplyExpression&gt; newValue = Optional.of(value);
&nbsp;      if (this.invoke.isPresent() &amp;&amp; this.invoke.get() == value) return this;
&nbsp;      return new ImmutableTrees.Invoke(this.access, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.Invoke#invoke() invoke} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for invoke
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.Invoke withInvoke(Optional&lt;? extends Trees.ApplyExpression&gt; optional) {
&nbsp;      Optional&lt;Trees.ApplyExpression&gt; value = (Optional&lt;Trees.ApplyExpression&gt;) optional;
&nbsp;      if (!this.invoke.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.invoke.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.invoke.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.Invoke(this.access, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Invoke} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Invoke
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Invoke) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Invoke another) {
&nbsp;      return access.equals(another.access)
&nbsp;          &amp;&amp; invoke.equals(another.invoke);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code access}, {@code invoke}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + access.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + invoke.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Invoke} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Invoke&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;access&quot;, access)
&nbsp;          .add(&quot;invoke&quot;, invoke.orNull())
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Invoke} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Invoke instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Invoke copyOf(Trees.Invoke instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Invoke) {
&nbsp;        return (ImmutableTrees.Invoke) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Invoke.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.Invoke Invoke}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.Invoke.builder()
&nbsp;     *    .access(org.immutables.generator.processor.Trees.AccessExpression) // required {@link Trees.Invoke#access() access}
&nbsp;     *    .invoke(org.immutables.generator.processor.Trees.ApplyExpression) // optional {@link Trees.Invoke#invoke() invoke}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Invoke builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.Invoke.Builder builder() {
&nbsp;      return new ImmutableTrees.Invoke.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.Invoke Invoke}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.Invoke&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_ACCESS = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.AccessExpression access;
&nbsp;      private Optional&lt;Trees.ApplyExpression&gt; invoke = Optional.absent();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokeDeclaration} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokeDeclaration instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Invoke} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Invoke instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.InvokeDeclaration) {
&nbsp;          Trees.InvokeDeclaration instance = (Trees.InvokeDeclaration) object;
&nbsp;          Optional&lt;Trees.ApplyExpression&gt; invokeOptional = instance.invoke();
&nbsp;          if (invokeOptional.isPresent()) {
&nbsp;            invoke(invokeOptional);
&nbsp;          }
&nbsp;          access(instance.access());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Invoke#access() access} attribute.
&nbsp;       * @param access The value for access 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder access(Trees.AccessExpression access) {
&nbsp;        this.access = Objects.requireNonNull(access, &quot;access&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_ACCESS;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.Invoke#invoke() invoke} to invoke.
&nbsp;       * @param invoke The value for invoke
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder invoke(Trees.ApplyExpression invoke) {
&nbsp;        this.invoke = Optional.of(invoke);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.Invoke#invoke() invoke} to invoke.
&nbsp;       * @param invoke The value for invoke
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder invoke(Optional&lt;? extends Trees.ApplyExpression&gt; invoke) {
&nbsp;        this.invoke = (Optional&lt;Trees.ApplyExpression&gt;) invoke;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.Invoke Invoke}.
&nbsp;       * @return An immutable instance of Invoke
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.Invoke build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.Invoke(access, invoke);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_ACCESS) != 0) attributes.add(&quot;access&quot;);
&nbsp;        return &quot;Cannot build Invoke, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Let}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Let.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Let&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Let implements Trees.Let {
&nbsp;    private final Trees.InvokableDeclaration declaration;
&nbsp;
&nbsp;    private Let(Trees.InvokableDeclaration declaration) {
&nbsp;      this.declaration = declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.InvokableDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Let#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Let withDeclaration(Trees.InvokableDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.InvokableDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.Let(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Let} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Let
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Let) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Let another) {
&nbsp;      return declaration.equals(another.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code declaration}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Let} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Let&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Let} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Let instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Let copyOf(Trees.Let instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Let) {
&nbsp;        return (ImmutableTrees.Let) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Let.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.Let Let}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.Let.builder()
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.InvokableDeclaration) // required {@link Trees.Let#declaration() declaration}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Let builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.Let.Builder builder() {
&nbsp;      return new ImmutableTrees.Let.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.Let Let}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.Let&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.InvokableDeclaration declaration;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokableStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokableStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Let} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Let instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.InvokableStatement) {
&nbsp;          Trees.InvokableStatement instance = (Trees.InvokableStatement) object;
&nbsp;          declaration(instance.declaration());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Let#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.InvokableDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.Let Let}.
&nbsp;       * @return An immutable instance of Let
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.Let build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.Let(declaration);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        return &quot;Cannot build Let, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Unit}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Unit.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Unit&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Unit implements Trees.Unit {
&nbsp;    private final ImmutableList&lt;Trees.UnitPart&gt; parts;
&nbsp;
&nbsp;    private Unit(ImmutableList&lt;Trees.UnitPart&gt; parts) {
&nbsp;      this.parts = parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.UnitPart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.Unit#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Unit withParts(Trees.UnitPart... elements) {
&nbsp;      ImmutableList&lt;Trees.UnitPart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.Unit(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.Unit#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Unit withParts(Iterable&lt;? extends Trees.UnitPart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.UnitPart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.Unit(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Unit} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Unit
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Unit) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Unit another) {
&nbsp;      return parts.equals(another.parts);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Unit} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Unit&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Unit} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Unit instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Unit copyOf(Trees.Unit instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Unit) {
&nbsp;        return (ImmutableTrees.Unit) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Unit.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.Unit Unit}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.Unit.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.UnitPart) // {@link Trees.Unit#parts() parts} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Unit builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.Unit.Builder builder() {
&nbsp;      return new ImmutableTrees.Unit.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.Unit Unit}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.Unit&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.UnitPart&gt; parts = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code Unit} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * Collection elements and entries will be added, not replaced.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Unit instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        addAllParts(instance.parts());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.Unit#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.UnitPart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.Unit#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.UnitPart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.Unit#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.UnitPart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.Unit#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.UnitPart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.Unit Unit}.
&nbsp;       * @return An immutable instance of Unit
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.Unit build() {
&nbsp;        return new ImmutableTrees.Unit(parts.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Template}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.Template.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Template&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Template extends Trees.Template {
&nbsp;    private final ImmutableList&lt;Trees.TemplatePart&gt; parts;
&nbsp;    private final Trees.InvokableDeclaration declaration;
&nbsp;    private final boolean isPublic;
&nbsp;
&nbsp;    private Template(ImmutableTrees.Template.Builder builder) {
&nbsp;      this.parts = builder.parts.build();
&nbsp;      this.declaration = builder.declaration;
&nbsp;      this.isPublic = builder.isPublicIsSet()
&nbsp;          ? builder.isPublic
&nbsp;          : super.isPublic();
&nbsp;    }
&nbsp;
&nbsp;    private Template(
&nbsp;        ImmutableList&lt;Trees.TemplatePart&gt; parts,
&nbsp;        Trees.InvokableDeclaration declaration,
&nbsp;        boolean isPublic) {
&nbsp;      this.parts = parts;
&nbsp;      this.declaration = declaration;
&nbsp;      this.isPublic = isPublic;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TemplatePart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.InvokableDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code isPublic} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isPublic() {
&nbsp;      return isPublic;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.Template#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Template withParts(Trees.TemplatePart... elements) {
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.Template(newValue, this.declaration, this.isPublic);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.Template#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Template withParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TemplatePart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.Template(newValue, this.declaration, this.isPublic);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Template#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Template withDeclaration(Trees.InvokableDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.InvokableDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.Template(this.parts, newValue, this.isPublic);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.Template#isPublic() isPublic} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for isPublic
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.Template withIsPublic(boolean value) {
&nbsp;      if (this.isPublic == value) return this;
&nbsp;      return new ImmutableTrees.Template(this.parts, this.declaration, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Template} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.Template
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.Template) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.Template another) {
&nbsp;      return parts.equals(another.parts)
&nbsp;          &amp;&amp; declaration.equals(another.declaration)
&nbsp;          &amp;&amp; isPublic == another.isPublic;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}, {@code declaration}, {@code isPublic}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + Booleans.hashCode(isPublic);
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Template} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;Template&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .add(&quot;isPublic&quot;, isPublic)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.Template} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable Template instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.Template copyOf(Trees.Template instance) {
&nbsp;      if (instance instanceof ImmutableTrees.Template) {
&nbsp;        return (ImmutableTrees.Template) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.Template.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.Template Template}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.Template.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TemplatePart) // {@link Trees.Template#parts() parts} elements
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.InvokableDeclaration) // required {@link Trees.Template#declaration() declaration}
&nbsp;     *    .isPublic(boolean) // optional {@link Trees.Template#isPublic() isPublic}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new Template builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.Template.Builder builder() {
&nbsp;      return new ImmutableTrees.Template.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.Template Template}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.Template&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private static final long OPT_BIT_IS_PUBLIC = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;      private long optBits;
&nbsp;
&nbsp;      private ImmutableList.Builder&lt;Trees.TemplatePart&gt; parts = ImmutableList.builder();
&nbsp;      private @Nullable Trees.InvokableDeclaration declaration;
&nbsp;      private boolean isPublic;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Block} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Block instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Template} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Template instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.InvokableStatement} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.InvokableStatement instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Block) {
&nbsp;          Trees.Block instance = (Trees.Block) object;
&nbsp;          addAllParts(instance.parts());
&nbsp;        }
&nbsp;        if (object instanceof Trees.Template) {
&nbsp;          Trees.Template instance = (Trees.Template) object;
&nbsp;          isPublic(instance.isPublic());
&nbsp;        }
&nbsp;        if (object instanceof Trees.InvokableStatement) {
&nbsp;          Trees.InvokableStatement instance = (Trees.InvokableStatement) object;
&nbsp;          declaration(instance.declaration());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.Template#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.Template#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TemplatePart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.Template#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.Template#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TemplatePart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Template#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.InvokableDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.Template#isPublic() isPublic} attribute.
&nbsp;       * &lt;p&gt;&lt;em&gt;If not set, this attribute will have a default value as returned by the initializer of {@link Trees.Template#isPublic() isPublic}.&lt;/em&gt;
&nbsp;       * @param isPublic The value for isPublic 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder isPublic(boolean isPublic) {
&nbsp;        this.isPublic = isPublic;
&nbsp;        optBits |= OPT_BIT_IS_PUBLIC;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.Template Template}.
&nbsp;       * @return An immutable instance of Template
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.Template build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.Template(this);
&nbsp;      }
&nbsp;
&nbsp;      private boolean isPublicIsSet() {
&nbsp;        return (optBits &amp; OPT_BIT_IS_PUBLIC) != 0;
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        return &quot;Cannot build Template, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.SimpleAccessExpression}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.SimpleAccessExpression.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.SimpleAccessExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class SimpleAccessExpression
&nbsp;      implements Trees.SimpleAccessExpression {
&nbsp;    private final ImmutableList&lt;Trees.Identifier&gt; path;
&nbsp;
&nbsp;    private SimpleAccessExpression(ImmutableList&lt;Trees.Identifier&gt; path) {
&nbsp;      this.path = path;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code path} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Identifier&gt; path() {
&nbsp;      return path;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.SimpleAccessExpression#path() path}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.SimpleAccessExpression withPath(Trees.Identifier... elements) {
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.SimpleAccessExpression(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.SimpleAccessExpression#path() path}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of path elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.SimpleAccessExpression withPath(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;      if (this.path == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Identifier&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.SimpleAccessExpression(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code SimpleAccessExpression} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.SimpleAccessExpression
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.SimpleAccessExpression) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.SimpleAccessExpression another) {
&nbsp;      return path.equals(another.path);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code path}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + path.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code SimpleAccessExpression} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;SimpleAccessExpression&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;path&quot;, path)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.SimpleAccessExpression} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable SimpleAccessExpression instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.SimpleAccessExpression copyOf(Trees.SimpleAccessExpression instance) {
&nbsp;      if (instance instanceof ImmutableTrees.SimpleAccessExpression) {
&nbsp;        return (ImmutableTrees.SimpleAccessExpression) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.SimpleAccessExpression.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.SimpleAccessExpression SimpleAccessExpression}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.SimpleAccessExpression.builder()
&nbsp;     *    .addPath|addAllPath(org.immutables.generator.processor.Trees.Identifier) // {@link Trees.SimpleAccessExpression#path() path} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new SimpleAccessExpression builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.SimpleAccessExpression.Builder builder() {
&nbsp;      return new ImmutableTrees.SimpleAccessExpression.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.SimpleAccessExpression SimpleAccessExpression}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.SimpleAccessExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.Identifier&gt; path = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.AccessExpression} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.AccessExpression instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.SimpleAccessExpression} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.SimpleAccessExpression instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.AccessExpression) {
&nbsp;          Trees.AccessExpression instance = (Trees.AccessExpression) object;
&nbsp;          addAllPath(instance.path());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.SimpleAccessExpression#path() path} list.
&nbsp;       * @param element A path element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addPath(Trees.Identifier element) {
&nbsp;        this.path.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.SimpleAccessExpression#path() path} list.
&nbsp;       * @param elements An array of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addPath(Trees.Identifier... elements) {
&nbsp;        this.path.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.SimpleAccessExpression#path() path} list.
&nbsp;       * @param elements An iterable of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder path(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;        this.path = ImmutableList.builder();
&nbsp;        return addAllPath(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.SimpleAccessExpression#path() path} list.
&nbsp;       * @param elements An iterable of path elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllPath(Iterable&lt;? extends Trees.Identifier&gt; elements) {
&nbsp;        this.path.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.SimpleAccessExpression SimpleAccessExpression}.
&nbsp;       * @return An immutable instance of SimpleAccessExpression
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.SimpleAccessExpression build() {
&nbsp;        return new ImmutableTrees.SimpleAccessExpression(path.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ApplyExpression}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ApplyExpression.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ApplyExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ApplyExpression implements Trees.ApplyExpression {
&nbsp;    private final ImmutableList&lt;Trees.Expression&gt; params;
&nbsp;
&nbsp;    private ApplyExpression(
&nbsp;        ImmutableList&lt;Trees.Expression&gt; params) {
&nbsp;      this.params = params;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code params} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.Expression&gt; params() {
&nbsp;      return params;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ApplyExpression#params() params}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ApplyExpression withParams(Trees.Expression... elements) {
&nbsp;      ImmutableList&lt;Trees.Expression&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ApplyExpression(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.ApplyExpression#params() params}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of params elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ApplyExpression withParams(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;      if (this.params == elements) return this;
&nbsp;      ImmutableList&lt;Trees.Expression&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.ApplyExpression(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ApplyExpression} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ApplyExpression
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ApplyExpression) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ApplyExpression another) {
&nbsp;      return params.equals(another.params);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code params}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + params.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ApplyExpression} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ApplyExpression&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;params&quot;, params)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ApplyExpression} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ApplyExpression instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ApplyExpression copyOf(Trees.ApplyExpression instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ApplyExpression) {
&nbsp;        return (ImmutableTrees.ApplyExpression) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ApplyExpression.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ApplyExpression ApplyExpression}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ApplyExpression.builder()
&nbsp;     *    .addParams|addAllParams(org.immutables.generator.processor.Trees.Expression) // {@link Trees.ApplyExpression#params() params} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ApplyExpression builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ApplyExpression.Builder builder() {
&nbsp;      return new ImmutableTrees.ApplyExpression.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ApplyExpression ApplyExpression}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ApplyExpression&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.Expression&gt; params = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code ApplyExpression} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * Collection elements and entries will be added, not replaced.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ApplyExpression instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        addAllParams(instance.params());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.ApplyExpression#params() params} list.
&nbsp;       * @param element A params element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParams(Trees.Expression element) {
&nbsp;        this.params.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ApplyExpression#params() params} list.
&nbsp;       * @param elements An array of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParams(Trees.Expression... elements) {
&nbsp;        this.params.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.ApplyExpression#params() params} list.
&nbsp;       * @param elements An iterable of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder params(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;        this.params = ImmutableList.builder();
&nbsp;        return addAllParams(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.ApplyExpression#params() params} list.
&nbsp;       * @param elements An iterable of params elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParams(Iterable&lt;? extends Trees.Expression&gt; elements) {
&nbsp;        this.params.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ApplyExpression ApplyExpression}.
&nbsp;       * @return An immutable instance of ApplyExpression
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ApplyExpression build() {
&nbsp;        return new ImmutableTrees.ApplyExpression(params.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.AssignGenerator}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.AssignGenerator.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.AssignGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class AssignGenerator implements Trees.AssignGenerator {
&nbsp;    private final Trees.ValueDeclaration declaration;
&nbsp;    private final Trees.Expression from;
&nbsp;
&nbsp;    private AssignGenerator(
&nbsp;        Trees.ValueDeclaration declaration,
&nbsp;        Trees.Expression from) {
&nbsp;      this.declaration = declaration;
&nbsp;      this.from = from;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.ValueDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code from} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression from() {
&nbsp;      return from;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.AssignGenerator#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.AssignGenerator withDeclaration(Trees.ValueDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.ValueDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.AssignGenerator(newValue, this.from);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.AssignGenerator#from() from} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for from
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.AssignGenerator withFrom(Trees.Expression value) {
&nbsp;      if (this.from == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;from&quot;);
&nbsp;      return new ImmutableTrees.AssignGenerator(this.declaration, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code AssignGenerator} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.AssignGenerator
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.AssignGenerator) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.AssignGenerator another) {
&nbsp;      return declaration.equals(another.declaration)
&nbsp;          &amp;&amp; from.equals(another.from);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code declaration}, {@code from}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + from.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code AssignGenerator} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;AssignGenerator&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .add(&quot;from&quot;, from)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.AssignGenerator} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable AssignGenerator instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.AssignGenerator copyOf(Trees.AssignGenerator instance) {
&nbsp;      if (instance instanceof ImmutableTrees.AssignGenerator) {
&nbsp;        return (ImmutableTrees.AssignGenerator) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.AssignGenerator.builder()
&nbsp;          .declaration(instance.declaration())
&nbsp;          .from(instance.from())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.AssignGenerator AssignGenerator}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.AssignGenerator.builder()
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.ValueDeclaration) // required {@link Trees.AssignGenerator#declaration() declaration}
&nbsp;     *    .from(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.AssignGenerator#from() from}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new AssignGenerator builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.AssignGenerator.Builder builder() {
&nbsp;      return new ImmutableTrees.AssignGenerator.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.AssignGenerator AssignGenerator}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.AssignGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private static final long INIT_BIT_FROM = 0x2L;
&nbsp;      private long initBits = 0x3L;
&nbsp;
&nbsp;      private @Nullable Trees.ValueDeclaration declaration;
&nbsp;      private @Nullable Trees.Expression from;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.AssignGenerator#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.ValueDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.AssignGenerator#from() from} attribute.
&nbsp;       * @param from The value for from 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Expression from) {
&nbsp;        this.from = Objects.requireNonNull(from, &quot;from&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_FROM;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.AssignGenerator AssignGenerator}.
&nbsp;       * @return An immutable instance of AssignGenerator
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.AssignGenerator build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.AssignGenerator(declaration, from);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_FROM) != 0) attributes.add(&quot;from&quot;);
&nbsp;        return &quot;Cannot build AssignGenerator, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.IterationGenerator}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.IterationGenerator.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.IterationGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class IterationGenerator implements Trees.IterationGenerator {
&nbsp;    private final Trees.ValueDeclaration declaration;
&nbsp;    private final Trees.Expression from;
&nbsp;    private final Optional&lt;Trees.Expression&gt; condition;
&nbsp;
&nbsp;    private IterationGenerator(
&nbsp;        Trees.ValueDeclaration declaration,
&nbsp;        Trees.Expression from,
&nbsp;        Optional&lt;Trees.Expression&gt; condition) {
&nbsp;      this.declaration = declaration;
&nbsp;      this.from = from;
&nbsp;      this.condition = condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.ValueDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code from} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression from() {
&nbsp;      return from;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code condition} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.Expression&gt; condition() {
&nbsp;      return condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.IterationGenerator#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IterationGenerator withDeclaration(Trees.ValueDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.ValueDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.IterationGenerator(newValue, this.from, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.IterationGenerator#from() from} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for from
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IterationGenerator withFrom(Trees.Expression value) {
&nbsp;      if (this.from == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;from&quot;);
&nbsp;      return new ImmutableTrees.IterationGenerator(this.declaration, newValue, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.IterationGenerator#condition() condition} attribute.
&nbsp;     * @param value The value for condition
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.IterationGenerator withCondition(Trees.Expression value) {
&nbsp;      Optional&lt;Trees.Expression&gt; newValue = Optional.of(value);
&nbsp;      if (this.condition.isPresent() &amp;&amp; this.condition.get() == value) return this;
&nbsp;      return new ImmutableTrees.IterationGenerator(this.declaration, this.from, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.IterationGenerator#condition() condition} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for condition
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.IterationGenerator withCondition(Optional&lt;? extends Trees.Expression&gt; optional) {
&nbsp;      Optional&lt;Trees.Expression&gt; value = (Optional&lt;Trees.Expression&gt;) optional;
&nbsp;      if (!this.condition.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.condition.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.condition.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.IterationGenerator(this.declaration, this.from, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code IterationGenerator} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.IterationGenerator
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.IterationGenerator) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.IterationGenerator another) {
&nbsp;      return declaration.equals(another.declaration)
&nbsp;          &amp;&amp; from.equals(another.from)
&nbsp;          &amp;&amp; condition.equals(another.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code declaration}, {@code from}, {@code condition}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + from.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + condition.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code IterationGenerator} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;IterationGenerator&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .add(&quot;from&quot;, from)
&nbsp;          .add(&quot;condition&quot;, condition.orNull())
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.IterationGenerator} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable IterationGenerator instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.IterationGenerator copyOf(Trees.IterationGenerator instance) {
&nbsp;      if (instance instanceof ImmutableTrees.IterationGenerator) {
&nbsp;        return (ImmutableTrees.IterationGenerator) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.IterationGenerator.builder()
&nbsp;          .declaration(instance.declaration())
&nbsp;          .from(instance.from())
&nbsp;          .condition(instance.condition())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.IterationGenerator IterationGenerator}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.IterationGenerator.builder()
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.ValueDeclaration) // required {@link Trees.IterationGenerator#declaration() declaration}
&nbsp;     *    .from(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.IterationGenerator#from() from}
&nbsp;     *    .condition(org.immutables.generator.processor.Trees.Expression) // optional {@link Trees.IterationGenerator#condition() condition}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new IterationGenerator builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.IterationGenerator.Builder builder() {
&nbsp;      return new ImmutableTrees.IterationGenerator.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.IterationGenerator IterationGenerator}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.IterationGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private static final long INIT_BIT_FROM = 0x2L;
&nbsp;      private long initBits = 0x3L;
&nbsp;
&nbsp;      private @Nullable Trees.ValueDeclaration declaration;
&nbsp;      private @Nullable Trees.Expression from;
&nbsp;      private Optional&lt;Trees.Expression&gt; condition = Optional.absent();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.IterationGenerator#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.ValueDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.IterationGenerator#from() from} attribute.
&nbsp;       * @param from The value for from 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Expression from) {
&nbsp;        this.from = Objects.requireNonNull(from, &quot;from&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_FROM;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.IterationGenerator#condition() condition} to condition.
&nbsp;       * @param condition The value for condition
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Trees.Expression condition) {
&nbsp;        this.condition = Optional.of(condition);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.IterationGenerator#condition() condition} to condition.
&nbsp;       * @param condition The value for condition
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Optional&lt;? extends Trees.Expression&gt; condition) {
&nbsp;        this.condition = (Optional&lt;Trees.Expression&gt;) condition;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.IterationGenerator IterationGenerator}.
&nbsp;       * @return An immutable instance of IterationGenerator
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.IterationGenerator build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.IterationGenerator(declaration, from, condition);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_FROM) != 0) attributes.add(&quot;from&quot;);
&nbsp;        return &quot;Cannot build IterationGenerator, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TransformGenerator}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TransformGenerator.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TransformGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TransformGenerator implements Trees.TransformGenerator {
&nbsp;    private final Trees.ValueDeclaration declaration;
&nbsp;    private final Trees.Expression from;
&nbsp;    private final Trees.Expression transform;
&nbsp;    private final Trees.ValueDeclaration varDeclaration;
&nbsp;    private final Optional&lt;Trees.Expression&gt; condition;
&nbsp;
&nbsp;    private TransformGenerator(
&nbsp;        Trees.ValueDeclaration declaration,
&nbsp;        Trees.Expression from,
&nbsp;        Trees.Expression transform,
&nbsp;        Trees.ValueDeclaration varDeclaration,
&nbsp;        Optional&lt;Trees.Expression&gt; condition) {
&nbsp;      this.declaration = declaration;
&nbsp;      this.from = from;
&nbsp;      this.transform = transform;
&nbsp;      this.varDeclaration = varDeclaration;
&nbsp;      this.condition = condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.ValueDeclaration declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code from} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression from() {
&nbsp;      return from;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code transform} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression transform() {
&nbsp;      return transform;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code varDeclaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.ValueDeclaration varDeclaration() {
&nbsp;      return varDeclaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code condition} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Optional&lt;Trees.Expression&gt; condition() {
&nbsp;      return condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TransformGenerator#declaration() declaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for declaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TransformGenerator withDeclaration(Trees.ValueDeclaration value) {
&nbsp;      if (this.declaration == value) return this;
&nbsp;      Trees.ValueDeclaration newValue = Objects.requireNonNull(value, &quot;declaration&quot;);
&nbsp;      return new ImmutableTrees.TransformGenerator(newValue, this.from, this.transform, this.varDeclaration, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TransformGenerator#from() from} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for from
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TransformGenerator withFrom(Trees.Expression value) {
&nbsp;      if (this.from == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;from&quot;);
&nbsp;      return new ImmutableTrees.TransformGenerator(this.declaration, newValue, this.transform, this.varDeclaration, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TransformGenerator#transform() transform} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for transform
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TransformGenerator withTransform(Trees.Expression value) {
&nbsp;      if (this.transform == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;transform&quot;);
&nbsp;      return new ImmutableTrees.TransformGenerator(this.declaration, this.from, newValue, this.varDeclaration, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TransformGenerator#varDeclaration() varDeclaration} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for varDeclaration
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TransformGenerator withVarDeclaration(Trees.ValueDeclaration value) {
&nbsp;      if (this.varDeclaration == value) return this;
&nbsp;      Trees.ValueDeclaration newValue = Objects.requireNonNull(value, &quot;varDeclaration&quot;);
&nbsp;      return new ImmutableTrees.TransformGenerator(this.declaration, this.from, this.transform, newValue, this.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a &lt;i&gt;present&lt;/i&gt; value for the optional {@link Trees.TransformGenerator#condition() condition} attribute.
&nbsp;     * @param value The value for condition
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TransformGenerator withCondition(Trees.Expression value) {
&nbsp;      Optional&lt;Trees.Expression&gt; newValue = Optional.of(value);
&nbsp;      if (this.condition.isPresent() &amp;&amp; this.condition.get() == value) return this;
&nbsp;      return new ImmutableTrees.TransformGenerator(this.declaration, this.from, this.transform, this.varDeclaration, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting an optional value for the {@link Trees.TransformGenerator#condition() condition} attribute.
&nbsp;     * A shallow reference equality check on the optional value is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param optional A value for condition
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;    public final ImmutableTrees.TransformGenerator withCondition(Optional&lt;? extends Trees.Expression&gt; optional) {
&nbsp;      Optional&lt;Trees.Expression&gt; value = (Optional&lt;Trees.Expression&gt;) optional;
&nbsp;      if (!this.condition.isPresent() &amp;&amp; !value.isPresent()) return this;
&nbsp;      if (this.condition.isPresent() &amp;&amp; value.isPresent() &amp;&amp; this.condition.get() == value.get()) return this;
&nbsp;      return new ImmutableTrees.TransformGenerator(this.declaration, this.from, this.transform, this.varDeclaration, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TransformGenerator} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TransformGenerator
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TransformGenerator) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TransformGenerator another) {
&nbsp;      return declaration.equals(another.declaration)
&nbsp;          &amp;&amp; from.equals(another.from)
&nbsp;          &amp;&amp; transform.equals(another.transform)
&nbsp;          &amp;&amp; varDeclaration.equals(another.varDeclaration)
&nbsp;          &amp;&amp; condition.equals(another.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code declaration}, {@code from}, {@code transform}, {@code varDeclaration}, {@code condition}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + from.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + transform.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + varDeclaration.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + condition.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code TransformGenerator} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;TransformGenerator&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .add(&quot;from&quot;, from)
&nbsp;          .add(&quot;transform&quot;, transform)
&nbsp;          .add(&quot;varDeclaration&quot;, varDeclaration)
&nbsp;          .add(&quot;condition&quot;, condition.orNull())
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TransformGenerator} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TransformGenerator instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TransformGenerator copyOf(Trees.TransformGenerator instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TransformGenerator) {
&nbsp;        return (ImmutableTrees.TransformGenerator) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TransformGenerator.builder()
&nbsp;          .declaration(instance.declaration())
&nbsp;          .from(instance.from())
&nbsp;          .transform(instance.transform())
&nbsp;          .varDeclaration(instance.varDeclaration())
&nbsp;          .condition(instance.condition())
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.TransformGenerator TransformGenerator}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.TransformGenerator.builder()
&nbsp;     *    .declaration(org.immutables.generator.processor.Trees.ValueDeclaration) // required {@link Trees.TransformGenerator#declaration() declaration}
&nbsp;     *    .from(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.TransformGenerator#from() from}
&nbsp;     *    .transform(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.TransformGenerator#transform() transform}
&nbsp;     *    .varDeclaration(org.immutables.generator.processor.Trees.ValueDeclaration) // required {@link Trees.TransformGenerator#varDeclaration() varDeclaration}
&nbsp;     *    .condition(org.immutables.generator.processor.Trees.Expression) // optional {@link Trees.TransformGenerator#condition() condition}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new TransformGenerator builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.TransformGenerator.Builder builder() {
&nbsp;      return new ImmutableTrees.TransformGenerator.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.TransformGenerator TransformGenerator}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.TransformGenerator&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_DECLARATION = 0x1L;
&nbsp;      private static final long INIT_BIT_FROM = 0x2L;
&nbsp;      private static final long INIT_BIT_TRANSFORM = 0x4L;
&nbsp;      private static final long INIT_BIT_VAR_DECLARATION = 0x8L;
&nbsp;      private long initBits = 0xfL;
&nbsp;
&nbsp;      private @Nullable Trees.ValueDeclaration declaration;
&nbsp;      private @Nullable Trees.Expression from;
&nbsp;      private @Nullable Trees.Expression transform;
&nbsp;      private @Nullable Trees.ValueDeclaration varDeclaration;
&nbsp;      private Optional&lt;Trees.Expression&gt; condition = Optional.absent();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TransformGenerator#declaration() declaration} attribute.
&nbsp;       * @param declaration The value for declaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Trees.ValueDeclaration declaration) {
&nbsp;        this.declaration = Objects.requireNonNull(declaration, &quot;declaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TransformGenerator#from() from} attribute.
&nbsp;       * @param from The value for from 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Expression from) {
&nbsp;        this.from = Objects.requireNonNull(from, &quot;from&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_FROM;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TransformGenerator#transform() transform} attribute.
&nbsp;       * @param transform The value for transform 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder transform(Trees.Expression transform) {
&nbsp;        this.transform = Objects.requireNonNull(transform, &quot;transform&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_TRANSFORM;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TransformGenerator#varDeclaration() varDeclaration} attribute.
&nbsp;       * @param varDeclaration The value for varDeclaration 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder varDeclaration(Trees.ValueDeclaration varDeclaration) {
&nbsp;        this.varDeclaration = Objects.requireNonNull(varDeclaration, &quot;varDeclaration&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_VAR_DECLARATION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.TransformGenerator#condition() condition} to condition.
&nbsp;       * @param condition The value for condition
&nbsp;       * @return {@code this} builder for chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Trees.Expression condition) {
&nbsp;        this.condition = Optional.of(condition);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the optional value {@link Trees.TransformGenerator#condition() condition} to condition.
&nbsp;       * @param condition The value for condition
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;) // safe covariant cast
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Optional&lt;? extends Trees.Expression&gt; condition) {
&nbsp;        this.condition = (Optional&lt;Trees.Expression&gt;) condition;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.TransformGenerator TransformGenerator}.
&nbsp;       * @return An immutable instance of TransformGenerator
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.TransformGenerator build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.TransformGenerator(declaration, from, transform, varDeclaration, condition);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_DECLARATION) != 0) attributes.add(&quot;declaration&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_FROM) != 0) attributes.add(&quot;from&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_TRANSFORM) != 0) attributes.add(&quot;transform&quot;);
&nbsp;        if ((initBits &amp; INIT_BIT_VAR_DECLARATION) != 0) attributes.add(&quot;varDeclaration&quot;);
&nbsp;        return &quot;Cannot build TransformGenerator, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.For}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.For.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.For&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class For implements Trees.For {
&nbsp;    private final ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration;
&nbsp;
&nbsp;    private For(
&nbsp;        ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration) {
&nbsp;      this.declaration = declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code declaration} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.GeneratorDeclaration&gt; declaration() {
&nbsp;      return declaration;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.For#declaration() declaration}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.For withDeclaration(Trees.GeneratorDeclaration... elements) {
&nbsp;      ImmutableList&lt;Trees.GeneratorDeclaration&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.For(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.For#declaration() declaration}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of declaration elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.For withDeclaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;      if (this.declaration == elements) return this;
&nbsp;      ImmutableList&lt;Trees.GeneratorDeclaration&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.For(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code For} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.For
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.For) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.For another) {
&nbsp;      return declaration.equals(another.declaration);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code declaration}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + declaration.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code For} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;For&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;declaration&quot;, declaration)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.For} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable For instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.For copyOf(Trees.For instance) {
&nbsp;      if (instance instanceof ImmutableTrees.For) {
&nbsp;        return (ImmutableTrees.For) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.For.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.For For}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.For.builder()
&nbsp;     *    .addDeclaration|addAllDeclaration(org.immutables.generator.processor.Trees.GeneratorDeclaration) // {@link Trees.For#declaration() declaration} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new For builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.For.Builder builder() {
&nbsp;      return new ImmutableTrees.For.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.For For}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.For&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.GeneratorDeclaration&gt; declaration = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code For} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * Collection elements and entries will be added, not replaced.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.For instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        addAllDeclaration(instance.declaration());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.For#declaration() declaration} list.
&nbsp;       * @param element A declaration element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addDeclaration(Trees.GeneratorDeclaration element) {
&nbsp;        this.declaration.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.For#declaration() declaration} list.
&nbsp;       * @param elements An array of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addDeclaration(Trees.GeneratorDeclaration... elements) {
&nbsp;        this.declaration.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.For#declaration() declaration} list.
&nbsp;       * @param elements An iterable of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder declaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;        this.declaration = ImmutableList.builder();
&nbsp;        return addAllDeclaration(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.For#declaration() declaration} list.
&nbsp;       * @param elements An iterable of declaration elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllDeclaration(Iterable&lt;? extends Trees.GeneratorDeclaration&gt; elements) {
&nbsp;        this.declaration.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.For For}.
&nbsp;       * @return An immutable instance of For
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.For build() {
&nbsp;        return new ImmutableTrees.For(declaration.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.If}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.If.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.If&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class If implements Trees.If {
&nbsp;    private final Trees.Expression condition;
&nbsp;
&nbsp;    private If(Trees.Expression condition) {
&nbsp;      this.condition = condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code condition} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression condition() {
&nbsp;      return condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.If#condition() condition} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for condition
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.If withCondition(Trees.Expression value) {
&nbsp;      if (this.condition == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;condition&quot;);
&nbsp;      return new ImmutableTrees.If(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code If} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.If
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.If) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.If another) {
&nbsp;      return condition.equals(another.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code condition}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + condition.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code If} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;If&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;condition&quot;, condition)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.If} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable If instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.If copyOf(Trees.If instance) {
&nbsp;      if (instance instanceof ImmutableTrees.If) {
&nbsp;        return (ImmutableTrees.If) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.If.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.If If}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.If.builder()
&nbsp;     *    .condition(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.If#condition() condition}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new If builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.If.Builder builder() {
&nbsp;      return new ImmutableTrees.If.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.If If}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.If&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_CONDITION = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.Expression condition;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Conditional} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Conditional instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.If} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.If instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Conditional) {
&nbsp;          Trees.Conditional instance = (Trees.Conditional) object;
&nbsp;          condition(instance.condition());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.If#condition() condition} attribute.
&nbsp;       * @param condition The value for condition 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Trees.Expression condition) {
&nbsp;        this.condition = Objects.requireNonNull(condition, &quot;condition&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_CONDITION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.If If}.
&nbsp;       * @return An immutable instance of If
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.If build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.If(condition);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_CONDITION) != 0) attributes.add(&quot;condition&quot;);
&nbsp;        return &quot;Cannot build If, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.ElseIf}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.ElseIf.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.ElseIf&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class ElseIf implements Trees.ElseIf {
&nbsp;    private final Trees.Expression condition;
&nbsp;
&nbsp;    private ElseIf(Trees.Expression condition) {
&nbsp;      this.condition = condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code condition} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.Expression condition() {
&nbsp;      return condition;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.ElseIf#condition() condition} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for condition
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.ElseIf withCondition(Trees.Expression value) {
&nbsp;      if (this.condition == value) return this;
&nbsp;      Trees.Expression newValue = Objects.requireNonNull(value, &quot;condition&quot;);
&nbsp;      return new ImmutableTrees.ElseIf(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code ElseIf} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.ElseIf
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.ElseIf) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.ElseIf another) {
&nbsp;      return condition.equals(another.condition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code condition}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + condition.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code ElseIf} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;ElseIf&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;condition&quot;, condition)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.ElseIf} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable ElseIf instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.ElseIf copyOf(Trees.ElseIf instance) {
&nbsp;      if (instance instanceof ImmutableTrees.ElseIf) {
&nbsp;        return (ImmutableTrees.ElseIf) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.ElseIf.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.ElseIf ElseIf}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.ElseIf.builder()
&nbsp;     *    .condition(org.immutables.generator.processor.Trees.Expression) // required {@link Trees.ElseIf#condition() condition}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new ElseIf builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.ElseIf.Builder builder() {
&nbsp;      return new ImmutableTrees.ElseIf.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.ElseIf ElseIf}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.ElseIf&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_CONDITION = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;
&nbsp;      private @Nullable Trees.Expression condition;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.Conditional} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.Conditional instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code org.immutables.generator.processor.Trees.ElseIf} instance.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.ElseIf instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        from((Object) instance);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      private void from(Object object) {
&nbsp;        if (object instanceof Trees.Conditional) {
&nbsp;          Trees.Conditional instance = (Trees.Conditional) object;
&nbsp;          condition(instance.condition());
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.ElseIf#condition() condition} attribute.
&nbsp;       * @param condition The value for condition 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder condition(Trees.Expression condition) {
&nbsp;        this.condition = Objects.requireNonNull(condition, &quot;condition&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_CONDITION;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.ElseIf ElseIf}.
&nbsp;       * @return An immutable instance of ElseIf
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.ElseIf build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.ElseIf(condition);
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_CONDITION) != 0) attributes.add(&quot;condition&quot;);
&nbsp;        return &quot;Cannot build ElseIf, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Else}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.Else.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Else&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Else implements Trees.Else {
&nbsp;
&nbsp;    private Else() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Else} that have equal attribute values.
&nbsp;     * As instances of the {@code Else} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return -1598161349;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code Else}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;Else{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.Else INSTANCE = new ImmutableTrees.Else();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code Else}
&nbsp;     * @return An immutable instance of Else
&nbsp;     */
&nbsp;    public static ImmutableTrees.Else of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TemplateEnd}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.TemplateEnd.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TemplateEnd&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TemplateEnd implements Trees.TemplateEnd {
&nbsp;
&nbsp;    private TemplateEnd() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TemplateEnd} that have equal attribute values.
&nbsp;     * As instances of the {@code TemplateEnd} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return 1299747805;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code TemplateEnd}.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return &quot;TemplateEnd{}&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.TemplateEnd INSTANCE = new ImmutableTrees.TemplateEnd();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code TemplateEnd}
&nbsp;     * @return An immutable instance of TemplateEnd
&nbsp;     */
&nbsp;    public static ImmutableTrees.TemplateEnd of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.StringLiteral}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.StringLiteral.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.StringLiteral&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class StringLiteral extends Trees.StringLiteral {
&nbsp;    private final String value;
&nbsp;
&nbsp;    private StringLiteral(String value) {
&nbsp;      this.value = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private StringLiteral(ImmutableTrees.StringLiteral original, String value) {
&nbsp;      this.value = value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code value} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String value() {
&nbsp;      return value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.StringLiteral#value() value} attribute.
&nbsp;     * An equals check used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for value
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.StringLiteral withValue(String value) {
&nbsp;      String newValue = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;      if (this.value.equals(newValue)) return this;
&nbsp;      return new ImmutableTrees.StringLiteral(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code StringLiteral} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.StringLiteral
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.StringLiteral) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.StringLiteral another) {
&nbsp;      return value.equals(another.value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code value}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + value.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code StringLiteral} instance.
&nbsp;     * @param value The value for the {@code value} attribute
&nbsp;     * @return An immutable StringLiteral instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.StringLiteral of(String value) {
&nbsp;      return new ImmutableTrees.StringLiteral(value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.StringLiteral} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable StringLiteral instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.StringLiteral copyOf(Trees.StringLiteral instance) {
&nbsp;      if (instance instanceof ImmutableTrees.StringLiteral) {
&nbsp;        return (ImmutableTrees.StringLiteral) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.StringLiteral.of(instance.value());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.Newline}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to get the default singleton instance:
&nbsp;   * {@code ImmutableTrees.Newline.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.Newline&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class Newline extends Trees.Newline {
&nbsp;
&nbsp;    private Newline() {}
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code Newline} that have equal attribute values.
&nbsp;     * As instances of the {@code Newline} class are interned, the {@code equals} method is implemented
&nbsp;     * as an efficient reference equality check.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      return this == another;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a constant hash code value.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      return -1911993872;
&nbsp;    }
&nbsp;
&nbsp;    private static final ImmutableTrees.Newline INSTANCE = new ImmutableTrees.Newline();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default immutable singleton value of {@code Newline}
&nbsp;     * @return An immutable instance of Newline
&nbsp;     */
&nbsp;    public static ImmutableTrees.Newline of() {
&nbsp;      return INSTANCE;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TextFragment}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the static factory method to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TextFragment.of()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TextFragment&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TextFragment extends Trees.TextFragment {
&nbsp;    private final String value;
&nbsp;
&nbsp;    private TextFragment(String value) {
&nbsp;      this.value = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private TextFragment(ImmutableTrees.TextFragment original, String value) {
&nbsp;      this.value = value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code value} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String value() {
&nbsp;      return value;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TextFragment#value() value} attribute.
&nbsp;     * An equals check used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for value
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TextFragment withValue(String value) {
&nbsp;      String newValue = Objects.requireNonNull(value, &quot;value&quot;);
&nbsp;      if (this.value.equals(newValue)) return this;
&nbsp;      return new ImmutableTrees.TextFragment(this, newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TextFragment} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TextFragment
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TextFragment) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TextFragment another) {
&nbsp;      return value.equals(another.value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code value}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + value.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a new immutable {@code TextFragment} instance.
&nbsp;     * @param value The value for the {@code value} attribute
&nbsp;     * @return An immutable TextFragment instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextFragment of(String value) {
&nbsp;      return new ImmutableTrees.TextFragment(value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TextFragment} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TextFragment instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextFragment copyOf(Trees.TextFragment instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TextFragment) {
&nbsp;        return (ImmutableTrees.TextFragment) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TextFragment.of(instance.value());
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TextBlock}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TextBlock.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TextBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TextBlock implements Trees.TextBlock {
&nbsp;    private final ImmutableList&lt;Trees.TextPart&gt; parts;
&nbsp;
&nbsp;    private TextBlock(ImmutableList&lt;Trees.TextPart&gt; parts) {
&nbsp;      this.parts = parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code parts} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ImmutableList&lt;Trees.TextPart&gt; parts() {
&nbsp;      return parts;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.TextBlock#parts() parts}.
&nbsp;     * @param elements The elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TextBlock withParts(Trees.TextPart... elements) {
&nbsp;      ImmutableList&lt;Trees.TextPart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.TextBlock(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object with elements that replace the content of {@link Trees.TextBlock#parts() parts}.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param elements An iterable of parts elements to set
&nbsp;     * @return A modified copy of {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TextBlock withParts(Iterable&lt;? extends Trees.TextPart&gt; elements) {
&nbsp;      if (this.parts == elements) return this;
&nbsp;      ImmutableList&lt;Trees.TextPart&gt; newValue = ImmutableList.copyOf(elements);
&nbsp;      return new ImmutableTrees.TextBlock(newValue);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TextBlock} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TextBlock
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TextBlock) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TextBlock another) {
&nbsp;      return parts.equals(another.parts);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code parts}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + parts.hashCode();
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints the immutable value {@code TextBlock} with attribute values.
&nbsp;     * @return A string representation of the value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;      return MoreObjects.toStringHelper(&quot;TextBlock&quot;)
&nbsp;          .omitNullValues()
&nbsp;          .add(&quot;parts&quot;, parts)
&nbsp;          .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TextBlock} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TextBlock instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextBlock copyOf(Trees.TextBlock instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TextBlock) {
&nbsp;        return (ImmutableTrees.TextBlock) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TextBlock.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.TextBlock TextBlock}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.TextBlock.builder()
&nbsp;     *    .addParts|addAllParts(org.immutables.generator.processor.Trees.TextPart) // {@link Trees.TextBlock#parts() parts} elements
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new TextBlock builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextBlock.Builder builder() {
&nbsp;      return new ImmutableTrees.TextBlock.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.TextBlock TextBlock}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.TextBlock&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private ImmutableList.Builder&lt;Trees.TextPart&gt; parts = ImmutableList.builder();
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code TextBlock} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * Collection elements and entries will be added, not replaced.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.TextBlock instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        addAllParts(instance.parts());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds one element to {@link Trees.TextBlock#parts() parts} list.
&nbsp;       * @param element A parts element
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TextPart element) {
&nbsp;        this.parts.add(element);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.TextBlock#parts() parts} list.
&nbsp;       * @param elements An array of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addParts(Trees.TextPart... elements) {
&nbsp;        this.parts.add(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * Sets or replaces all elements for {@link Trees.TextBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder parts(Iterable&lt;? extends Trees.TextPart&gt; elements) {
&nbsp;        this.parts = ImmutableList.builder();
&nbsp;        return addAllParts(elements);
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Adds elements to {@link Trees.TextBlock#parts() parts} list.
&nbsp;       * @param elements An iterable of parts elements
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder addAllParts(Iterable&lt;? extends Trees.TextPart&gt; elements) {
&nbsp;        this.parts.addAll(elements);
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.TextBlock TextBlock}.
&nbsp;       * @return An immutable instance of TextBlock
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.TextBlock build() {
&nbsp;        return new ImmutableTrees.TextBlock(parts.build());
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Immutable implementation of {@link Trees.TextLine}.
&nbsp;   * &lt;p&gt;
&nbsp;   * Use the builder to create immutable instances:
&nbsp;   * {@code ImmutableTrees.TextLine.builder()}.
&nbsp;   */
&nbsp;  @Generated(from = &quot;Trees.TextLine&quot;, generator = &quot;Immutables&quot;)
&nbsp;  @Immutable
&nbsp;  @CheckReturnValue
&nbsp;  public static final class TextLine extends Trees.TextLine {
&nbsp;    private final Trees.TextFragment fragment;
&nbsp;    private final boolean newline;
&nbsp;
&nbsp;    private TextLine(ImmutableTrees.TextLine.Builder builder) {
&nbsp;      this.fragment = builder.fragment;
&nbsp;      this.newline = builder.newlineIsSet()
&nbsp;          ? builder.newline
&nbsp;          : super.newline();
&nbsp;    }
&nbsp;
&nbsp;    private TextLine(Trees.TextFragment fragment, boolean newline) {
&nbsp;      this.fragment = fragment;
&nbsp;      this.newline = newline;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code fragment} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Trees.TextFragment fragment() {
&nbsp;      return fragment;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The value of the {@code newline} attribute
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean newline() {
&nbsp;      return newline;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TextLine#fragment() fragment} attribute.
&nbsp;     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for fragment
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TextLine withFragment(Trees.TextFragment value) {
&nbsp;      if (this.fragment == value) return this;
&nbsp;      Trees.TextFragment newValue = Objects.requireNonNull(value, &quot;fragment&quot;);
&nbsp;      return new ImmutableTrees.TextLine(newValue, this.newline);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy the current immutable object by setting a value for the {@link Trees.TextLine#newline() newline} attribute.
&nbsp;     * A value equality check is used to prevent copying of the same value by returning {@code this}.
&nbsp;     * @param value A new value for newline
&nbsp;     * @return A modified copy of the {@code this} object
&nbsp;     */
&nbsp;    public final ImmutableTrees.TextLine withNewline(boolean value) {
&nbsp;      if (this.newline == value) return this;
&nbsp;      return new ImmutableTrees.TextLine(this.fragment, value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This instance is equal to all instances of {@code TextLine} that have equal attribute values.
&nbsp;     * @return {@code true} if {@code this} is equal to {@code another} instance
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(@Nullable Object another) {
&nbsp;      if (this == another) return true;
&nbsp;      return another instanceof ImmutableTrees.TextLine
&nbsp;          &amp;&amp; equalTo((ImmutableTrees.TextLine) another);
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalTo(ImmutableTrees.TextLine another) {
&nbsp;      return fragment.equals(another.fragment)
&nbsp;          &amp;&amp; newline == another.newline;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a hash code from attributes: {@code fragment}, {@code newline}.
&nbsp;     * @return hashCode value
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
&nbsp;      @Var int h = 5381;
&nbsp;      h += (h &lt;&lt; 5) + fragment.hashCode();
&nbsp;      h += (h &lt;&lt; 5) + Booleans.hashCode(newline);
&nbsp;      return h;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an immutable copy of a {@link Trees.TextLine} value.
&nbsp;     * Uses accessors to get values to initialize the new immutable instance.
&nbsp;     * If an instance is already immutable, it is returned as is.
&nbsp;     * @param instance The instance to copy
&nbsp;     * @return A copied immutable TextLine instance
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextLine copyOf(Trees.TextLine instance) {
&nbsp;      if (instance instanceof ImmutableTrees.TextLine) {
&nbsp;        return (ImmutableTrees.TextLine) instance;
&nbsp;      }
&nbsp;      return ImmutableTrees.TextLine.builder()
&nbsp;          .from(instance)
&nbsp;          .build();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for {@link ImmutableTrees.TextLine TextLine}.
&nbsp;     * &lt;pre&gt;
&nbsp;     * ImmutableTrees.TextLine.builder()
&nbsp;     *    .fragment(org.immutables.generator.processor.Trees.TextFragment) // required {@link Trees.TextLine#fragment() fragment}
&nbsp;     *    .newline(boolean) // optional {@link Trees.TextLine#newline() newline}
&nbsp;     *    .build();
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @return A new TextLine builder
&nbsp;     */
&nbsp;    public static ImmutableTrees.TextLine.Builder builder() {
&nbsp;      return new ImmutableTrees.TextLine.Builder();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds instances of type {@link ImmutableTrees.TextLine TextLine}.
&nbsp;     * Initialize attributes and then invoke the {@link #build()} method to create an
&nbsp;     * immutable instance.
&nbsp;     * &lt;p&gt;&lt;em&gt;{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
&nbsp;     * but instead used immediately to create instances.&lt;/em&gt;
&nbsp;     */
&nbsp;    @Generated(from = &quot;Trees.TextLine&quot;, generator = &quot;Immutables&quot;)
&nbsp;    @NotThreadSafe
&nbsp;    public static final class Builder {
&nbsp;      private static final long INIT_BIT_FRAGMENT = 0x1L;
&nbsp;      private static final long OPT_BIT_NEWLINE = 0x1L;
&nbsp;      private long initBits = 0x1L;
&nbsp;      private long optBits;
&nbsp;
&nbsp;      private @Nullable Trees.TextFragment fragment;
&nbsp;      private boolean newline;
&nbsp;
&nbsp;      private Builder() {
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Fill a builder with attribute values from the provided {@code TextLine} instance.
&nbsp;       * Regular attribute values will be replaced with those from the given instance.
&nbsp;       * Absent optional values will not replace present values.
&nbsp;       * @param instance The instance from which to copy values
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder from(Trees.TextLine instance) {
&nbsp;        Objects.requireNonNull(instance, &quot;instance&quot;);
&nbsp;        fragment(instance.fragment());
&nbsp;        newline(instance.newline());
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TextLine#fragment() fragment} attribute.
&nbsp;       * @param fragment The value for fragment 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder fragment(Trees.TextFragment fragment) {
&nbsp;        this.fragment = Objects.requireNonNull(fragment, &quot;fragment&quot;);
&nbsp;        initBits &amp;= ~INIT_BIT_FRAGMENT;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Initializes the value for the {@link Trees.TextLine#newline() newline} attribute.
&nbsp;       * &lt;p&gt;&lt;em&gt;If not set, this attribute will have a default value as returned by the initializer of {@link Trees.TextLine#newline() newline}.&lt;/em&gt;
&nbsp;       * @param newline The value for newline 
&nbsp;       * @return {@code this} builder for use in a chained invocation
&nbsp;       */
&nbsp;      @CanIgnoreReturnValue 
&nbsp;      public final Builder newline(boolean newline) {
&nbsp;        this.newline = newline;
&nbsp;        optBits |= OPT_BIT_NEWLINE;
&nbsp;        return this;
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Builds a new {@link ImmutableTrees.TextLine TextLine}.
&nbsp;       * @return An immutable instance of TextLine
&nbsp;       * @throws java.lang.IllegalStateException if any required attributes are missing
&nbsp;       */
&nbsp;      public ImmutableTrees.TextLine build() {
&nbsp;        if (initBits != 0) {
&nbsp;          throw new IllegalStateException(formatRequiredAttributesMessage());
&nbsp;        }
&nbsp;        return new ImmutableTrees.TextLine(this);
&nbsp;      }
&nbsp;
&nbsp;      private boolean newlineIsSet() {
&nbsp;        return (optBits &amp; OPT_BIT_NEWLINE) != 0;
&nbsp;      }
&nbsp;
&nbsp;      private String formatRequiredAttributesMessage() {
&nbsp;        List&lt;String&gt; attributes = new ArrayList&lt;&gt;();
&nbsp;        if ((initBits &amp; INIT_BIT_FRAGMENT) != 0) attributes.add(&quot;fragment&quot;);
&nbsp;        return &quot;Cannot build TextLine, some of required attributes are not set &quot; + attributes;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
