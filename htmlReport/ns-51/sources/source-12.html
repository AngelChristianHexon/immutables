


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Instantiation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.encode</a>
</div>

<h1>Coverage Summary for Class: Instantiation (org.immutables.value.processor.encode)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Instantiation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/109)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/131)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Instantiation$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$10$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instantiation$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/139)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/212)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2016 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.encode;
&nbsp;
&nbsp;import com.google.common.base.CaseFormat;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Predicate;
&nbsp;import com.google.common.collect.FluentIterable;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableMap;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import javax.annotation.Nullable;
&nbsp;import org.immutables.generator.Templates;
&nbsp;import org.immutables.generator.Templates.Invokable;
&nbsp;import org.immutables.generator.Templates.Invokation;
&nbsp;import org.immutables.value.processor.encode.Code.Binding;
&nbsp;import org.immutables.value.processor.encode.Code.Term;
&nbsp;import org.immutables.value.processor.encode.EncodedElement.Param;
&nbsp;import org.immutables.value.processor.encode.EncodedElement.TypeParam;
&nbsp;import org.immutables.value.processor.encode.Type.Defined;
&nbsp;import org.immutables.value.processor.encode.Type.Parameters;
&nbsp;import org.immutables.value.processor.encode.Type.Variable;
&nbsp;import org.immutables.value.processor.encode.Type.VariableResolver;
&nbsp;import org.immutables.value.processor.meta.Styles;
&nbsp;import org.immutables.value.processor.meta.Styles.UsingName.AttributeNames;
&nbsp;import org.immutables.value.processor.meta.ValueType;
&nbsp;import static com.google.common.base.Preconditions.checkArgument;
&nbsp;
<b class="nc">&nbsp;public final class Instantiation {</b>
&nbsp;  private final Map&lt;Binding, String&gt; bindings;
&nbsp;  private final Map&lt;Binding, String&gt; builderBindings;
<b class="nc">&nbsp;  private final Map&lt;Binding, String&gt; deriveFieldBindings = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;  private final Map&lt;Binding, String&gt; thisFieldBindings = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;  final Type type;
&nbsp;  final EncodingInfo encoding;
&nbsp;  final EncodedElement expose;
&nbsp;
&nbsp;  // these exist as functions that can be applied from a template
&nbsp;  final VariableResolver typer;
&nbsp;  private final AttributeNames names;
&nbsp;  private final ValueType containingType;
&nbsp;  private final boolean shimFields;
&nbsp;
&nbsp;  Instantiation(
&nbsp;      EncodingInfo encoding,
&nbsp;      EncodedElement expose,
&nbsp;      Type exposedType,
&nbsp;      Styles.UsingName.AttributeNames names,
&nbsp;      VariableResolver resolver,
&nbsp;      ValueType containingType,
<b class="nc">&nbsp;      boolean shimFields) {</b>
<b class="nc">&nbsp;    this.encoding = encoding;</b>
<b class="nc">&nbsp;    this.expose = expose;</b>
<b class="nc">&nbsp;    this.type = exposedType;</b>
<b class="nc">&nbsp;    this.names = names;</b>
<b class="nc">&nbsp;    this.typer = resolver;</b>
<b class="nc">&nbsp;    this.containingType = containingType;</b>
<b class="nc">&nbsp;    this.shimFields = shimFields;</b>
&nbsp;
<b class="nc">&nbsp;    this.bindings = new HashMap&lt;&gt;(encoding.element().size());</b>
<b class="nc">&nbsp;    this.builderBindings = new HashMap&lt;&gt;(encoding.element().size());</b>
&nbsp;
<b class="nc">&nbsp;    populateBindings(resolver);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void populateBindings(VariableResolver resolver) {
<b class="nc">&nbsp;    if (hasVirtualImpl()) {</b>
<b class="nc">&nbsp;      deriveFieldBindings.put(encoding.impl().asBinding(), getDecoratedImplFieldName());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    for (EncodedElement e : encoding.element()) {</b>
<b class="nc">&nbsp;      if (e.isStatic()) {</b>
<b class="nc">&nbsp;        if (e.inBuilder()) {</b>
<b class="nc">&nbsp;          builderBindings.put(e.asBinding(), generateProperName(e));</b>
&nbsp;        } else {
&nbsp;          // statics from value are visible in builder
<b class="nc">&nbsp;          builderBindings.put(e.asBinding(), generateProperName(e));</b>
<b class="nc">&nbsp;          bindings.put(e.asBinding(), generateProperName(e));</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    for (EncodedElement e : encoding.element()) {</b>
<b class="nc">&nbsp;      if (!e.isStatic()) {</b>
<b class="nc">&nbsp;        if (e.inBuilder()) {</b>
<b class="nc">&nbsp;          builderBindings.put(e.asBinding(), generateProperName(e));</b>
<b class="nc">&nbsp;        } else if (isShimField(e)) {</b>
<b class="nc">&nbsp;          bindings.put(e.asBinding(), generateShimAccess(e));</b>
<b class="nc">&nbsp;          if (e.isValueField() || e.isImplField()) {</b>
<b class="nc">&nbsp;            thisFieldBindings.put(e.asBinding(), directThisFieldName(e));</b>
&nbsp;          }
<b class="nc">&nbsp;          if (e.isValueField()) {</b>
<b class="nc">&nbsp;            deriveFieldBindings.put(e.asBinding(), directFieldName(e));</b>
&nbsp;          }
&nbsp;        } else {
<b class="nc">&nbsp;          bindings.put(e.asBinding(), generateProperName(e));</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    for (Variable v : resolver.variables()) {</b>
<b class="nc">&nbsp;      Binding binding = Binding.newTop(v.name);</b>
<b class="nc">&nbsp;      String value = resolver.apply(v).toString();</b>
<b class="nc">&nbsp;      bindings.put(binding, value);</b>
<b class="nc">&nbsp;      builderBindings.put(binding, value);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private String generateShimAccess(EncodedElement e) {
<b class="nc">&nbsp;    return shimName(e) + &quot;()&quot;; // it safe to append parenheses to field access, not for methods</b>
&nbsp;  }
&nbsp;
&nbsp;  private String shimName(EncodedElement e) {
<b class="nc">&nbsp;    return directFieldName(e) + &quot;$shim&quot;;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  final Function&lt;EncodedElement, String&gt; directField = new Function&lt;EncodedElement, String&gt;() {</b>
&nbsp;    @Override
&nbsp;    public String apply(EncodedElement e) {
<b class="nc">&nbsp;      return isShimField(e)</b>
<b class="nc">&nbsp;          ? directFieldName(e)</b>
<b class="nc">&nbsp;          : namer.apply(e);</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Function&lt;EncodedElement, String&gt; shimName = new Function&lt;EncodedElement, String&gt;() {</b>
&nbsp;    @Override
&nbsp;    public String apply(EncodedElement input) {
<b class="nc">&nbsp;      return shimName(input);</b>
&nbsp;    }
&nbsp;  };
&nbsp;
&nbsp;  public boolean shimFields() {
<b class="nc">&nbsp;    return shimFields;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String directFieldName(EncodedElement e) {
<b class="nc">&nbsp;    checkArgument(e.isValueField() || e.isImplField());</b>
<b class="nc">&nbsp;    return e.isImplField()</b>
<b class="nc">&nbsp;        ? names.var</b>
<b class="nc">&nbsp;        : names.apply(e.naming(), false);</b>
&nbsp;  }
&nbsp;
&nbsp;  private String directThisFieldName(EncodedElement e) {
<b class="nc">&nbsp;    return &quot;this.&quot; + directFieldName(e);</b>
&nbsp;  }
&nbsp;
&nbsp;  protected boolean isShimField(EncodedElement e) {
<b class="nc">&nbsp;    return shimFields &amp;&amp; (e.isValueField() || e.isImplField());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasTrivialFrom() {
<b class="nc">&nbsp;    ImmutableList&lt;Term&gt; oneLiner = encoding.from().oneLiner();</b>
<b class="nc">&nbsp;    return oneLiner.size() == 1</b>
<b class="nc">&nbsp;        &amp;&amp; oneLiner.get(0).equals(</b>
<b class="nc">&nbsp;            Binding.newTop(encoding.from().firstParam().name()));</b>
&nbsp;  }
&nbsp;
&nbsp;  public String getDecoratedImplFieldName() {
<b class="nc">&nbsp;    return directFieldName(encoding.impl()) + &quot;$impl&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasValueOrVirtualFields() {
<b class="nc">&nbsp;    if (encoding.impl().isVirtual()) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    for (EncodedElement e : encoding.element()) {</b>
<b class="nc">&nbsp;      if (e.isValueField()) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  public List&lt;String&gt; exposeDoc() {
<b class="nc">&nbsp;    return expose.doc();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean hasVirtualImpl() {
<b class="nc">&nbsp;    return encoding.impl().isVirtual();</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean supportsInternalImplConstructor() {
<b class="nc">&nbsp;    return encoding.build().type().equals(encoding.impl().type());</b>
&nbsp;  }
&nbsp;
&nbsp;  public boolean supportsDefaultValue() {
<b class="nc">&nbsp;    return !encoding.impl().code().isEmpty();</b>
&nbsp;  }
&nbsp;
&nbsp;  private String generateProperName(EncodedElement element) {
<b class="nc">&nbsp;    if (element.isImplField()) {</b>
<b class="nc">&nbsp;      return names.var;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (element.isExpose()) {</b>
<b class="nc">&nbsp;      return names.get;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (element.standardNaming() != StandardNaming.NONE) {</b>
<b class="nc">&nbsp;      switch (element.standardNaming()) {</b>
&nbsp;      case GET:
<b class="nc">&nbsp;        return names.get;</b>
&nbsp;      case INIT:
<b class="nc">&nbsp;        return names.init;</b>
&nbsp;      case ADD:
<b class="nc">&nbsp;        return names.add();</b>
&nbsp;      case ADD_ALL:
<b class="nc">&nbsp;        return names.addAll();</b>
&nbsp;      case PUT:
<b class="nc">&nbsp;        return names.put();</b>
&nbsp;      case PUT_ALL:
<b class="nc">&nbsp;        return names.putAll();</b>
&nbsp;      case WITH:
<b class="nc">&nbsp;        return names.with;</b>
&nbsp;      default:
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (isDefaultUnspecifiedValue(element)) {</b>
<b class="nc">&nbsp;      if (element.isCopy()) {</b>
<b class="nc">&nbsp;        return names.with;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (element.isInit()) {</b>
<b class="nc">&nbsp;        return names.init;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (element.isStaticField() &amp;&amp; element.isFinal()) {</b>
<b class="nc">&nbsp;      String base = CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, rawName());</b>
<b class="nc">&nbsp;      return element.naming().apply(base);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return names.apply(element.naming(), element.depluralize());</b>
&nbsp;  }
&nbsp;
&nbsp;  private String rawName() {
<b class="nc">&nbsp;    return names.raw;</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  final Function&lt;EncodedElement, String&gt; namer = new Function&lt;EncodedElement, String&gt;() {</b>
&nbsp;    @Override
&nbsp;    public String apply(EncodedElement input) {
<b class="nc">&nbsp;      return input.inBuilder()</b>
<b class="nc">&nbsp;          ? builderBindings.get(input.asBinding())</b>
<b class="nc">&nbsp;          : bindings.get(input.asBinding());</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Predicate&lt;EncodedElement&gt; isInlined = new Predicate&lt;EncodedElement&gt;() {</b>
&nbsp;    @Override
&nbsp;    public boolean apply(EncodedElement input) {
<b class="nc">&nbsp;      return isInlined(input);</b>
&nbsp;    }
&nbsp;  };
&nbsp;
&nbsp;  private boolean isInlined(EncodedElement el) {
<b class="nc">&nbsp;    return el.isInlinable()</b>
<b class="nc">&nbsp;        &amp;&amp; !el.oneLiner().isEmpty()</b>
<b class="nc">&nbsp;        &amp;&amp; !encoding.crossReferencedMethods().contains(el.name())</b>
<b class="nc">&nbsp;        &amp;&amp; !entangledBuildMethod(el);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean entangledBuildMethod(EncodedElement el) {
<b class="nc">&nbsp;    return el.isBuild() &amp;&amp; containingType.isGenerateBuilderConstructor();</b>
&nbsp;  }
&nbsp;
&nbsp;  public ValueType getContainingType() {
<b class="nc">&nbsp;    return containingType;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isDefaultUnspecifiedValue(EncodedElement element) {
<b class="nc">&nbsp;    return element.naming().isIdentity() &amp;&amp; !element.depluralize();</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  public final Function&lt;String, String&gt; filterDoc = new Function&lt;String, String&gt;() {</b>
&nbsp;    @Override
&nbsp;    public String apply(String input) {
<b class="nc">&nbsp;      return input.replace(&quot;&lt;*&gt;&quot;, names.var);</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Templates.Invokable fragmentOf = new Templates.Invokable() {</b>
&nbsp;    @Override
&nbsp;    public @Nullable Invokable invoke(Invokation invokation, Object... parameters) {
<b class="nc">&nbsp;      EncodedElement el = (EncodedElement) parameters[0];</b>
&nbsp;
<b class="nc">&nbsp;      @Nullable Map&lt;Binding, String&gt; overrideBindings = null;</b>
<b class="nc">&nbsp;      if (el.params().size() == 1 &amp;&amp; parameters.length &gt; 1) {</b>
<b class="nc">&nbsp;        overrideBindings = ImmutableMap.of(</b>
<b class="nc">&nbsp;            Binding.newTop(el.firstParam().name()),</b>
<b class="nc">&nbsp;            parameters[1].toString());</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Map&lt;Binding, String&gt; contextBindings = el.inBuilder() ? builderBindings : bindings;</b>
<b class="nc">&nbsp;      Code.Interpolator interpolator =</b>
<b class="nc">&nbsp;          new Code.Interpolator(rawName(), contextBindings, overrideBindings);</b>
&nbsp;
<b class="nc">&nbsp;      if (isInlined(el)) {</b>
<b class="nc">&nbsp;        printWithIndentation(invokation, interpolator.apply(el.oneLiner()));</b>
&nbsp;      } else {
<b class="nc">&nbsp;        invokation.out(contextBindings.get(el.asBinding())).out(&quot;(&quot;);</b>
<b class="nc">&nbsp;        boolean notFirst = false;</b>
<b class="nc">&nbsp;        for (Param p : el.params()) {</b>
<b class="nc">&nbsp;          if (notFirst) {</b>
<b class="nc">&nbsp;            invokation.out(&quot;, &quot;);</b>
&nbsp;          }
<b class="nc">&nbsp;          notFirst = true;</b>
<b class="nc">&nbsp;          Binding binding = Code.Binding.newTop(p.name());</b>
<b class="nc">&nbsp;          invokation.out(interpolator.dereference(binding));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        invokation.out(&quot;)&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Templates.Invokable codeOf = new Templates.Invokable() {</b>
&nbsp;    @Override
&nbsp;    public @Nullable Invokable invoke(Invokation invokation, Object... parameters) {
<b class="nc">&nbsp;      EncodedElement el = (EncodedElement) parameters[0];</b>
&nbsp;
<b class="nc">&nbsp;      Map&lt;Binding, String&gt; contextBindings = el.inBuilder() ? builderBindings : bindings;</b>
&nbsp;
<b class="nc">&nbsp;      List&lt;Term&gt; code = el.code();</b>
&nbsp;
<b class="nc">&nbsp;      if (parameters.length &gt;= 2) {</b>
<b class="nc">&nbsp;        String param = parameters[1].toString();</b>
<b class="nc">&nbsp;        code = Code.replaceReturn(code, param);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Code.Interpolator interpolator =</b>
<b class="nc">&nbsp;          new Code.Interpolator(rawName(), contextBindings, null);</b>
&nbsp;
<b class="nc">&nbsp;      printWithIndentation(invokation, interpolator.apply(code));</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Templates.Invokable codeThisFields = new Templates.Invokable() {</b>
&nbsp;    @Override
&nbsp;    public @Nullable Invokable invoke(Invokation invokation, Object... parameters) {
<b class="nc">&nbsp;      interpolateAndPrint(invokation, (EncodedElement) parameters[0], thisFieldBindings);</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  };
&nbsp;
<b class="nc">&nbsp;  final Templates.Invokable codeDeriveFields = new Templates.Invokable() {</b>
&nbsp;    @Override
&nbsp;    public @Nullable Invokable invoke(Invokation invokation, Object... parameters) {
<b class="nc">&nbsp;      interpolateAndPrint(invokation, (EncodedElement) parameters[0], deriveFieldBindings);</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  };
&nbsp;
&nbsp;  private void interpolateAndPrint(Invokation invokation, EncodedElement el, Map&lt;Binding, String&gt; overrides) {
<b class="nc">&nbsp;    Code.Interpolator interpolator =</b>
&nbsp;        new Code.Interpolator(
<b class="nc">&nbsp;            rawName(),</b>
&nbsp;            bindings,
&nbsp;            overrides);
&nbsp;
<b class="nc">&nbsp;    printWithIndentation(invokation, interpolator.apply(el.code()));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void printWithIndentation(Invokation invokation, List&lt;Term&gt; terms) {
<b class="nc">&nbsp;    int indentLevel = 0;</b>
<b class="nc">&nbsp;    int indentWrap = 0;</b>
<b class="nc">&nbsp;    boolean nextNewline = false;</b>
&nbsp;
<b class="nc">&nbsp;    for (Code.Term t : terms) {</b>
<b class="nc">&nbsp;      if (t.isWhitespace() &amp;&amp; t.is(&#39;\n&#39;)) {</b>
<b class="nc">&nbsp;        nextNewline = true;</b>
<b class="nc">&nbsp;        continue;</b>
&nbsp;      }
&nbsp;
&nbsp;      // decrease indent level before writing a newline
<b class="nc">&nbsp;      if (t.isDelimiter() &amp;&amp; t.is(&#39;}&#39;)) {</b>
<b class="nc">&nbsp;        indentLevel--;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (nextNewline) {</b>
<b class="nc">&nbsp;        nextNewline = false;</b>
<b class="nc">&nbsp;        invokation.ln();</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; indentLevel + indentWrap; i++) {</b>
<b class="nc">&nbsp;          invokation.out(&quot;  &quot;);</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (t.isDelimiter() &amp;&amp; (t.is(&#39;;&#39;) || t.is(&#39;}&#39;) || t.is(&#39;{&#39;))) {</b>
<b class="nc">&nbsp;        indentWrap = 0;</b>
<b class="nc">&nbsp;      } else if (!t.isIgnorable()) {</b>
&nbsp;        // auto-increase indent wrap unless semicolon will return it back
<b class="nc">&nbsp;        indentWrap = 2;</b>
&nbsp;      }
&nbsp;
&nbsp;      // increase indent level after writing a newline
<b class="nc">&nbsp;      if (t.isDelimiter() &amp;&amp; t.is(&#39;{&#39;)) {</b>
<b class="nc">&nbsp;        indentLevel++;</b>
&nbsp;      }
&nbsp;
&nbsp;      // outputing actual token after any indents
<b class="nc">&nbsp;      invokation.out(t);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  final Function&lt;EncodedElement, String&gt; ownTypeParams =</b>
<b class="nc">&nbsp;      new Function&lt;EncodedElement, String&gt;() {</b>
&nbsp;        @Override
&nbsp;        public String apply(EncodedElement input) {
<b class="nc">&nbsp;          Parameters parameters = Type.Producer.emptyParameters();</b>
&nbsp;
&nbsp;          // if our method have the same named type parameters as
&nbsp;          // encoding, when instantiating it for specific
&nbsp;          // attribute, some may resolve to concrete types, some
&nbsp;          // may end up value-type specific type parameter
&nbsp;          // we need to write only type-specific type parameters omiting those
&nbsp;          // which resolves to specific type.
&nbsp;          // note that some methods are to be inlined, so this is not needed
&nbsp;          // then, it is only needed when non-inlined references are present.
&nbsp;
<b class="nc">&nbsp;          if (input.isFrom()) {</b>
&nbsp;            // from has implied type parameters, the same as encoding
<b class="nc">&nbsp;            for (Variable v : typer.variables()) {</b>
<b class="nc">&nbsp;              parameters = introduceAsEncodingVar(parameters, v);</b>
&nbsp;            }
&nbsp;          } else {
<b class="nc">&nbsp;            for (TypeParam p : input.typeParams()) {</b>
<b class="nc">&nbsp;              @Nullable Variable encodingVar = typer.byName(p.name());</b>
<b class="nc">&nbsp;              if (encodingVar != null) {</b>
<b class="nc">&nbsp;                parameters = introduceAsEncodingVar(parameters, encodingVar);</b>
&nbsp;              } else {
<b class="nc">&nbsp;                parameters = parameters.introduce(p.name(), transformBounds(p.bounds()));</b>
&nbsp;              }
<b class="nc">&nbsp;            }</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          if (parameters.names().isEmpty()) {</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          return parameters + &quot; &quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        private Parameters introduceAsEncodingVar(Parameters parameters, Variable encodingVar) {
<b class="nc">&nbsp;          Type t = typer.apply(encodingVar);</b>
<b class="nc">&nbsp;          final Parameters[] pHolder = new Parameters[] {parameters};</b>
<b class="nc">&nbsp;          t.accept(new Type.Transformer() {</b>
&nbsp;            @Override
&nbsp;            public Type variable(Variable v) {
<b class="nc">&nbsp;              pHolder[0] = pHolder[0].introduce(v.name, transformBounds(v.upperBounds));</b>
<b class="nc">&nbsp;              return v;</b>
&nbsp;            }
&nbsp;          });
<b class="nc">&nbsp;          parameters = pHolder[0];</b>
<b class="nc">&nbsp;          return parameters;</b>
&nbsp;        }
&nbsp;
&nbsp;        private ImmutableList&lt;Defined&gt; transformBounds(List&lt;Defined&gt; bounds) {
<b class="nc">&nbsp;          return FluentIterable.from(bounds)</b>
<b class="nc">&nbsp;              .transform(typer)</b>
<b class="nc">&nbsp;              .filter(Defined.class)</b>
<b class="nc">&nbsp;              .toList();</b>
&nbsp;        }
&nbsp;      };
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return type + &quot;(by &quot; + encoding.name() + &quot;)&quot;;</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
