


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Type</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.encode</a>
</div>

<h1>Coverage Summary for Class: Type (org.immutables.value.processor.encode)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Type</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Type$Array</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Defined</td>
  </tr>
  <tr>
    <td class="name">Type$Factory</td>
  </tr>
  <tr>
    <td class="name">Type$Nonprimitive</td>
  </tr>
  <tr>
    <td class="name">Type$Parameterized</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Parameters</td>
  </tr>
  <tr>
    <td class="name">Type$Parser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Parser$1Reader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/93)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Primitive</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Print</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Producer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Producer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Producer$DefinedParameters</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Reference</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Template</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Template$1Decomposer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Transformer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Variable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$VariableResolver</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Visitor</td>
  </tr>
  <tr>
    <td class="name">Type$Wildcard</td>
  </tr>
  <tr>
    <td class="name">Type$Wildcard$Extends</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Type$Wildcard$Super</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/117)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/158)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/366)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2016 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.encode;
&nbsp;
&nbsp;import com.google.common.base.Ascii;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Joiner;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableMap;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Deque;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import javax.annotation.Nullable;
&nbsp;import javax.annotation.concurrent.ThreadSafe;
&nbsp;import org.immutables.value.processor.encode.Code.Term;
&nbsp;
&nbsp;/**
&nbsp; * I&#39;ve created this type model as an experiment which I want to bring forward and evolve
&nbsp; * into something more general purpose, probably, an utility library some day.
&nbsp; * The idea here is to give practical, yet accurate depiction of the type system in java using
&nbsp; * immutable types, being lightweight, efficient and easy to analyse and transform. Apparently,
&nbsp; * neither {@code java.lang.reflect} nor {@code javax.lang.model} (nor any 3rd party lib I&#39;ve seen)
&nbsp; * are not suitable for anything I want to do.
&nbsp; * &lt;p&gt;
&nbsp; * What we tried to avoid:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Compicated reverse references and mutability&lt;/li&gt;
&nbsp; * &lt;li&gt;Idealism and unrealistic overgeneralization ({@link java.lang.reflect.WildcardType}
&nbsp; * anyone?)&lt;/li&gt;
&nbsp; * &lt;li&gt;Complicated types like intersection or unions where we get without them&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * Moreover we are only concerned with the types in signatures, not a whole spectre of types which
&nbsp; * might occur in java code.
&nbsp; */
&nbsp;public interface Type {
<b class="nc">&nbsp;  Reference OBJECT = Reference.OBJECT;</b>
&nbsp;
&nbsp;  &lt;V&gt; V accept(Visitor&lt;V&gt; visitor);
&nbsp;
&nbsp;  interface Visitor&lt;V&gt; {
&nbsp;    V primitive(Primitive primitive);
&nbsp;
&nbsp;    V reference(Reference reference);
&nbsp;
&nbsp;    V parameterized(Parameterized parameterized);
&nbsp;
&nbsp;    V variable(Variable variable);
&nbsp;
&nbsp;    V array(Array array);
&nbsp;
&nbsp;    V superWildcard(Wildcard.Super wildcard);
&nbsp;
&nbsp;    V extendsWildcard(Wildcard.Extends wildcard);
&nbsp;  }
&nbsp;
&nbsp;  interface Nonprimitive extends Type {}
&nbsp;
&nbsp;  interface Defined extends Nonprimitive {}
&nbsp;
&nbsp;  class Reference implements Defined {
<b class="nc">&nbsp;    public static final Reference OBJECT = new Reference(Object.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference STRING = new Reference(String.class.getName(), true);</b>
&nbsp;
<b class="nc">&nbsp;    public static final Reference BYTE = new Reference(Short.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference SHORT = new Reference(Short.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference INTEGER = new Reference(Integer.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference LONG = new Reference(Long.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference DOUBLE = new Reference(Double.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference FLOAT = new Reference(Float.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference CHARACTER = new Reference(Character.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference BOOLEAN = new Reference(Boolean.class.getName(), true);</b>
<b class="nc">&nbsp;    public static final Reference VOID = new Reference(Void.class.getName(), true);</b>
&nbsp;
&nbsp;    public final String name;
&nbsp;    public final boolean resolved;
&nbsp;
<b class="nc">&nbsp;    Reference(String name, boolean resolved) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.resolved = resolved;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;      return visitor.reference(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return accept(new Print()).toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  class Array extends Eq&lt;Array&gt; implements Nonprimitive {
&nbsp;    public final Type element;
&nbsp;    public final boolean varargs;
&nbsp;
&nbsp;    Array(Type element, boolean varargs) {
<b class="nc">&nbsp;      super(element, varargs);</b>
<b class="nc">&nbsp;      if (element instanceof Wildcard) {</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Wildcard as array element is not allowed: &quot; + element);</b>
&nbsp;      }
<b class="nc">&nbsp;      this.element = element;</b>
<b class="nc">&nbsp;      this.varargs = varargs;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected boolean eq(Array other) {
<b class="nc">&nbsp;      return element.equals(other.element)</b>
&nbsp;          &amp;&amp; varargs == other.varargs;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;      return visitor.array(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return accept(new Print()).toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  class Variable implements Defined {
&nbsp;    public final String name;
&nbsp;    public final List&lt;Defined&gt; upperBounds;
&nbsp;    public final boolean recursive;
&nbsp;
<b class="nc">&nbsp;    Variable(String name, List&lt;Defined&gt; upperBounds, boolean recursive) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.upperBounds = upperBounds;</b>
<b class="nc">&nbsp;      this.recursive = recursive;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean isUnbounded() {
<b class="nc">&nbsp;      return upperBounds.isEmpty()</b>
<b class="nc">&nbsp;          || upperBounds.equals(ImmutableList.of(OBJECT));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;      return visitor.variable(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return accept(new Print()).toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  class Parameterized extends Eq&lt;Parameterized&gt; implements Defined {
&nbsp;    public final Reference reference;
&nbsp;    public final List&lt;Nonprimitive&gt; arguments;
&nbsp;
&nbsp;    Parameterized(Reference reference, List&lt;Nonprimitive&gt; arguments) {
<b class="nc">&nbsp;      super(reference, arguments);</b>
<b class="nc">&nbsp;      this.reference = reference;</b>
<b class="nc">&nbsp;      this.arguments = arguments;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected boolean eq(Parameterized other) {
<b class="nc">&nbsp;      return reference.equals(other.reference)</b>
<b class="nc">&nbsp;          &amp;&amp; arguments.equals(other.arguments);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;      return visitor.parameterized(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return accept(new Print()).toString();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  interface Wildcard extends Nonprimitive {
&nbsp;    class Super extends Eq&lt;Super&gt; implements Wildcard {
&nbsp;      public final Defined lowerBound;
&nbsp;
&nbsp;      Super(Defined lowerBound) {
<b class="nc">&nbsp;        super(lowerBound);</b>
<b class="nc">&nbsp;        this.lowerBound = lowerBound;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected boolean eq(Super other) {
<b class="nc">&nbsp;        return lowerBound.equals(other.lowerBound);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;        return visitor.superWildcard(this);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public String toString() {
<b class="nc">&nbsp;        return accept(new Print()).toString();</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    class Extends extends Eq&lt;Extends&gt; implements Wildcard {
&nbsp;      public final Defined upperBound;
&nbsp;
&nbsp;      Extends(Defined upperBound) {
<b class="nc">&nbsp;        super(upperBound);</b>
<b class="nc">&nbsp;        this.upperBound = upperBound;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      protected boolean eq(Extends other) {
<b class="nc">&nbsp;        return upperBound.equals(other.upperBound);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;        return visitor.extendsWildcard(this);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public String toString() {
<b class="nc">&nbsp;        return accept(new Print()).toString();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  enum Primitive implements Type {</b>
<b class="nc">&nbsp;    BOOLEAN(Reference.BOOLEAN, &quot;false&quot;),</b>
<b class="nc">&nbsp;    BYTE(Reference.BYTE, &quot;0&quot;),</b>
<b class="nc">&nbsp;    SHORT(Reference.SHORT, &quot;0&quot;),</b>
<b class="nc">&nbsp;    INT(Reference.INTEGER, &quot;0&quot;),</b>
<b class="nc">&nbsp;    LONG(Reference.LONG, &quot;0L&quot;),</b>
<b class="nc">&nbsp;    CHAR(Reference.CHARACTER, &quot;&#39;\0&#39;&quot;),</b>
<b class="nc">&nbsp;    FLOAT(Reference.FLOAT, &quot;0F&quot;),</b>
<b class="nc">&nbsp;    DOUBLE(Reference.DOUBLE, &quot;0D&quot;),</b>
<b class="nc">&nbsp;    VOID(Reference.VOID, &quot;&quot;);</b>
&nbsp;
&nbsp;    public final String typename;
&nbsp;    public final Reference wrapper;
&nbsp;    public final String defaultValue;
&nbsp;
<b class="nc">&nbsp;    Primitive(Reference wrapper, String defaultValue) {</b>
<b class="nc">&nbsp;      this.wrapper = wrapper;</b>
<b class="nc">&nbsp;      this.typename = Ascii.toLowerCase(name());</b>
<b class="nc">&nbsp;      this.defaultValue = defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;V&gt; V accept(Visitor&lt;V&gt; visitor) {
<b class="nc">&nbsp;      return visitor.primitive(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return typename;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Nonprimitive asNonprimitive(Type type) {
<b class="nc">&nbsp;      if (type instanceof Primitive) {</b>
<b class="nc">&nbsp;        return ((Primitive) type).wrapper;</b>
&nbsp;      }
<b class="nc">&nbsp;      return (Nonprimitive) type;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  interface Parameters {
&nbsp;    Parameters introduce(String name, Iterable&lt;? extends Defined&gt; upperBounds);
&nbsp;
&nbsp;    Parameters recursive(String name);
&nbsp;
&nbsp;    List&lt;String&gt; names();
&nbsp;
&nbsp;    Variable variable(String name);
&nbsp;  }
&nbsp;
&nbsp;  interface Factory {
&nbsp;    Primitive primitive(String name);
&nbsp;
&nbsp;    Reference reference(String name);
&nbsp;
&nbsp;    Reference unresolved(String name);
&nbsp;
&nbsp;    Parameterized parameterized(Reference raw, Iterable&lt;? extends Nonprimitive&gt; arguments);
&nbsp;
&nbsp;    Array array(Type element);
&nbsp;
&nbsp;    Array varargs(Type element);
&nbsp;
&nbsp;    Wildcard.Super superWildcard(Defined lowerBound);
&nbsp;
&nbsp;    Wildcard.Extends extendsWildcard(Defined upperBound);
&nbsp;
&nbsp;    Parameters parameters();
&nbsp;  }
&nbsp;
&nbsp;  class Print implements Visitor&lt;StringBuilder&gt; {
&nbsp;    private final StringBuilder builder;
&nbsp;
&nbsp;    Print() {
<b class="nc">&nbsp;      this(new StringBuilder());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Print(StringBuilder builder) {</b>
<b class="nc">&nbsp;      this.builder = builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder primitive(Primitive primitive) {
<b class="nc">&nbsp;      return builder.append(primitive);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder reference(Reference reference) {
<b class="nc">&nbsp;      return builder.append(reference.name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder parameterized(Parameterized parameterized) {
<b class="nc">&nbsp;      parameterized.reference.accept(this);</b>
<b class="nc">&nbsp;      builder.append(&#39;&lt;&#39;);</b>
<b class="nc">&nbsp;      printSeparated(parameterized.arguments, &quot;, &quot;);</b>
<b class="nc">&nbsp;      return builder.append(&#39;&gt;&#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder variable(Variable variable) {
<b class="nc">&nbsp;      return builder.append(variable.name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder array(Array array) {
<b class="nc">&nbsp;      array.element.accept(this);</b>
<b class="nc">&nbsp;      return builder.append(array.varargs ? &quot;...&quot; : &quot;[]&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder superWildcard(Wildcard.Super wildcard) {
<b class="nc">&nbsp;      builder.append(&quot;? super &quot;);</b>
<b class="nc">&nbsp;      return wildcard.lowerBound.accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StringBuilder extendsWildcard(Wildcard.Extends wildcard) {
<b class="nc">&nbsp;      if (wildcard.upperBound == OBJECT) {</b>
<b class="nc">&nbsp;        return builder.append(&quot;?&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      builder.append(&quot;? extends &quot;);</b>
<b class="nc">&nbsp;      return wildcard.upperBound.accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      return builder.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void printSeparated(Iterable&lt;? extends Type&gt; types, String separator) {
<b class="nc">&nbsp;      boolean notFirst = false;</b>
<b class="nc">&nbsp;      for (Type t : types) {</b>
<b class="nc">&nbsp;        if (notFirst) {</b>
<b class="nc">&nbsp;          builder.append(separator);</b>
&nbsp;        }
<b class="nc">&nbsp;        notFirst = true;</b>
<b class="nc">&nbsp;        t.accept(this);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @ThreadSafe
<b class="nc">&nbsp;  class Producer implements Type.Factory {</b>
&nbsp;    static final Map&lt;String, Primitive&gt; PRIMITIVE_TYPES;
&nbsp;    static {
<b class="nc">&nbsp;      ImmutableMap.Builder&lt;String, Primitive&gt; primitives = ImmutableMap.builder();</b>
<b class="nc">&nbsp;      for (Primitive p : Primitive.values()) {</b>
<b class="nc">&nbsp;        primitives.put(p.typename, p);</b>
&nbsp;      }
<b class="nc">&nbsp;      PRIMITIVE_TYPES = primitives.build();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Parameters EMPTY_PARAMETERS = new Parameters() {</b>
&nbsp;      @Override
&nbsp;      public Variable variable(String name) {
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;no such type parameter &#39;&quot; + name + &quot;&#39; defined in &quot; + this);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public Parameters introduce(String name, Iterable&lt;? extends Defined&gt; upperBounds) {
<b class="nc">&nbsp;        return new DefinedParameters(null, name, ImmutableList.copyOf(upperBounds), false);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public Parameters recursive(String name) {
<b class="nc">&nbsp;        return new DefinedParameters(null, name, ImmutableList.&lt;Defined&gt;of(), true);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public List&lt;String&gt; names() {
<b class="nc">&nbsp;        return ImmutableList.of();</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public String toString() {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;      }
&nbsp;    };
&nbsp;
&nbsp;    static Parameters emptyParameters() {
<b class="nc">&nbsp;      return EMPTY_PARAMETERS;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;String, Reference&gt; resolvedTypes = new HashMap&lt;&gt;(64);</b>
&nbsp;    {
<b class="nc">&nbsp;      synchronized (resolvedTypes) {</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.OBJECT.name, Reference.OBJECT);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.STRING.name, Reference.STRING);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.BYTE.name, Reference.BYTE);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.SHORT.name, Reference.SHORT);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.INTEGER.name, Reference.INTEGER);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.LONG.name, Reference.LONG);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.DOUBLE.name, Reference.DOUBLE);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.FLOAT.name, Reference.FLOAT);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.CHARACTER.name, Reference.CHARACTER);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.BOOLEAN.name, Reference.BOOLEAN);</b>
<b class="nc">&nbsp;        resolvedTypes.put(Reference.VOID.name, Reference.VOID);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Primitive primitive(String name) {
<b class="nc">&nbsp;      @Nullable Primitive type = PRIMITIVE_TYPES.get(name);</b>
<b class="nc">&nbsp;      Preconditions.checkArgument(type != null, &quot;wrong primitive type name %s&quot;, name);</b>
<b class="nc">&nbsp;      return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Reference reference(String name) {
<b class="nc">&nbsp;      synchronized (resolvedTypes) {</b>
<b class="nc">&nbsp;        Reference type = resolvedTypes.get(name);</b>
<b class="nc">&nbsp;        if (type == null) {</b>
<b class="nc">&nbsp;          type = new Reference(name, true);</b>
<b class="nc">&nbsp;          resolvedTypes.put(name, type);</b>
&nbsp;        }
<b class="nc">&nbsp;        return type;</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Reference unresolved(String name) {
<b class="nc">&nbsp;      return new Reference(name, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Parameterized parameterized(Reference raw, Iterable&lt;? extends Nonprimitive&gt; arguments) {
<b class="nc">&nbsp;      return new Parameterized(raw, ImmutableList.copyOf(arguments));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Array array(Type element) {
<b class="nc">&nbsp;      return new Array(element, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Array varargs(Type element) {
<b class="nc">&nbsp;      return new Array(element, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Wildcard.Super superWildcard(Defined lowerBound) {
<b class="nc">&nbsp;      return new Wildcard.Super(lowerBound);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Wildcard.Extends extendsWildcard(Defined upperBound) {
<b class="nc">&nbsp;      return new Wildcard.Extends(upperBound);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Parameters parameters() {
<b class="nc">&nbsp;      return EMPTY_PARAMETERS;</b>
&nbsp;    }
&nbsp;
&nbsp;    static final class DefinedParameters implements Parameters {
&nbsp;      private final @Nullable DefinedParameters parent;
&nbsp;      private final Variable variable;
&nbsp;      private final List&lt;String&gt; names;
&nbsp;
<b class="nc">&nbsp;      DefinedParameters(@Nullable DefinedParameters parent, String name, List&lt;Defined&gt; bounds, boolean recursive) {</b>
<b class="nc">&nbsp;        this.parent = parent;</b>
<b class="nc">&nbsp;        this.variable = new Variable(name, bounds, recursive);</b>
<b class="nc">&nbsp;        this.names = unwindNames();</b>
&nbsp;      }
&nbsp;
&nbsp;      private ImmutableList&lt;String&gt; unwindNames() {
<b class="nc">&nbsp;        ImmutableList.Builder&lt;String&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;        for (DefinedParameters p = this; p != null; p = p.parent) {</b>
<b class="nc">&nbsp;          builder.add(p.variable.name);</b>
&nbsp;        }
<b class="nc">&nbsp;        return builder.build().reverse();</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public Parameters introduce(String name, Iterable&lt;? extends Defined&gt; upperBounds) {
<b class="nc">&nbsp;        return new DefinedParameters(this, name, ImmutableList.copyOf(upperBounds), false);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public Parameters recursive(String name) {
<b class="nc">&nbsp;        return new DefinedParameters(this, name, ImmutableList.&lt;Defined&gt;of(), true);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public Variable variable(String name) {
<b class="nc">&nbsp;        if (variable.name.equals(name)) {</b>
<b class="nc">&nbsp;          return variable;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (parent != null) {</b>
<b class="nc">&nbsp;          return parent.variable(name);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;no such variable: &quot; + name);</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public List&lt;String&gt; names() {
<b class="nc">&nbsp;        return names;</b>
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public String toString() {
<b class="nc">&nbsp;        String parameters = &quot;&quot;;</b>
<b class="nc">&nbsp;        for (DefinedParameters p = this; p != null; p = p.parent) {</b>
<b class="nc">&nbsp;          parameters = !parameters.isEmpty()</b>
<b class="nc">&nbsp;              ? p.parameterString() + &quot;, &quot; + parameters</b>
<b class="nc">&nbsp;              : p.parameterString();</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&lt;&quot; + parameters + &quot;&gt;&quot;;</b>
&nbsp;      }
&nbsp;
&nbsp;      private String parameterString() {
<b class="nc">&nbsp;        if (variable.upperBounds.isEmpty()) {</b>
<b class="nc">&nbsp;          return variable.name;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (variable.upperBounds.size() == 1 &amp;&amp; variable.upperBounds.get(0) == Type.OBJECT) {</b>
<b class="nc">&nbsp;          return variable.name;</b>
&nbsp;        }
<b class="nc">&nbsp;        return variable.name + &quot; extends &quot; + Joiner.on(&quot; &amp; &quot;).join(variable.upperBounds);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  abstract class Transformer implements Visitor&lt;Type&gt; {</b>
&nbsp;    protected Type defaults(Type type) {
<b class="nc">&nbsp;      return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type primitive(Primitive primitive) {
<b class="nc">&nbsp;      return defaults(primitive);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type reference(Reference reference) {
<b class="nc">&nbsp;      return defaults(reference);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type variable(Variable variable) {
<b class="nc">&nbsp;      return defaults(variable);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type parameterized(Parameterized parameterized) {
<b class="nc">&nbsp;      ImmutableList.Builder&lt;Nonprimitive&gt; builder = ImmutableList.builder();</b>
<b class="nc">&nbsp;      for (Nonprimitive a : parameterized.arguments) {</b>
<b class="nc">&nbsp;        builder.add((Nonprimitive) a.accept(this));</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return new Parameterized(</b>
<b class="nc">&nbsp;          (Reference) parameterized.reference.accept(this),</b>
<b class="nc">&nbsp;          builder.build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type array(Array array) {
<b class="nc">&nbsp;      return new Array(array.element.accept(this), array.varargs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type superWildcard(Wildcard.Super wildcard) {
<b class="nc">&nbsp;      return new Wildcard.Super((Defined) wildcard.lowerBound.accept(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type extendsWildcard(Wildcard.Extends wildcard) {
<b class="nc">&nbsp;      return new Wildcard.Extends((Defined) wildcard.upperBound.accept(this));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  class VariableResolver extends Transformer implements Function&lt;Type, Type&gt; {</b>
<b class="nc">&nbsp;    private static final VariableResolver EMPTY = new VariableResolver(new Variable[0], new Nonprimitive[0]);</b>
&nbsp;
&nbsp;    public static VariableResolver empty() {
<b class="nc">&nbsp;      return EMPTY;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;      return variables.length == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private final Variable[] variables;
&nbsp;    private final Nonprimitive[] substitutions;
&nbsp;
<b class="nc">&nbsp;    private VariableResolver(Variable[] variables, Nonprimitive[] substitutions) {</b>
<b class="nc">&nbsp;      assert variables.length == substitutions.length;</b>
<b class="nc">&nbsp;      this.variables = variables;</b>
<b class="nc">&nbsp;      this.substitutions = substitutions;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Variable[] variables() {
<b class="nc">&nbsp;      return variables.clone();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type variable(Variable variable) {
<b class="nc">&nbsp;      for (int i = 0; i &lt; variables.length; i++) {</b>
<b class="nc">&nbsp;        if (variables[i] == variable) {</b>
<b class="nc">&nbsp;          return substitutions[i];</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return variable;</b>
&nbsp;    }
&nbsp;
&nbsp;    public @Nullable Variable byName(String named) {
<b class="nc">&nbsp;      for (int i = 0; i &lt; variables.length; i++) {</b>
<b class="nc">&nbsp;        if (variables[i].name.equals(named)) {</b>
<b class="nc">&nbsp;          return variables[i];</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Type apply(Type type) {
<b class="nc">&nbsp;      return type.accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;      StringBuilder b = new StringBuilder(getClass().getSimpleName()).append(&quot;{&quot;);</b>
<b class="nc">&nbsp;      for (Variable v : variables) {</b>
<b class="nc">&nbsp;        b.append(&quot;\n  &quot;).append(v).append(&quot; -&gt; &quot;).append(variable(v));</b>
&nbsp;      }
<b class="nc">&nbsp;      return b.append(&quot;\n}&quot;).toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public VariableResolver bind(Variable variable, Nonprimitive substitution) {
<b class="nc">&nbsp;      Variable[] variables = Arrays.copyOf(this.variables, this.variables.length + 1);</b>
<b class="nc">&nbsp;      variables[variables.length - 1] = variable;</b>
&nbsp;
<b class="nc">&nbsp;      Nonprimitive[] substitutions = Arrays.copyOf(this.substitutions, this.substitutions.length + 1);</b>
<b class="nc">&nbsp;      substitutions[substitutions.length - 1] = substitution;</b>
&nbsp;
<b class="nc">&nbsp;      return new VariableResolver(variables, substitutions);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  class Parser {</b>
<b class="nc">&nbsp;    private static final Joiner JOINER = Joiner.on(&#39;.&#39;);</b>
&nbsp;
&nbsp;    private boolean unresolve;
&nbsp;    private final Factory factory;
&nbsp;    private final Parameters parameters;
&nbsp;
<b class="nc">&nbsp;    public Parser(Factory factory, Parameters parameters) {</b>
<b class="nc">&nbsp;      this.factory = factory;</b>
<b class="nc">&nbsp;      this.parameters = parameters;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Parser unresolving() {
<b class="nc">&nbsp;      unresolve = false;</b>
<b class="nc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Type forName(String name) {
<b class="nc">&nbsp;      if (Producer.PRIMITIVE_TYPES.containsKey(name)) {</b>
<b class="nc">&nbsp;        return factory.primitive(name);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (parameters.names().contains(name)) {</b>
<b class="nc">&nbsp;        return parameters.variable(name);</b>
&nbsp;      }
<b class="nc">&nbsp;      return unresolve</b>
<b class="nc">&nbsp;          ? factory.unresolved(name)</b>
<b class="nc">&nbsp;          : factory.reference(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Type parse(String input) {
&nbsp;      try {
<b class="nc">&nbsp;        return doParse(input);</b>
<b class="nc">&nbsp;      } catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;        IllegalArgumentException exception =</b>
&nbsp;            new IllegalArgumentException(
<b class="nc">&nbsp;                &quot;Cannot parse type from input string &#39;&quot; + input + &quot;&#39;. &quot; + ex.getMessage());</b>
<b class="nc">&nbsp;        exception.setStackTrace(ex.getStackTrace());</b>
<b class="nc">&nbsp;        throw exception;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    private Type doParse(String input) {
<b class="nc">&nbsp;      final Deque&lt;Term&gt; terms = new LinkedList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;      for (Term t : Code.termsFrom(input)) {</b>
<b class="nc">&nbsp;        if (!t.isWhitespace())</b>
<b class="nc">&nbsp;          terms.add(t);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      class Reader {</b>
&nbsp;
&nbsp;        Type type() {
<b class="nc">&nbsp;          Term t = terms.peek();</b>
<b class="nc">&nbsp;          if (t.isWordOrNumber()) {</b>
<b class="nc">&nbsp;            Type type = named();</b>
&nbsp;
<b class="nc">&nbsp;            t = terms.peek();</b>
<b class="nc">&nbsp;            if (t != null) {</b>
<b class="nc">&nbsp;              if (t.is(&quot;&lt;&quot;)) {</b>
<b class="nc">&nbsp;                type = arguments(type);</b>
&nbsp;              }
<b class="nc">&nbsp;              while (!terms.isEmpty()) {</b>
<b class="nc">&nbsp;                t = terms.peek();</b>
<b class="nc">&nbsp;                if (t.is(&quot;[&quot;)) {</b>
<b class="nc">&nbsp;                  type = array(type);</b>
&nbsp;                } else {
&nbsp;                  break;
&nbsp;                }
&nbsp;              }
<b class="nc">&nbsp;              if (t.is(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;                type = varargs(type);</b>
&nbsp;              }
&nbsp;            }
<b class="nc">&nbsp;            return type;</b>
<b class="nc">&nbsp;          } else if (t.is(&quot;@&quot;)) {</b>
&nbsp;            // just consume type annotation
<b class="nc">&nbsp;            terms.poll();</b>
<b class="nc">&nbsp;            consumeAnnotation();</b>
&nbsp;            // and try again, yep, recursively...
<b class="nc">&nbsp;            return type();</b>
<b class="nc">&nbsp;          } else if (t.is(&quot;(&quot;)) {</b>
<b class="nc">&nbsp;            Type type = annotatedType();</b>
<b class="nc">&nbsp;            while (!terms.isEmpty()) {</b>
<b class="nc">&nbsp;              t = terms.peek();</b>
<b class="nc">&nbsp;              if (t.is(&quot;[&quot;)) {</b>
<b class="nc">&nbsp;                type = array(type);</b>
&nbsp;              } else {
&nbsp;                break;
&nbsp;              }
&nbsp;            }
<b class="nc">&nbsp;            return type;</b>
&nbsp;          }
<b class="nc">&nbsp;          throw new IllegalStateException(&quot;unexpected term &#39;&quot; + t + &quot;&#39;&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        Type annotatedType() {
<b class="nc">&nbsp;          terms.poll();</b>
<b class="nc">&nbsp;          consumeAnnotation();</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;:&quot;);</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;:&quot;);</b>
<b class="nc">&nbsp;          Type type = type();</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;)&quot;);</b>
<b class="nc">&nbsp;          return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        Wildcard wildcard() {
<b class="nc">&nbsp;          expect(terms.poll(), &quot;?&quot;);</b>
&nbsp;
<b class="nc">&nbsp;          Term t = terms.peek();</b>
<b class="nc">&nbsp;          if (t.is(&quot;super&quot;)) {</b>
<b class="nc">&nbsp;            terms.poll();</b>
<b class="nc">&nbsp;            Defined lowerBound = (Defined) type();</b>
<b class="nc">&nbsp;            return factory.superWildcard(lowerBound);</b>
&nbsp;          }
<b class="nc">&nbsp;          if (t.is(&quot;extends&quot;)) {</b>
<b class="nc">&nbsp;            terms.poll();</b>
<b class="nc">&nbsp;            Defined upperBound = (Defined) type();</b>
<b class="nc">&nbsp;            return factory.extendsWildcard(upperBound);</b>
&nbsp;          }
<b class="nc">&nbsp;          return factory.extendsWildcard(OBJECT);</b>
&nbsp;        }
&nbsp;
&nbsp;        Type array(Type element) {
<b class="nc">&nbsp;          expect(terms.poll(), &quot;[&quot;);</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;]&quot;);</b>
<b class="nc">&nbsp;          return factory.array(element);</b>
&nbsp;        }
&nbsp;
&nbsp;        Type varargs(Type element) {
<b class="nc">&nbsp;          expect(terms.poll(), &quot;.&quot;);</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;.&quot;);</b>
<b class="nc">&nbsp;          expect(terms.poll(), &quot;.&quot;);</b>
<b class="nc">&nbsp;          return factory.varargs(element);</b>
&nbsp;        }
&nbsp;
&nbsp;        Type arguments(Type reference) {
<b class="nc">&nbsp;          expect(terms.poll(), &quot;&lt;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;          List&lt;Nonprimitive&gt; arguments = new ArrayList&lt;&gt;();</b>
&nbsp;          for (;;) {
<b class="nc">&nbsp;            if (terms.peek().is(&quot;?&quot;)) {</b>
<b class="nc">&nbsp;              arguments.add(wildcard());</b>
&nbsp;            } else {
<b class="nc">&nbsp;              arguments.add((Nonprimitive) type());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!terms.isEmpty() &amp;&amp; terms.peek().is(&quot;,&quot;)) {</b>
<b class="nc">&nbsp;              terms.poll();</b>
&nbsp;            } else
&nbsp;              break;
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          expect(terms.poll(), &quot;&gt;&quot;);</b>
&nbsp;
<b class="nc">&nbsp;          return factory.parameterized((Reference) reference, arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        Type named() {
<b class="nc">&nbsp;          List&lt;String&gt; segments = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;          for (;;) {
<b class="nc">&nbsp;            if (terms.peek().isWordOrNumber()) {</b>
<b class="nc">&nbsp;              segments.add(terms.poll().toString());</b>
<b class="nc">&nbsp;            } else if (terms.peek().is(&quot;@&quot;)) {</b>
<b class="nc">&nbsp;              terms.poll();</b>
&nbsp;              // just consume type annotation
<b class="nc">&nbsp;              consumeAnnotation();</b>
<b class="nc">&nbsp;              continue;</b>
&nbsp;            } else {
&nbsp;              break;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!terms.isEmpty() &amp;&amp; terms.peek().is(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;              if (terms.size() &gt;= 2) {</b>
&nbsp;                // case when varargs may be so more than one dot
&nbsp;                // but we handle rest of it elsewhere
<b class="nc">&nbsp;                Iterator&lt;Term&gt; it = terms.iterator();</b>
<b class="nc">&nbsp;                if (it.next().is(&quot;.&quot;) &amp;&amp; it.next().is(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;                  break;</b>
&nbsp;                }
&nbsp;              }
<b class="nc">&nbsp;              terms.poll();</b>
&nbsp;            } else {
&nbsp;              break;
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          return forName(JOINER.join(segments));</b>
&nbsp;        }
&nbsp;
&nbsp;        private void consumeAnnotation() {
<b class="nc">&nbsp;          named();</b>
<b class="nc">&nbsp;          consumeAnnotationParameters();</b>
<b class="nc">&nbsp;          consumeErraticTrailingComma();</b>
&nbsp;        }
&nbsp;
&nbsp;        private void consumeAnnotationParameters() {
<b class="nc">&nbsp;          consumeRecursiveUntil(&quot;(&quot;, &quot;)&quot;);</b>
&nbsp;        }
&nbsp;        
&nbsp;        private void consumeRecursiveUntil(String begin, String end) {
<b class="nc">&nbsp;          if (!terms.isEmpty() &amp;&amp; terms.peek().is(begin)) {</b>
<b class="nc">&nbsp;            terms.poll();</b>
<b class="nc">&nbsp;            while(!terms.isEmpty()) {</b>
<b class="nc">&nbsp;              Term t = terms.peek();</b>
<b class="nc">&nbsp;              if (t.is(end)) {</b>
<b class="nc">&nbsp;                terms.poll();</b>
&nbsp;                return;
&nbsp;              }
<b class="nc">&nbsp;              if (t.is(begin)) {</b>
<b class="nc">&nbsp;                consumeRecursiveUntil(begin, end);</b>
&nbsp;              } else {
<b class="nc">&nbsp;                terms.poll();</b>
&nbsp;              }
<b class="nc">&nbsp;            }</b>
&nbsp;          }
&nbsp;        }
&nbsp;
&nbsp;        private void consumeErraticTrailingComma() {
<b class="nc">&nbsp;          if (!terms.isEmpty() &amp;&amp; terms.peek().is(&quot;,&quot;)) {</b>
<b class="nc">&nbsp;            terms.poll();</b>
&nbsp;          }
&nbsp;        }
&nbsp;
&nbsp;        void expect(Term t, String is) {
<b class="nc">&nbsp;          if (t == null || !t.is(is)) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;expected &#39;&quot; + is + &quot;&#39; but got &#39;&quot; + t + &quot;&#39;&quot;);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      Type type = new Reader().type();</b>
&nbsp;
<b class="nc">&nbsp;      if (!terms.isEmpty()) {</b>
<b class="nc">&nbsp;        throw new IllegalStateException(&quot;unexpected trailing terms &#39;&quot; + Joiner.on(&quot;&quot;).join(terms) + &quot;&#39;&quot;);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return type;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // Template matches types, but do not subtyping into account
&nbsp;  // also it doesn&#39;t verify variable bounds
&nbsp;  class Template {
&nbsp;    public final Type template;
&nbsp;
<b class="nc">&nbsp;    public Template(Type template) {</b>
<b class="nc">&nbsp;      this.template = template;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Optional&lt;VariableResolver&gt; match(Type type) {
<b class="nc">&nbsp;      final VariableResolver[] holder = new VariableResolver[] {VariableResolver.empty()};</b>
&nbsp;
&nbsp;      class Decomposer implements Visitor&lt;Boolean&gt; {
&nbsp;        final Type type;
&nbsp;
<b class="nc">&nbsp;        Decomposer(Type type) {</b>
<b class="nc">&nbsp;          this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean primitive(Primitive primitive) {
<b class="nc">&nbsp;          return type == primitive;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean reference(Reference reference) {
<b class="nc">&nbsp;          return type.equals(reference);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean parameterized(Parameterized template) {
<b class="nc">&nbsp;          if (type instanceof Parameterized) {</b>
<b class="nc">&nbsp;            Parameterized ps = (Parameterized) type;</b>
<b class="nc">&nbsp;            if (template.reference.equals(ps.reference)</b>
<b class="nc">&nbsp;                &amp;&amp; ps.arguments.size() == template.arguments.size()) {</b>
<b class="nc">&nbsp;              for (int i = 0; i &lt; template.arguments.size(); i++) {</b>
<b class="nc">&nbsp;                Decomposer visitor = new Decomposer(ps.arguments.get(i));</b>
<b class="nc">&nbsp;                boolean matched = template.arguments.get(i).accept(visitor);</b>
<b class="nc">&nbsp;                if (!matched) {</b>
<b class="nc">&nbsp;                  return false;</b>
&nbsp;                }
&nbsp;              }
<b class="nc">&nbsp;              return true;</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean variable(Variable variable) {
<b class="nc">&nbsp;          if (variable.equals(type)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
<b class="nc">&nbsp;          if (type instanceof Nonprimitive) {</b>
<b class="nc">&nbsp;            holder[0] = holder[0].bind(variable, (Nonprimitive) type);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;          }
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean array(Array array) {
<b class="nc">&nbsp;          if (type instanceof Array) {</b>
<b class="nc">&nbsp;            return array.element.accept(new Decomposer(((Array) type).element));</b>
&nbsp;          }
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean superWildcard(Wildcard.Super wildcard) {
<b class="nc">&nbsp;          if (type instanceof Wildcard.Super) {</b>
<b class="nc">&nbsp;            return wildcard.lowerBound.accept(new Decomposer(((Wildcard.Super) type).lowerBound));</b>
&nbsp;          }
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean extendsWildcard(Wildcard.Extends wildcard) {
<b class="nc">&nbsp;          if (type instanceof Wildcard.Extends) {</b>
<b class="nc">&nbsp;            return wildcard.upperBound.accept(new Decomposer(((Wildcard.Extends) type).upperBound));</b>
&nbsp;          }
<b class="nc">&nbsp;          return false;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      if (template.accept(new Decomposer(type))) {</b>
<b class="nc">&nbsp;        return Optional.of(holder[0]);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
