


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Structurizer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.value.processor.encode</a>
</div>

<h1>Coverage Summary for Class: Structurizer (org.immutables.value.processor.encode)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Structurizer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/118)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Structurizer$1</td>
  </tr>
  <tr>
    <td class="name">Structurizer$Statement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Structurizer$Statement$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Structurizer$WhitespaceEnabler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/94)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/137)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp;   Copyright 2016 Immutables Authors and Contributors
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp; */
&nbsp;package org.immutables.value.processor.encode;
&nbsp;
&nbsp;import com.google.common.base.Optional;
&nbsp;import com.google.common.base.Predicate;
&nbsp;import com.google.common.base.Verify;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Iterators;
&nbsp;import com.google.common.collect.PeekingIterator;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Deque;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import javax.lang.model.element.Modifier;
&nbsp;import org.immutables.value.Value.Default;
&nbsp;import org.immutables.value.Value.Derived;
&nbsp;import org.immutables.value.Value.Enclosing;
&nbsp;import org.immutables.value.Value.Immutable;
&nbsp;import org.immutables.value.Value.Lazy;
&nbsp;import org.immutables.value.processor.encode.Code.Term;
&nbsp;
&nbsp;// All parsing assume well-formed Java code
<b class="nc">&nbsp;@Enclosing</b>
<b class="nc">&nbsp;final class Structurizer {</b>
<b class="nc">&nbsp;  private static final ImmutableSet&lt;String&gt; modifiers = allModifiers();</b>
&nbsp;  private final PeekingIterator&lt;Term&gt; terms;
<b class="nc">&nbsp;  private final WhitespaceEnabler whitespaces = new WhitespaceEnabler();</b>
&nbsp;
<b class="nc">&nbsp;  Structurizer(Iterable&lt;Term&gt; terms) {</b>
<b class="nc">&nbsp;    this.terms = Iterators.peekingIterator(Iterators.filter(terms.iterator(), whitespaces));</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private final class WhitespaceEnabler implements Predicate&lt;Term&gt; {</b>
&nbsp;    private int count;
&nbsp;
&nbsp;    void on() {
<b class="nc">&nbsp;      count++;</b>
&nbsp;    }
&nbsp;
&nbsp;    void off() {
<b class="nc">&nbsp;      if (--count &lt; 0)</b>
<b class="nc">&nbsp;        throw new IllegalStateException(&quot;unmatched off&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean apply(Term input) {
<b class="nc">&nbsp;      return count &gt; 0 || (!input.isWhitespace() &amp;&amp; !input.isComment());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Immutable
<b class="nc">&nbsp;  abstract static class Statement {</b>
&nbsp;    abstract List&lt;Term&gt; annotations();
&nbsp;
&nbsp;    abstract List&lt;Term&gt; signature();
&nbsp;
&nbsp;    abstract List&lt;Term&gt; parameters();
&nbsp;
&nbsp;    abstract List&lt;Term&gt; expression();
&nbsp;
&nbsp;    abstract List&lt;Term&gt; block();
&nbsp;
&nbsp;    abstract List&lt;Statement&gt; definitions();
&nbsp;
&nbsp;    @Derived
&nbsp;    boolean isClassOrInterface() {
<b class="nc">&nbsp;      for (Term t : signature()) {</b>
<b class="nc">&nbsp;        if (t.is(&quot;class&quot;) || t.is(&quot;interface&quot;)) {</b>
<b class="nc">&nbsp;          return true;</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Lazy
&nbsp;    List&lt;Term&gt; returnType() {
<b class="nc">&nbsp;      return parseReturnType(signature());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Default
&nbsp;    Optional&lt;String&gt; name() {
<b class="nc">&nbsp;      if (signature().isEmpty()) {</b>
<b class="nc">&nbsp;        return Optional.absent();</b>
&nbsp;      }
<b class="nc">&nbsp;      Term last = Iterables.getLast(signature());</b>
<b class="nc">&nbsp;      if (last.isWordOrNumber() &amp;&amp; !last.is(&quot;static&quot;)) {</b>
<b class="nc">&nbsp;        return Optional.of(last.toString());</b>
&nbsp;      }
<b class="nc">&nbsp;      return Optional.absent();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    static class Builder extends ImmutableStructurizer.Statement.Builder {}</b>
&nbsp;  }
&nbsp;
&nbsp;  List&lt;Statement&gt; structurize() {
<b class="nc">&nbsp;    List&lt;Statement&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    while (terms.hasNext()) {</b>
<b class="nc">&nbsp;      result.add(statement());</b>
&nbsp;    }
<b class="nc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Statement statement() {
<b class="nc">&nbsp;    Statement.Builder builder = new Statement.Builder();</b>
<b class="nc">&nbsp;    boolean classDecl = false;</b>
<b class="nc">&nbsp;    boolean wasParameters = false;</b>
&nbsp;    for (;;) {
<b class="nc">&nbsp;      Term t = terms.peek();</b>
<b class="nc">&nbsp;      if (t.is(&quot;=&quot;)) {</b>
<b class="nc">&nbsp;        terms.next();</b>
<b class="nc">&nbsp;        expressionUpToSemicolon(builder);</b>
<b class="nc">&nbsp;        return builder.build();</b>
<b class="nc">&nbsp;      } else if (t.is(&quot;(&quot;) &amp;&amp; !wasParameters) {</b>
<b class="nc">&nbsp;        builder.addAllParameters(collectUntilMatching(&quot;)&quot;));</b>
<b class="nc">&nbsp;        wasParameters = true;</b>
<b class="nc">&nbsp;      } else if (t.is(&quot;{&quot;)) {</b>
<b class="nc">&nbsp;        block(builder, classDecl);</b>
<b class="nc">&nbsp;        return builder.build();</b>
<b class="nc">&nbsp;      } else if (t.is(&quot;;&quot;)) {</b>
<b class="nc">&nbsp;        terms.next();</b>
<b class="nc">&nbsp;        return builder.build();</b>
&nbsp;      } else {
<b class="nc">&nbsp;        if (wasParameters) {</b>
<b class="nc">&nbsp;          terms.next();// just throwing away throws information</b>
&nbsp;        } else {
<b class="nc">&nbsp;          if (signature(builder)) {</b>
<b class="nc">&nbsp;            classDecl = true;</b>
&nbsp;            // take class name as next token after class keyword
<b class="nc">&nbsp;            builder.name(Optional.of(terms.peek().toString()));</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;Term&gt; collectUntilMatching(String end) {
<b class="nc">&nbsp;    List&lt;Term&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    doCollectMatching(result, terms.peek().toString(), end);</b>
<b class="nc">&nbsp;    return result;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void doCollectMatching(List&lt;Term&gt; accumulator, String start, String end) {
<b class="nc">&nbsp;    whitespaces.on();</b>
&nbsp;    try {
<b class="nc">&nbsp;      accumulator.add(terms.next());</b>
&nbsp;      for (;;) {
<b class="nc">&nbsp;        Term t = terms.peek();</b>
<b class="nc">&nbsp;        if (t.is(start)) {</b>
<b class="nc">&nbsp;          doCollectMatching(accumulator, start, end);</b>
<b class="nc">&nbsp;        } else if (t.is(end)) {</b>
<b class="nc">&nbsp;          accumulator.add(terms.next());</b>
&nbsp;          return;
&nbsp;        } else {
<b class="nc">&nbsp;          accumulator.add(terms.next());</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    } finally {
<b class="nc">&nbsp;      whitespaces.off();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private void expressionUpToSemicolon(Statement.Builder builder) {
<b class="nc">&nbsp;    terms.peek();</b>
<b class="nc">&nbsp;    whitespaces.on();</b>
&nbsp;    try {
<b class="nc">&nbsp;      List&lt;Term&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;      for (;;) {
<b class="nc">&nbsp;        Term t = terms.peek();</b>
<b class="nc">&nbsp;        if (t.is(&quot;(&quot;)) {</b>
<b class="nc">&nbsp;          doCollectMatching(result, &quot;(&quot;, &quot;)&quot;);</b>
<b class="nc">&nbsp;        } else if (t.is(&quot;{&quot;)) {</b>
<b class="nc">&nbsp;          doCollectMatching(result, &quot;{&quot;, &quot;}&quot;);</b>
<b class="nc">&nbsp;        } else if (t.is(&quot;[&quot;)) {</b>
<b class="nc">&nbsp;          doCollectMatching(result, &quot;[&quot;, &quot;]&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;          if (t.is(&quot;;&quot;)) {</b>
<b class="nc">&nbsp;            builder.addAllExpression(result);</b>
&nbsp;            return;
&nbsp;          }
<b class="nc">&nbsp;          result.add(terms.next());</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    } finally {
<b class="nc">&nbsp;      whitespaces.off();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private void block(Statement.Builder builder, boolean classDecl) {
<b class="nc">&nbsp;    if (classDecl) {</b>
<b class="nc">&nbsp;      Verify.verify(terms.peek().is(&quot;{&quot;));</b>
<b class="nc">&nbsp;      terms.next();</b>
<b class="nc">&nbsp;      while (terms.hasNext() &amp;&amp; !terms.peek().is(&quot;}&quot;)) {</b>
<b class="nc">&nbsp;        builder.addDefinitions(statement());</b>
&nbsp;      }
<b class="nc">&nbsp;      Verify.verify(terms.next().is(&quot;}&quot;));</b>
&nbsp;    } else {
<b class="nc">&nbsp;      builder.addAllBlock(collectUntilMatching(&quot;}&quot;));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean signature(Statement.Builder builder) {
<b class="nc">&nbsp;    Term t = terms.peek();</b>
<b class="nc">&nbsp;    if (t.is(&quot;@&quot;)) {</b>
&nbsp;      do {
<b class="nc">&nbsp;        builder.addAnnotations(terms.next());</b>
<b class="nc">&nbsp;        Verify.verify(terms.peek().isWordOrNumber());</b>
<b class="nc">&nbsp;        builder.addAnnotations(terms.next());</b>
<b class="nc">&nbsp;      } while (terms.peek().is(&quot;.&quot;));</b>
&nbsp;
<b class="nc">&nbsp;      if (terms.peek().is(&quot;(&quot;)) {</b>
<b class="nc">&nbsp;        builder.addAllAnnotations(collectUntilMatching(&quot;)&quot;));</b>
&nbsp;      }
<b class="nc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    } else if (t.is(&quot;&lt;&quot;)) {</b>
<b class="nc">&nbsp;      builder.addAllSignature(collectUntilMatching(&quot;&gt;&quot;));</b>
<b class="nc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    } else if (t.is(&quot;class&quot;) || t.is(&quot;interface&quot;)) {</b>
<b class="nc">&nbsp;      builder.addSignature(terms.next());</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      builder.addSignature(terms.next());</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static List&lt;Term&gt; parseReturnType(List&lt;Term&gt; signature) {
<b class="nc">&nbsp;    if (signature.isEmpty()) {</b>
<b class="nc">&nbsp;      return ImmutableList.of();</b>
&nbsp;    }
<b class="nc">&nbsp;    Deque&lt;Term&gt; terms = new ArrayDeque&lt;&gt;(signature);</b>
<b class="nc">&nbsp;    Term last = terms.removeLast();</b>
<b class="nc">&nbsp;    if (!last.isWordOrNumber() || last.is(&quot;static&quot;)) {</b>
<b class="nc">&nbsp;      return ImmutableList.of();</b>
&nbsp;    }
<b class="nc">&nbsp;    while (!terms.isEmpty()) {</b>
<b class="nc">&nbsp;      Term t = terms.peek();</b>
<b class="nc">&nbsp;      if (t.is(&quot;&lt;&quot;)) {</b>
<b class="nc">&nbsp;        removeTillMatching(terms, &quot;&lt;&quot;, &quot;&gt;&quot;);</b>
<b class="nc">&nbsp;      } else if (modifiers.contains(t.toString())) {</b>
<b class="nc">&nbsp;        terms.remove();</b>
&nbsp;      } else {
&nbsp;        // it is possible that there are
&nbsp;        // no whitespace or comments already
<b class="nc">&nbsp;        removeCommentsAndWhitespace(terms);</b>
<b class="nc">&nbsp;        return ImmutableList.copyOf(terms);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return ImmutableList.of();</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void removeCommentsAndWhitespace(Deque&lt;Term&gt; terms) {
<b class="nc">&nbsp;    Iterator&lt;Term&gt; it = terms.iterator();</b>
<b class="nc">&nbsp;    while (it.hasNext()) {</b>
<b class="nc">&nbsp;      Term n = it.next();</b>
<b class="nc">&nbsp;      if (n.isComment() || n.isWhitespace()) {</b>
<b class="nc">&nbsp;        it.remove();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void removeTillMatching(Deque&lt;Term&gt; terms, String begin, String end) {
<b class="nc">&nbsp;    assert terms.peek().is(begin);</b>
<b class="nc">&nbsp;    terms.remove();</b>
&nbsp;    for (;;) {
<b class="nc">&nbsp;      if (terms.peek().is(begin)) {</b>
<b class="nc">&nbsp;        removeTillMatching(terms, begin, end);</b>
<b class="nc">&nbsp;      } else if (terms.remove().is(end)) {</b>
&nbsp;        return;
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static ImmutableSet&lt;String&gt; allModifiers() {
<b class="nc">&nbsp;    ImmutableSet.Builder&lt;String&gt; b = ImmutableSet.builder();</b>
<b class="nc">&nbsp;    for (Modifier m : Modifier.values()) {</b>
<b class="nc">&nbsp;      b.add(m.toString());</b>
&nbsp;    }
<b class="nc">&nbsp;    return b.build();</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
