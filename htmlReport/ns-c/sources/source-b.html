


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Json</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.criteria.elasticsearch</a>
</div>

<h1>Coverage Summary for Class: Json (org.immutables.criteria.elasticsearch)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Json</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Json$1</td>
  </tr>
  <tr>
    <td class="name">Json$Aggregation</td>
  </tr>
  <tr>
    <td class="name">Json$Aggregations</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$AggregationsDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$Bucket</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$Count</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$GroupValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$HasAggregations</td>
  </tr>
  <tr>
    <td class="name">Json$MultiBucketsAggregation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$MultiValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$Result</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$RowKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$SearchHit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$SearchHits</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$SearchTotal</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Json$SearchTotalDeserializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/198)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2019 Immutables Authors and Contributors
&nbsp; * Copyright 2016-2018 Apache Software Foundation (ASF)
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.immutables.criteria.elasticsearch;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonCreator;
&nbsp;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
&nbsp;import com.fasterxml.jackson.annotation.JsonProperty;
&nbsp;import com.fasterxml.jackson.core.JsonParser;
&nbsp;import com.fasterxml.jackson.core.JsonProcessingException;
&nbsp;import com.fasterxml.jackson.databind.DeserializationContext;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
&nbsp;import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
&nbsp;import com.fasterxml.jackson.databind.node.ArrayNode;
&nbsp;import com.fasterxml.jackson.databind.node.NullNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.time.Duration;
&nbsp;import java.util.ArrayDeque;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Deque;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.stream.StreamSupport;
&nbsp;
&nbsp;/**
&nbsp; * Mapping classes for ElasticSearch results.
&nbsp; *
&nbsp; * Some parts of this class have been copied from &lt;a href=&quot;https://calcite.apache.org/&quot;&gt;Apache Calcite&lt;/a&gt; project.
&nbsp; */
<b class="nc">&nbsp;class Json {</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Reply of &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html&quot;&gt;search-count&lt;/a&gt;
&nbsp;   * endpoint aka {@code _count}.
&nbsp;   */
&nbsp;  @JsonIgnoreProperties(ignoreUnknown = true)
&nbsp;  static class Count {
&nbsp;    private final long count;
&nbsp;
&nbsp;    @JsonCreator
<b class="nc">&nbsp;    Count(@JsonProperty(&quot;count&quot;) long count) {</b>
<b class="nc">&nbsp;      this.count = count;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long count() {
<b class="nc">&nbsp;      return count;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Response from Elastic
&nbsp;   */
&nbsp;  @JsonIgnoreProperties(ignoreUnknown = true)
&nbsp;  static class Result {
&nbsp;    private final SearchHits hits;
&nbsp;    private final Aggregations aggregations;
&nbsp;    private final String scrollId;
&nbsp;    private final long took;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for this instance.
&nbsp;     * @param hits list of matched documents
&nbsp;     * @param took time taken (in took) for this query to execute
&nbsp;     */
&nbsp;    @JsonCreator
&nbsp;    Result(@JsonProperty(&quot;hits&quot;) SearchHits hits,
&nbsp;           @JsonProperty(&quot;aggregations&quot;) Aggregations aggregations,
&nbsp;           @JsonProperty(&quot;_scroll_id&quot;) String scrollId,
<b class="nc">&nbsp;           @JsonProperty(&quot;took&quot;) long took) {</b>
<b class="nc">&nbsp;      this.hits = Objects.requireNonNull(hits, &quot;hits&quot;);</b>
<b class="nc">&nbsp;      this.aggregations = aggregations;</b>
<b class="nc">&nbsp;      this.scrollId = scrollId;</b>
<b class="nc">&nbsp;      this.took = took;</b>
&nbsp;    }
&nbsp;
&nbsp;    SearchHits searchHits() {
<b class="nc">&nbsp;      return hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean isEmpty() {
<b class="nc">&nbsp;      return hits.hits().isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    Aggregations aggregations() {
<b class="nc">&nbsp;      return aggregations;</b>
&nbsp;    }
&nbsp;
&nbsp;    Duration took() {
<b class="nc">&nbsp;      return Duration.ofMillis(took);</b>
&nbsp;    }
&nbsp;
&nbsp;    Optional&lt;String&gt; scrollId() {
<b class="nc">&nbsp;      return Optional.ofNullable(scrollId);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits leaves of the aggregation where all values are stored.
&nbsp;   */
&nbsp;  static void visitValueNodes(Aggregations aggregations, Consumer&lt;Map&lt;String, Object&gt;&gt; consumer) {
<b class="nc">&nbsp;    Objects.requireNonNull(aggregations, &quot;aggregations&quot;);</b>
<b class="nc">&nbsp;    Objects.requireNonNull(consumer, &quot;consumer&quot;);</b>
&nbsp;
<b class="nc">&nbsp;    Map&lt;RowKey, List&lt;MultiValue&gt;&gt; rows = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    BiConsumer&lt;RowKey, MultiValue&gt; cons = (r, v) -&gt;</b>
<b class="nc">&nbsp;            rows.computeIfAbsent(r, ignore -&gt; new ArrayList&lt;&gt;()).add(v);</b>
<b class="nc">&nbsp;    aggregations.forEach(a -&gt; visitValueNodes(a, new ArrayList&lt;&gt;(), cons));</b>
<b class="nc">&nbsp;    rows.forEach((k, v) -&gt; {</b>
<b class="nc">&nbsp;      if (v.stream().allMatch(val -&gt; val instanceof GroupValue)) {</b>
<b class="nc">&nbsp;        v.forEach(tuple -&gt; {</b>
<b class="nc">&nbsp;          Map&lt;String, Object&gt; groupRow = new LinkedHashMap&lt;&gt;(k.keys);</b>
<b class="nc">&nbsp;          groupRow.put(tuple.getName(), tuple.value());</b>
<b class="nc">&nbsp;          consumer.accept(groupRow);</b>
&nbsp;        });
&nbsp;      } else {
<b class="nc">&nbsp;        Map&lt;String, Object&gt; row = new LinkedHashMap&lt;&gt;(k.keys);</b>
<b class="nc">&nbsp;        v.forEach(val -&gt; row.put(val.getName(), val.value()));</b>
<b class="nc">&nbsp;        consumer.accept(row);</b>
&nbsp;      }
&nbsp;    });
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits Elasticsearch
&nbsp;   * &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html&quot;&gt;mapping
&nbsp;   * properties&lt;/a&gt; and calls consumer for each {@code field / type} pair.
&nbsp;   * Nested fields are represented as {@code foo.bar.qux}.
&nbsp;   */
&nbsp;  static void visitMappingProperties(ObjectNode mapping,
&nbsp;                                     BiConsumer&lt;String, String&gt; consumer) {
<b class="nc">&nbsp;    Objects.requireNonNull(mapping, &quot;mapping&quot;);</b>
<b class="nc">&nbsp;    Objects.requireNonNull(consumer, &quot;consumer&quot;);</b>
<b class="nc">&nbsp;    visitMappingProperties(new ArrayDeque&lt;&gt;(), mapping, consumer);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void visitMappingProperties(Deque&lt;String&gt; path,
&nbsp;                                             ObjectNode mapping, BiConsumer&lt;String, String&gt; consumer) {
<b class="nc">&nbsp;    Objects.requireNonNull(mapping, &quot;mapping&quot;);</b>
<b class="nc">&nbsp;    if (mapping.isMissingNode()) {</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (mapping.has(&quot;properties&quot;)) {</b>
&nbsp;      // recurse
<b class="nc">&nbsp;      visitMappingProperties(path, (ObjectNode) mapping.get(&quot;properties&quot;), consumer);</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (mapping.has(&quot;type&quot;)) {</b>
&nbsp;      // this is leaf (register field / type mapping)
<b class="nc">&nbsp;      consumer.accept(String.join(&quot;.&quot;, path), mapping.get(&quot;type&quot;).asText());</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
&nbsp;    // otherwise continue visiting mapping(s)
<b class="nc">&nbsp;    Iterable&lt;Map.Entry&lt;String, JsonNode&gt;&gt; iter = mapping::fields;</b>
<b class="nc">&nbsp;    for (Map.Entry&lt;String, JsonNode&gt; entry : iter) {</b>
<b class="nc">&nbsp;      final String name = entry.getKey();</b>
<b class="nc">&nbsp;      final ObjectNode node = (ObjectNode) entry.getValue();</b>
<b class="nc">&nbsp;      path.add(name);</b>
<b class="nc">&nbsp;      visitMappingProperties(path, node, consumer);</b>
<b class="nc">&nbsp;      path.removeLast();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Identifies a calcite row (as in relational algebra)
&nbsp;   */
<b class="nc">&nbsp;  private static class RowKey {</b>
&nbsp;    private final Map&lt;String, Object&gt; keys;
&nbsp;    private final int hashCode;
&nbsp;
<b class="nc">&nbsp;    private RowKey(final Map&lt;String, Object&gt; keys) {</b>
<b class="nc">&nbsp;      this.keys = Objects.requireNonNull(keys, &quot;keys&quot;);</b>
<b class="nc">&nbsp;      this.hashCode = Objects.hashCode(keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    private RowKey(List&lt;Bucket&gt; buckets) {
<b class="nc">&nbsp;      this(toMap(buckets));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Map&lt;String, Object&gt; toMap(Iterable&lt;Bucket&gt; buckets) {
<b class="nc">&nbsp;      return StreamSupport.stream(buckets.spliterator(), false)</b>
<b class="nc">&nbsp;              .collect(LinkedHashMap::new,</b>
<b class="nc">&nbsp;                      (m, v) -&gt; m.put(v.getName(), v.key()),</b>
&nbsp;                      LinkedHashMap::putAll);
&nbsp;    }
&nbsp;
&nbsp;    @Override public boolean equals(final Object o) {
<b class="nc">&nbsp;      if (this == o) {</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      final RowKey rowKey = (RowKey) o;</b>
<b class="nc">&nbsp;      return hashCode == rowKey.hashCode</b>
<b class="nc">&nbsp;              &amp;&amp; Objects.equals(keys, rowKey.keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public int hashCode() {
<b class="nc">&nbsp;      return this.hashCode;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static void visitValueNodes(Aggregation aggregation, List&lt;Bucket&gt; parents,
&nbsp;                                      BiConsumer&lt;RowKey, MultiValue&gt; consumer) {
&nbsp;
<b class="nc">&nbsp;    if (aggregation instanceof MultiValue) {</b>
&nbsp;      // this is a leaf. publish value of the row.
<b class="nc">&nbsp;      RowKey key = new RowKey(parents);</b>
<b class="nc">&nbsp;      consumer.accept(key, (MultiValue) aggregation);</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (aggregation instanceof Bucket) {</b>
<b class="nc">&nbsp;      Bucket bucket = (Bucket) aggregation;</b>
<b class="nc">&nbsp;      if (bucket.hasNoAggregations()) {</b>
&nbsp;        // bucket with no aggregations is also considered a leaf node
<b class="nc">&nbsp;        visitValueNodes(GroupValue.of(bucket.getName(), bucket.key()), parents, consumer);</b>
&nbsp;        return;
&nbsp;      }
<b class="nc">&nbsp;      parents.add(bucket);</b>
<b class="nc">&nbsp;      bucket.getAggregations().forEach(a -&gt; visitValueNodes(a, parents, consumer));</b>
<b class="nc">&nbsp;      parents.remove(parents.size() - 1);</b>
<b class="nc">&nbsp;    } else if (aggregation instanceof HasAggregations) {</b>
<b class="nc">&nbsp;      HasAggregations children = (HasAggregations) aggregation;</b>
<b class="nc">&nbsp;      children.getAggregations().forEach(a -&gt; visitValueNodes(a, parents, consumer));</b>
<b class="nc">&nbsp;    } else if (aggregation instanceof MultiBucketsAggregation) {</b>
<b class="nc">&nbsp;      MultiBucketsAggregation multi = (MultiBucketsAggregation) aggregation;</b>
<b class="nc">&nbsp;      multi.buckets().forEach(b -&gt; visitValueNodes(b, parents, consumer));</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Similar to {@code SearchHits} in ES. Container for {@link SearchHit}
&nbsp;   */
&nbsp;  @JsonIgnoreProperties(ignoreUnknown = true)
&nbsp;  static class SearchHits {
&nbsp;
&nbsp;    private final SearchTotal total;
&nbsp;    private final List&lt;SearchHit&gt; hits;
&nbsp;
&nbsp;    @JsonCreator
&nbsp;    SearchHits(@JsonProperty(&quot;total&quot;)final SearchTotal total,
<b class="nc">&nbsp;               @JsonProperty(&quot;hits&quot;) final List&lt;SearchHit&gt; hits) {</b>
<b class="nc">&nbsp;      this.total = total;</b>
<b class="nc">&nbsp;      this.hits = Objects.requireNonNull(hits, &quot;hits&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;SearchHit&gt; hits() {
<b class="nc">&nbsp;      return this.hits;</b>
&nbsp;    }
&nbsp;
&nbsp;    public SearchTotal total() {
<b class="nc">&nbsp;      return total;</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Container for total hits
&nbsp;   */
&nbsp;  @JsonDeserialize(using = SearchTotalDeserializer.class)
&nbsp;  static class SearchTotal {
&nbsp;
&nbsp;    private final long value;
&nbsp;
<b class="nc">&nbsp;    SearchTotal(final long value) {</b>
<b class="nc">&nbsp;      this.value = value;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long value() {
<b class="nc">&nbsp;      return value;</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Allows to de-serialize total hits structures.
&nbsp;   */
&nbsp;  static class SearchTotalDeserializer extends StdDeserializer&lt;SearchTotal&gt; {
&nbsp;
&nbsp;    SearchTotalDeserializer() {
<b class="nc">&nbsp;      super(SearchTotal.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public SearchTotal deserialize(final JsonParser parser,
&nbsp;                                                               final DeserializationContext ctxt)
&nbsp;            throws IOException {
&nbsp;
<b class="nc">&nbsp;      JsonNode node = parser.getCodec().readTree(parser);</b>
<b class="nc">&nbsp;      return parseSearchTotal(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static SearchTotal parseSearchTotal(JsonNode node) {
&nbsp;
&nbsp;      final Number value;
<b class="nc">&nbsp;      if (node.isNumber()) {</b>
<b class="nc">&nbsp;        value = node.numberValue();</b>
&nbsp;      } else {
<b class="nc">&nbsp;        value = node.get(&quot;value&quot;).numberValue();</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return new SearchTotal(value.longValue());</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Concrete result record which matched the query. Similar to {@code SearchHit} in ES.
&nbsp;   */
&nbsp;  @JsonIgnoreProperties(ignoreUnknown = true)
&nbsp;  static class SearchHit {
&nbsp;
&nbsp;    /**
&nbsp;     * ID of the document (not available in aggregations)
&nbsp;     */
&nbsp;    private final String id;
&nbsp;    private final ObjectNode source;
&nbsp;    private final ObjectNode fields;
&nbsp;
&nbsp;    @JsonCreator
&nbsp;    SearchHit(@JsonProperty(&quot;_id&quot;) final String id,
&nbsp;              @JsonProperty(&quot;_source&quot;) final ObjectNode source,
<b class="nc">&nbsp;              @JsonProperty(&quot;fields&quot;) final ObjectNode fields) {</b>
<b class="nc">&nbsp;      this.id = Objects.requireNonNull(id, &quot;id&quot;);</b>
&nbsp;
&nbsp;      // both can&#39;t be null
<b class="nc">&nbsp;      if (source == null &amp;&amp; fields == null) {</b>
<b class="nc">&nbsp;        final String message = String.format(Locale.ROOT,</b>
&nbsp;                &quot;Both &#39;_source&#39; and &#39;fields&#39; are missing for %s&quot;, id);
<b class="nc">&nbsp;        throw new IllegalArgumentException(message);</b>
&nbsp;      }
&nbsp;
&nbsp;      // both can&#39;t be non-null
<b class="nc">&nbsp;      if (source != null &amp;&amp; fields != null) {</b>
<b class="nc">&nbsp;        final String message = String.format(Locale.ROOT,</b>
&nbsp;                &quot;Both &#39;_source&#39; and &#39;fields&#39; are populated (non-null) for %s&quot;, id);
<b class="nc">&nbsp;        throw new IllegalArgumentException(message);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      this.source = source;</b>
<b class="nc">&nbsp;      this.fields = fields;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns id of this hit (usually document id)
&nbsp;     * @return unique id
&nbsp;     */
&nbsp;    public String id() {
<b class="nc">&nbsp;      return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    JsonNode valueOrNull(String name) {
<b class="nc">&nbsp;      Objects.requireNonNull(name, &quot;name&quot;);</b>
&nbsp;
<b class="nc">&nbsp;      if (fields != null &amp;&amp; fields.has(name)) {</b>
<b class="nc">&nbsp;        JsonNode field = fields.get(name);</b>
<b class="nc">&nbsp;        if (field.isArray()) {</b>
&nbsp;          // return first element (or null)
<b class="nc">&nbsp;          Iterator&lt;JsonNode&gt; iter = field.elements();</b>
<b class="nc">&nbsp;          return iter.hasNext() ? iter.next() : null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return field;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      JsonNode found = source().at(name);</b>
<b class="nc">&nbsp;      return found.isMissingNode() ? NullNode.getInstance() : found;</b>
&nbsp;    }
&nbsp;
&nbsp;    ObjectNode source() {
<b class="nc">&nbsp;      return source;</b>
&nbsp;    }
&nbsp;
&nbsp;    ObjectNode fields() {
<b class="nc">&nbsp;      return fields;</b>
&nbsp;    }
&nbsp;
&nbsp;    ObjectNode sourceOrFields() {
<b class="nc">&nbsp;      return source != null ? source : fields;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * {@link Aggregation} container.
&nbsp;   */
&nbsp;  @JsonDeserialize(using = AggregationsDeserializer.class)
&nbsp;  static class Aggregations implements Iterable&lt;Aggregation&gt; {
&nbsp;
&nbsp;    private final List&lt;? extends Aggregation&gt; aggregations;
&nbsp;    private Map&lt;String, Aggregation&gt; aggregationsAsMap;
&nbsp;
<b class="nc">&nbsp;    Aggregations(List&lt;? extends Aggregation&gt; aggregations) {</b>
<b class="nc">&nbsp;      this.aggregations = Objects.requireNonNull(aggregations, &quot;aggregations&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Iterates over the {@link Aggregation}s.
&nbsp;     */
&nbsp;    @Override public final Iterator&lt;Aggregation&gt; iterator() {
<b class="nc">&nbsp;      return asList().iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The list of {@link Aggregation}s.
&nbsp;     */
&nbsp;    final List&lt;Aggregation&gt; asList() {
<b class="nc">&nbsp;      return Collections.unmodifiableList(aggregations);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link Aggregation}s keyed by aggregation name. Lazy init.
&nbsp;     */
&nbsp;    final Map&lt;String, Aggregation&gt; asMap() {
<b class="nc">&nbsp;      if (aggregationsAsMap == null) {</b>
<b class="nc">&nbsp;        Map&lt;String, Aggregation&gt; map = new LinkedHashMap&lt;&gt;(aggregations.size());</b>
<b class="nc">&nbsp;        for (Aggregation aggregation : aggregations) {</b>
<b class="nc">&nbsp;          map.put(aggregation.getName(), aggregation);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        this.aggregationsAsMap = Collections.unmodifiableMap(map);</b>
&nbsp;      }
<b class="nc">&nbsp;      return aggregationsAsMap;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the aggregation that is associated with the specified name.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final &lt;A extends Aggregation&gt; A get(String name) {
<b class="nc">&nbsp;      return (A) asMap().get(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public final boolean equals(Object obj) {
<b class="nc">&nbsp;      if (obj == null || getClass() != obj.getClass()) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      return aggregations.equals(((Aggregations) obj).aggregations);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public final int hashCode() {
<b class="nc">&nbsp;      return Objects.hash(getClass(), aggregations);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Identifies all aggregations
&nbsp;   */
&nbsp;  interface Aggregation {
&nbsp;
&nbsp;    /**
&nbsp;     * @return The name of this aggregation.
&nbsp;     */
&nbsp;    String getName();
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Allows traversing aggregations tree
&nbsp;   */
&nbsp;  interface HasAggregations {
&nbsp;    Aggregations getAggregations();
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * An aggregation that returns multiple buckets
&nbsp;   */
&nbsp;  static class MultiBucketsAggregation implements Aggregation {
&nbsp;
&nbsp;    private final String name;
&nbsp;    private final List&lt;Bucket&gt; buckets;
&nbsp;
&nbsp;    MultiBucketsAggregation(final String name,
<b class="nc">&nbsp;                            final List&lt;Bucket&gt; buckets) {</b>
<b class="nc">&nbsp;      this.name = name;</b>
<b class="nc">&nbsp;      this.buckets = buckets;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return  The buckets of this aggregation.
&nbsp;     */
&nbsp;    List&lt;Bucket&gt; buckets() {
<b class="nc">&nbsp;      return buckets;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String getName() {
<b class="nc">&nbsp;      return name;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * A bucket represents a criteria to which all documents that fall in it adhere to.
&nbsp;   * It is also uniquely identified
&nbsp;   * by a key, and can potentially hold sub-aggregations computed over all documents in it.
&nbsp;   */
&nbsp;  static class Bucket implements HasAggregations, Aggregation {
&nbsp;    private final Object key;
&nbsp;    private final String name;
&nbsp;    private final Aggregations aggregations;
&nbsp;
&nbsp;    Bucket(final Object key,
&nbsp;           final String name,
<b class="nc">&nbsp;           final Aggregations aggregations) {</b>
<b class="nc">&nbsp;      this.key = key; // key can be set after construction</b>
<b class="nc">&nbsp;      this.name = Objects.requireNonNull(name, &quot;name&quot;);</b>
<b class="nc">&nbsp;      this.aggregations = Objects.requireNonNull(aggregations, &quot;aggregations&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The key associated with the bucket
&nbsp;     */
&nbsp;    Object key() {
<b class="nc">&nbsp;      return key;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The key associated with the bucket as a string
&nbsp;     */
&nbsp;    String keyAsString() {
<b class="nc">&nbsp;      return Objects.toString(key());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Means current bucket has no aggregations.
&nbsp;     */
&nbsp;    boolean hasNoAggregations() {
<b class="nc">&nbsp;      return aggregations.asList().isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return  The sub-aggregations of this bucket
&nbsp;     */
&nbsp;    @Override public Aggregations getAggregations() {
<b class="nc">&nbsp;      return aggregations;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String getName() {
<b class="nc">&nbsp;      return name;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Multi value aggregatoin like
&nbsp;   * &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html&quot;&gt;Stats&lt;/a&gt;
&nbsp;   */
&nbsp;  static class MultiValue implements Aggregation {
&nbsp;    private final String name;
&nbsp;    private final Map&lt;String, Object&gt; values;
&nbsp;
<b class="nc">&nbsp;    MultiValue(final String name, final Map&lt;String, Object&gt; values) {</b>
<b class="nc">&nbsp;      this.name = Objects.requireNonNull(name, &quot;name&quot;);</b>
<b class="nc">&nbsp;      this.values = Objects.requireNonNull(values, &quot;values&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String getName() {
<b class="nc">&nbsp;      return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    Map&lt;String, Object&gt; values() {
<b class="nc">&nbsp;      return values;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For single value. Returns single value represented by this leaf aggregation.
&nbsp;     * @return value corresponding to {@code value}
&nbsp;     */
&nbsp;    Object value() {
<b class="nc">&nbsp;      if (!values().containsKey(&quot;value&quot;)) {</b>
<b class="nc">&nbsp;        String message = String.format(Locale.ROOT, &quot;&#39;value&#39; field not present in &quot;</b>
<b class="nc">&nbsp;                + &quot;%s aggregation&quot;, getName());</b>
&nbsp;
<b class="nc">&nbsp;        throw new IllegalStateException(message);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return values().get(&quot;value&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Distinguishes from {@link MultiValue}.
&nbsp;   * In order that rows which have the same key can be put into result map.
&nbsp;   */
&nbsp;  static class GroupValue extends MultiValue {
&nbsp;    GroupValue(String name, Map&lt;String, Object&gt; values) {
<b class="nc">&nbsp;      super(name, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a {@link GroupValue} instance with a single value.
&nbsp;     */
&nbsp;    static GroupValue of(String name, Object value) {
<b class="nc">&nbsp;      return new GroupValue(name, Collections.singletonMap(&quot;value&quot;, value));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Allows to de-serialize nested aggregation structures.
&nbsp;   */
&nbsp;  static class AggregationsDeserializer extends StdDeserializer&lt;Aggregations&gt; {
&nbsp;
<b class="nc">&nbsp;    private static final Set&lt;String&gt; IGNORE_TOKENS =</b>
<b class="nc">&nbsp;            ImmutableSet.of(&quot;meta&quot;, &quot;buckets&quot;, &quot;value&quot;, &quot;values&quot;, &quot;value_as_string&quot;,</b>
&nbsp;                    &quot;doc_count&quot;, &quot;key&quot;, &quot;key_as_string&quot;);
&nbsp;
&nbsp;    AggregationsDeserializer() {
<b class="nc">&nbsp;      super(Aggregations.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public Aggregations deserialize(final JsonParser parser,
&nbsp;                                                                final DeserializationContext ctxt)
&nbsp;            throws IOException  {
&nbsp;
<b class="nc">&nbsp;      ObjectNode node = parser.getCodec().readTree(parser);</b>
<b class="nc">&nbsp;      return parseAggregations(parser, node);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Aggregations parseAggregations(JsonParser parser, ObjectNode node)
&nbsp;            throws JsonProcessingException {
&nbsp;
<b class="nc">&nbsp;      List&lt;Aggregation&gt; aggregations = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;      Iterable&lt;Map.Entry&lt;String, JsonNode&gt;&gt; iter = node::fields;</b>
<b class="nc">&nbsp;      for (Map.Entry&lt;String, JsonNode&gt; entry : iter) {</b>
<b class="nc">&nbsp;        final String name = entry.getKey();</b>
<b class="nc">&nbsp;        final JsonNode value = entry.getValue();</b>
&nbsp;
<b class="nc">&nbsp;        Aggregation agg = null;</b>
<b class="nc">&nbsp;        if (value.has(&quot;buckets&quot;)) {</b>
<b class="nc">&nbsp;          agg = parseBuckets(parser, name, (ArrayNode) value.get(&quot;buckets&quot;));</b>
<b class="nc">&nbsp;        } else if (value.isObject() &amp;&amp; !IGNORE_TOKENS.contains(name)) {</b>
&nbsp;          // leaf
<b class="nc">&nbsp;          agg = parseValue(parser, name, (ObjectNode) value);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (agg != null) {</b>
<b class="nc">&nbsp;          aggregations.add(agg);</b>
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return new Aggregations(aggregations);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    private static MultiValue parseValue(JsonParser parser, String name, ObjectNode node)
&nbsp;            throws JsonProcessingException {
&nbsp;      @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;      Map&lt;String, Object&gt; values = (Map&lt;String, Object&gt;) parser.getCodec().treeToValue(node, Map.class);</b>
<b class="nc">&nbsp;      return new MultiValue(name, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Aggregation parseBuckets(JsonParser parser, String name, ArrayNode nodes)
&nbsp;            throws JsonProcessingException {
&nbsp;
<b class="nc">&nbsp;      List&lt;Bucket&gt; buckets = new ArrayList&lt;&gt;(nodes.size());</b>
<b class="nc">&nbsp;      for (JsonNode b: nodes) {</b>
<b class="nc">&nbsp;        buckets.add(parseBucket(parser, name, (ObjectNode) b));</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      return new MultiBucketsAggregation(name, buckets);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if current key is a missing field key. Missing key is returned when document
&nbsp;     * does not have pivoting attribute (example {@code GROUP BY _MAP[&#39;a.b.missing&#39;]}). It helps
&nbsp;     * grouping documents which don&#39;t have a field. In relational algebra this
&nbsp;     * would normally be {@code null}.
&nbsp;     *
&nbsp;     * &lt;p&gt;Please note that missing value is different for each type.
&nbsp;     *
&nbsp;     * @param key current {@code key} (usually string) as returned by ES
&nbsp;     * @return {@code true} if this value
&nbsp;     */
&nbsp;    private static boolean isMissingBucket(JsonNode key) {
<b class="nc">&nbsp;      return Mapping.Datatype.isMissingValue(key);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Bucket parseBucket(JsonParser parser, String name, ObjectNode node)
&nbsp;            throws JsonProcessingException  {
&nbsp;
<b class="nc">&nbsp;      if (!node.has(&quot;key&quot;)) {</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;No &#39;key&#39; attribute for &quot; + node);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      final JsonNode keyNode = node.get(&quot;key&quot;);</b>
&nbsp;      final Object key;
<b class="nc">&nbsp;      if (isMissingBucket(keyNode) || keyNode.isNull()) {</b>
<b class="nc">&nbsp;        key = null;</b>
<b class="nc">&nbsp;      } else if (keyNode.isTextual()) {</b>
<b class="nc">&nbsp;        key = keyNode.textValue();</b>
<b class="nc">&nbsp;      } else if (keyNode.isNumber()) {</b>
<b class="nc">&nbsp;        key = keyNode.numberValue();</b>
<b class="nc">&nbsp;      } else if (keyNode.isBoolean()) {</b>
<b class="nc">&nbsp;        key = keyNode.booleanValue();</b>
&nbsp;      } else {
&nbsp;        // don&#39;t usually expect keys to be Objects
<b class="nc">&nbsp;        key = parser.getCodec().treeToValue(node, Map.class);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      return new Bucket(key, name, parseAggregations(parser, node));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
