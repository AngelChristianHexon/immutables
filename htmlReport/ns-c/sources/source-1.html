


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AggregateQueryBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.immutables.criteria.elasticsearch</a>
</div>

<h1>Coverage Summary for Class: AggregateQueryBuilder (org.immutables.criteria.elasticsearch)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AggregateQueryBuilder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AggregateQueryBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/84)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2019 Immutables Authors and Contributors
&nbsp; * Copyright 2016-2018 Apache Software Foundation (ASF)
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.immutables.criteria.elasticsearch;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.ObjectMapper;
&nbsp;import com.fasterxml.jackson.databind.node.JsonNodeFactory;
&nbsp;import com.fasterxml.jackson.databind.node.NullNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.base.Converter;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import com.google.common.collect.Maps;
&nbsp;import org.immutables.criteria.backend.PathNaming;
&nbsp;import org.immutables.criteria.backend.ProjectedTuple;
&nbsp;import org.immutables.criteria.backend.UniqueCachedNaming;
&nbsp;import org.immutables.criteria.expression.AggregationOperators;
&nbsp;import org.immutables.criteria.expression.Call;
&nbsp;import org.immutables.criteria.expression.Collation;
&nbsp;import org.immutables.criteria.expression.Expression;
&nbsp;import org.immutables.criteria.expression.Path;
&nbsp;import org.immutables.criteria.expression.Query;
&nbsp;import org.immutables.criteria.expression.Visitors;
&nbsp;
&nbsp;import java.time.Instant;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Helps build aggregate query in elastic
&nbsp; *
&nbsp; * &lt;p&gt;Some parts of this class have been copied from &lt;a href=&quot;https://calcite.apache.org/&quot;&gt;Apache Calcite&lt;/a&gt; project.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&quot;&gt;Search Aggregations&lt;/a&gt;
&nbsp; */
&nbsp;class AggregateQueryBuilder {
&nbsp;
&nbsp;  /**
&nbsp;   * Used for constructing (possibly nested) Elastic aggregation nodes.
&nbsp;   */
&nbsp;  private static final String AGGREGATIONS = &quot;aggregations&quot;;
&nbsp;
&nbsp;
&nbsp;  private final Query query;
&nbsp;  private final Mapping mapping;
&nbsp;  private final UniqueCachedNaming&lt;Expression&gt; naming;
&nbsp;  private final ObjectMapper mapper;
&nbsp;  private final JsonNodeFactory nodeFactory;
&nbsp;  private final PathNaming pathNaming;
&nbsp;  private final Predicate&lt;Path&gt; idPredicate;
&nbsp;
<b class="nc">&nbsp;  AggregateQueryBuilder(Query query, ObjectMapper mapper, Mapping mapping, PathNaming pathNaming, Predicate&lt;Path&gt; idPredicate) {</b>
<b class="nc">&nbsp;    this.query = Objects.requireNonNull(query, &quot;query&quot;);</b>
<b class="nc">&nbsp;    Preconditions.checkArgument(query.hasAggregations(), &quot;no aggregations for query %s&quot;, query);</b>
<b class="nc">&nbsp;    this.mapping = mapping;</b>
<b class="nc">&nbsp;    this.pathNaming = pathNaming;</b>
<b class="nc">&nbsp;    List&lt;Expression&gt; toName = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    toName.addAll(query.projections());</b>
<b class="nc">&nbsp;    toName.addAll(query.collations().stream().map(Collation::expression).collect(Collectors.toList()));</b>
<b class="nc">&nbsp;    toName.addAll(query.groupBy());</b>
<b class="nc">&nbsp;    naming = UniqueCachedNaming.of(toName);</b>
<b class="nc">&nbsp;    this.mapper = mapper;</b>
<b class="nc">&nbsp;    this.nodeFactory = mapper.getNodeFactory();</b>
<b class="nc">&nbsp;    this.idPredicate = idPredicate;</b>
&nbsp;  }
&nbsp;
&nbsp;  ObjectNode jsonQuery() {
&nbsp;
<b class="nc">&nbsp;    if (!query.groupBy().isEmpty() &amp;&amp; query.offset().isPresent()) {</b>
<b class="nc">&nbsp;      String message = &quot;Currently ES doesn&#39;t support generic pagination &quot;</b>
&nbsp;              + &quot;with aggregations. You can still use LIMIT keyword (without OFFSET). &quot;
&nbsp;              + &quot;For more details see https://github.com/elastic/elasticsearch/issues/4915&quot;;
<b class="nc">&nbsp;      throw new UnsupportedOperationException(message);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    final ObjectNode json = nodeFactory.objectNode();</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    json.put(&quot;_source&quot;, false);</b>
<b class="nc">&nbsp;    json.put(&quot;size&quot;, 0);</b>
<b class="nc">&nbsp;    json.put(&quot;stored_fields&quot;, &quot;_none_&quot;); // avoid fetch phase</b>
&nbsp;
<b class="nc">&nbsp;    query.filter().ifPresent(f -&gt; json.set(&quot;query&quot;, Elasticsearch.constantScoreQuery(mapper, pathNaming, idPredicate).convert(f)));</b>
&nbsp;
&nbsp;    // due to ES aggregation format. fields in &quot;order by&quot; clause should go first
&nbsp;    // if &quot;order by&quot; is missing. order in &quot;group by&quot; is un-important
<b class="nc">&nbsp;    final Set&lt;Expression&gt; orderedGroupBy = new LinkedHashSet&lt;&gt;();</b>
<b class="nc">&nbsp;    orderedGroupBy.addAll(query.collations().stream().map(Collation::expression).collect(Collectors.toList()));</b>
<b class="nc">&nbsp;    orderedGroupBy.addAll(query.groupBy());</b>
&nbsp;
&nbsp;    // construct nested aggregations node(s)
<b class="nc">&nbsp;    ObjectNode parent = json.with(AGGREGATIONS);</b>
<b class="nc">&nbsp;    for (Expression expr: orderedGroupBy) {</b>
<b class="nc">&nbsp;      final String name = ((Path) expr).toStringPath();</b>
<b class="nc">&nbsp;      final String aggName = naming.apply(expr);</b>
<b class="nc">&nbsp;      final ObjectNode section = parent.with(aggName);</b>
<b class="nc">&nbsp;      final ObjectNode terms = section.with(&quot;terms&quot;);</b>
<b class="nc">&nbsp;      terms.put(&quot;field&quot;, name);</b>
&nbsp;
<b class="nc">&nbsp;      mapping.missingValueFor(name).ifPresent(m -&gt; {</b>
&nbsp;        // expose missing terms. each type has a different missing value
<b class="nc">&nbsp;        terms.set(&quot;missing&quot;, m);</b>
&nbsp;      });
&nbsp;
<b class="nc">&nbsp;      query.limit().ifPresent(limit -&gt;terms.put(&quot;size&quot;, limit));</b>
&nbsp;
<b class="nc">&nbsp;      query.collations().stream()</b>
<b class="nc">&nbsp;              .filter(c -&gt; c.path().toStringPath().equals(name))</b>
<b class="nc">&nbsp;              .findAny()</b>
<b class="nc">&nbsp;              .ifPresent(col -&gt; terms.with(&quot;order&quot;).put(&quot;_key&quot;, col.direction().isAscending() ? &quot;asc&quot; : &quot;desc&quot;));</b>
&nbsp;
<b class="nc">&nbsp;      parent = section.with(AGGREGATIONS);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    for (Expression expr: query.projections()) {</b>
<b class="nc">&nbsp;      if (Visitors.isAggregationCall(expr)) {</b>
<b class="nc">&nbsp;        Call call = Visitors.toCall(expr);</b>
<b class="nc">&nbsp;        ObjectNode agg = nodeFactory.objectNode();</b>
<b class="nc">&nbsp;        String field = ((Path) call.arguments().get(0)).toStringPath();</b>
<b class="nc">&nbsp;        agg.with(toElasticAggregate(call)).put(&quot;field&quot;, field);</b>
<b class="nc">&nbsp;        parent.set(naming.apply(call), agg);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // cleanup json. remove empty &quot;aggregations&quot; element (if empty)
<b class="nc">&nbsp;    removeEmptyAggregation(json);</b>
<b class="nc">&nbsp;    return json;</b>
&nbsp;  }
&nbsp;
&nbsp;  List&lt;ProjectedTuple&gt; processResult(Json.Result result) {
&nbsp;
<b class="nc">&nbsp;    final List&lt;ProjectedTuple&gt; tuples = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    if (result.aggregations() != null) {</b>
<b class="nc">&nbsp;      Converter&lt;String, Expression&gt; converter = naming.asConverter().reverse();</b>
&nbsp;      // collect values
<b class="nc">&nbsp;      Json.visitValueNodes(result.aggregations(), m -&gt; {</b>
<b class="nc">&nbsp;        Map&lt;Expression, Object&gt; values = Maps.newHashMapWithExpectedSize(query.projections().size());</b>
&nbsp;
<b class="nc">&nbsp;        for (String field: m.keySet()) {</b>
<b class="nc">&nbsp;          Expression expression = converter.convert(field);</b>
<b class="nc">&nbsp;          Object value = m.get(field);</b>
<b class="nc">&nbsp;          if (value == null) {</b>
&nbsp;            // otherwise jackson returns null even for optionals
<b class="nc">&nbsp;            value = NullNode.getInstance();</b>
<b class="nc">&nbsp;          } else if (value instanceof Number &amp;&amp; (expression.returnType() == LocalDate.class || expression.returnType() == LocalDateTime.class)) {</b>
&nbsp;            // hack/work-around because JavaTimeModule doesn&#39;t handle epoch millis for LocalDate and LocalDateTime
&nbsp;            // and elastic always returns epoch millis
&nbsp;            // this ideally should be handled directly by Deserializer
<b class="nc">&nbsp;            Instant instant = Instant.ofEpochMilli(((Number) value).longValue());</b>
<b class="nc">&nbsp;            value = nodeFactory.textNode(instant.toString());</b>
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          values.put(expression, mapper.convertValue(value, mapper.getTypeFactory().constructType(expression.returnType())));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Object&gt; projections = query.projections().stream().map(values::get).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        tuples.add(ProjectedTuple.of(query.projections(), projections));</b>
&nbsp;      });
&nbsp;    }
&nbsp;
&nbsp;    // elastic exposes total number of documents matching a query in &quot;/hits/total&quot; path
&nbsp;    // this can be used for simple &quot;select count(*) from table&quot;
<b class="nc">&nbsp;    final long total = result.searchHits().total().value();</b>
&nbsp;
<b class="nc">&nbsp;    return tuples;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static void removeEmptyAggregation(JsonNode node) {
<b class="nc">&nbsp;    if (!node.has(AGGREGATIONS)) {</b>
<b class="nc">&nbsp;      node.elements().forEachRemaining(AggregateQueryBuilder::removeEmptyAggregation);</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    JsonNode agg = node.get(AGGREGATIONS);</b>
<b class="nc">&nbsp;    if (agg.size() == 0) {</b>
<b class="nc">&nbsp;      ((ObjectNode) node).remove(AGGREGATIONS);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      removeEmptyAggregation(agg);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Most of the aggregations can be retrieved with single
&nbsp;   * &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html&quot;&gt;stats&lt;/a&gt;
&nbsp;   * function. But currently only one-to-one mapping is supported between sql agg and elastic
&nbsp;   * aggregation.
&nbsp;   */
&nbsp;  private static String toElasticAggregate(Call call) {
<b class="nc">&nbsp;    final AggregationOperators kind = (AggregationOperators) call.operator();</b>
<b class="nc">&nbsp;    switch (kind) {</b>
&nbsp;      case COUNT:
<b class="nc">&nbsp;        return &quot;value_count&quot;;</b>
&nbsp;      case SUM:
<b class="nc">&nbsp;        return &quot;sum&quot;;</b>
&nbsp;      case MIN:
<b class="nc">&nbsp;        return &quot;min&quot;;</b>
&nbsp;      case MAX:
<b class="nc">&nbsp;        return &quot;max&quot;;</b>
&nbsp;      case AVG:
<b class="nc">&nbsp;        return &quot;avg&quot;;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Unknown aggregation kind &quot; + kind + &quot; for &quot; + call);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 15:34</div>
</div>
</body>
</html>
